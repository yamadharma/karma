diff -ruN linux-2.4.20-wolk4.0-fullkernel/Documentation/Configure.help linux-2.4.20-wolk4.0-fullkernel.mipl/Documentation/Configure.help
--- linux-2.4.20-wolk4.0-fullkernel/Documentation/Configure.help	2003-05-12 17:36:21.000000000 +0200
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/Documentation/Configure.help	2003-05-18 11:33:53.000000000 +0200
@@ -7997,6 +7997,58 @@
 
   It is safe to say N here for now.
 
+IPv6: IPv6 over IPv6 Tunneling (EXPERIMENTAL)
+CONFIG_IPV6_IPV6_TUNNEL
+  Experimental IP6-IP6 tunneling.  You must select this, if you want
+  to use CONFIG_IPV6_MOBILITY.  More information in MIPL Mobile IPv6
+  instructions.
+
+  If you don't want IP6-IP6 tunnels and Mobile IPv6, say N.
+
+IPv6: Mobility Support (EXPERIMENTAL)
+CONFIG_IPV6_MOBILITY
+  This is experimental support for the upcoming specification of
+  Mobile IPv6. Mobile IPv6 allows nodes to seamlessly move between
+  networks without changing their IP addresses, thus allowing them to
+  maintain upper layer connections (e.g. TCP).  Selecting this option
+  allows your computer to act as a Correspondent Node (CN).  A MIPv6
+  Mobile Node will be able to communicate with the CN and use route
+  optimization.
+
+  For more information and configuration details, see
+  http://www.mipl.mediapoli.com/.
+
+  If unsure, say N.
+
+MIPv6: Mobile Node Support
+CONFIG_IPV6_MOBILITY_MN
+  If you want your computer to be a MIPv6 Mobile Node (MN), select
+  this option.  You must configure MN using the userspace tools
+  available at http://www.mipl.mediapoli.com/download/mipv6-tools/.
+
+  If your computer is stationary, or you are unsure if you need this,
+  say N.  Note that you will need a properly configured MIPv6 Home
+  Agent to use any Mobile Nodes.
+
+MIPv6: Home Agent Support
+CONFIG_IPV6_MOBILITY_HA
+  If you want your router to serve as a MIPv6 Home Agent (HA), select
+  this option.  You must configure HA using the userspace tools
+  available at http://www.mipl.mediapoli.com/download/mipv6-tools/.
+
+  If your computer is not a router, or you are unsure if you need
+  this, say N.
+
+MIPv6: Debug messages
+CONFIG_IPV6_MOBILITY_DEBUG
+  MIPL Mobile IPv6 can produce a lot of debugging messages. There are
+  eight debug levels (0 through 7) and the level is controlled via
+  /proc/sys/net/ipv6/mobility/debuglevel. Since MIPL is still
+  experimental, you might want to say Y here.
+
+  Be sure to say Y and record debug messages when submitting a bug
+  report.
+
 Kernel httpd acceleration
 CONFIG_KHTTPD
   The kernel httpd acceleration daemon (kHTTPd) is a (limited) web
diff -ruN linux-2.4.20-wolk4.0-fullkernel/Documentation/DocBook/Makefile linux-2.4.20-wolk4.0-fullkernel.mipl/Documentation/DocBook/Makefile
--- linux-2.4.20-wolk4.0-fullkernel/Documentation/DocBook/Makefile	2002-12-18 01:03:44.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/Documentation/DocBook/Makefile	2003-05-18 11:33:53.000000000 +0200
@@ -2,7 +2,7 @@
 	   kernel-api.sgml parportbook.sgml kernel-hacking.sgml \
 	   kernel-locking.sgml via-audio.sgml mousedrivers.sgml sis900.sgml \
 	   deviceiobook.sgml procfs-guide.sgml tulip-user.sgml \
-	   journal-api.sgml
+	   journal-api.sgml mip6-func.sgml
 
 PS	:=	$(patsubst %.sgml, %.ps, $(BOOKS))
 PDF	:=	$(patsubst %.sgml, %.pdf, $(BOOKS))
@@ -86,6 +86,9 @@
 procfs-guide.sgml:  procfs-guide.tmpl procfs_example.sgml
 	$(TOPDIR)/scripts/docgen < procfs-guide.tmpl >$@
 
+mip6-func.sgml: mip6-func.tmpl
+	$(TOPDIR)/scripts/docgen <$< >$@
+
 APISOURCES :=	$(TOPDIR)/drivers/media/video/videodev.c \
 		$(TOPDIR)/arch/i386/kernel/irq.c \
 		$(TOPDIR)/arch/i386/kernel/mca.c \
diff -ruN linux-2.4.20-wolk4.0-fullkernel/Documentation/DocBook/mip6-func.tmpl linux-2.4.20-wolk4.0-fullkernel.mipl/Documentation/DocBook/mip6-func.tmpl
--- linux-2.4.20-wolk4.0-fullkernel/Documentation/DocBook/mip6-func.tmpl	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/Documentation/DocBook/mip6-func.tmpl	2003-05-18 11:33:53.000000000 +0200
@@ -0,0 +1,756 @@
+<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook V3.1//EN"[]>
+<book id="LinuxMobileIPv6">
+ <bookinfo>
+  <title>MIPL Mobile IPv6 Function Reference Guide</title>
+
+  <authorgroup>
+    <author>
+      <othername>MIPL Mobile IPv6 for Linux Team</othername>
+      <affiliation>
+       <orgname>Helsinki University of Technology</orgname>
+       <orgdiv>Telecommunications Software and Multimedia Lab</orgdiv>
+       <address>
+        <pob>PO BOX 9201</pob>
+	<postcode>FIN-02015 HUT</postcode>
+	<country>Finland</country>
+        <email>mipl@list.mipl.mediapoli.com</email>
+       </address>
+      </affiliation>
+     </author>
+  </authorgroup>
+
+  <copyright>
+   <year>2000-2001</year>
+   <holder>Helsinki University of Technology</holder>
+  </copyright>
+ 
+  <legalnotice>
+   <para>
+     Copyright (c) 2001, 2002 MIPL Mobile IPv6 for Linux Team.
+   </para>
+   <para>
+     Permission is granted to copy, distribute and/or modify this
+     document under the terms of the GNU Free Documentation License,
+     Version 1.1 published by the Free Software Foundation; with the
+     Invariant Sections being "Introduction", with the Front-Cover
+     Texts being "MIPL Mobile IPv6 Function Reference Guide", "MIPL
+     Mobile IPv6 for Linux Team" and "Helsinki University of
+     Technology".  A copy of the license is included in <xref
+     linkend="gfdl">.
+   </para>
+      
+  </legalnotice>
+ </bookinfo>
+
+<toc></toc>
+
+  <preface id="intro">
+     <title>Introduction</title>
+
+     <para>
+       MIPL Mobile IPv6 for Linux is an implementation of Mobility
+       Support in IPv6 IETF mobile-ip working groups Internet-Draft
+       (draft-ietf-mobileip-ipv6).  This implementation has been
+       developed in the Telecommunications Software and Multimedia
+       Laboratory at Helsinki University of Technology.
+     </para>
+
+     <para>
+       MIPL is fully open source, licensed under the GNU General
+       Public License.  Latest source for MIPL can be downloaded from
+       the MIPL website at:
+     </para>
+     <programlisting>
+       http://www.mipl.mediapoli.com/.
+     </programlisting>
+     <para>
+       Developers and users interested in MIPL can subscribe to the
+       MIPL mailing list by sending e-mail to
+       <email>majordomo@list.mipl.mediapoli.com</email> with
+     </para>
+     <programlisting>
+       subscribe mipl
+     </programlisting>
+     <para>
+       in the body of the message.
+     </para>
+
+     <para>
+       This document is a reference guide to MIPL functions.  Intended
+       audience is developers wishing to contribute to the project.
+       Hopefully this document will make it easier and quicker to
+       understand and adopt the inner workings of MIPL Mobile IPv6.
+     </para>
+
+     <para>
+       MIPL Mobile IPv6 for Linux Team members (past and present):
+
+       <itemizedlist>
+        <listitem>
+	<address>
+	Sami Kivisaari <email>Sami.Kivisaari@hut.fi</email>
+	</address>
+        </listitem>
+        <listitem>
+	<address>
+	Niklas Kampe <email>Niklas.Kampe@hut.fi</email>
+	</address>
+        </listitem>
+        <listitem>
+	<address>
+	Juha Mynttinen <email>Juha.Mynttinen@hut.fi</email>
+	</address>
+        </listitem>
+        <listitem>
+	<address>
+	Toni Nykanen <email>Toni.Nykanen@iki.fi</email>
+	</address>
+        </listitem>
+        <listitem>
+	<address>
+	Henrik Petander <email>Henrik.Petander@hut.fi</email>
+	</address>
+        </listitem>
+        <listitem>
+	<address>
+	Antti Tuominen <email>ajtuomin@tml.hut.fi</email>
+	</address>
+        </listitem>
+       </itemizedlist>
+
+       <itemizedlist>
+        <listitem>
+	<address>
+	Marko Myllynen
+	</address>
+        </listitem>
+        <listitem>
+	<address>
+	Ville Nuorvala <email>Ville.Nuorvala@hut.fi</email>
+	</address>
+        </listitem>
+        <listitem>
+	<address>
+	Jaakko Laine <email>Jaakko.Laine@hut.fi</email>
+	</address>
+        </listitem>
+       </itemizedlist>
+     </para>
+
+  </preface>
+
+  <chapter id="common">
+     <title>Common functions for all entities</title>
+
+     <sect1><title>Low-level functions</title>
+     <para>
+       These functions implement memory allocation used by others.
+       Hashlist functions implement a linked list with hash lookup,
+       which is used with Binding Update List, Binding Cache, Home
+       Agents List etc.
+     </para>
+!Inet/ipv6/mobile_ip6/mempool.h
+!Inet/ipv6/mobile_ip6/hashlist.h
+     </sect1>
+
+     <sect1><title>Debug functions</title>
+     <para>
+       Debug and utility functions.  These functions are available if
+       <constant>CONFIG_IPV6_MOBILITY_DEBUG</constant> is set.
+       Otherwise macros expand to no operation.
+     </para>
+!Inet/ipv6/mobile_ip6/debug.h
+!Inet/ipv6/mobile_ip6/mipv6.c
+     </sect1>
+
+     <sect1><title>Extension Header functions</title>
+     <para>
+       These functions create and handle extension headers that are
+       specific to MIPv6.
+     </para>
+!Inet/ipv6/mobile_ip6/exthdrs.c
+     </sect1>
+
+     <sect1><title>Mobility Header functions</title>
+     <para>
+       MIPv6 specifies a new protocol called Mobility Header.
+       Mobility Header has several message types.  Messages may also
+       carry Mobility Options.  These functions are used to create and
+       handle Mobility Headers and Mobility Options.
+     </para>
+!Inet/ipv6/mobile_ip6/sendopts.c
+!Inet/ipv6/mobile_ip6/mh_recv.c
+!Inet/ipv6/mobile_ip6/auth_subopt.c
+     </sect1>
+
+     <sect1><title>Binding Cache</title>
+     <para>
+       All Mobile IPv6 entities have a binding cache.  These functions
+       provide easy manipulation of the binding cache.
+     </para>
+!Inet/ipv6/mobile_ip6/bcache.c
+     </sect1>
+
+     <sect1><title>Security</title>
+
+     <para>
+       These functions are common authentication functions and
+       implement Draft 13 style IPSec AH support for Binding Updates.
+     </para>
+!Inet/ipv6/mobile_ip6/ah_algo.c
+!Inet/ipv6/mobile_ip6/sadb.c
+!Inet/ipv6/mobile_ip6/ah.c
+     </sect1>
+
+     <sect1><title>Utility functions</title>
+
+     <para>
+       These functions are general utility functions commonly used by
+       all entities.
+     </para>
+!Inet/ipv6/mobile_ip6/util.c
+     </sect1>
+
+  </chapter>
+
+  <chapter id="mn">
+     <title>Mobile Node functions</title>
+     <sect1><title>General functions</title>
+     <para>
+     </para>
+!Inet/ipv6/mobile_ip6/mn.c
+     </sect1>
+
+     <sect1><title>Binding Update List</title>
+     <para>
+       Mobile Node keeps track of sent binding updates in Binding
+       Update List.
+     </para>
+!Inet/ipv6/mobile_ip6/bul.c
+     </sect1>
+
+     <sect1><title>Movement detection</title>
+
+     <para>
+       These functions are used by the mobile node for movement
+       detection.
+     </para>
+!Inet/ipv6/mobile_ip6/mdetect.c
+     </sect1>
+  </chapter>
+
+  <chapter id="ha">
+     <title>Home Agent functions</title>
+     <sect1><title>General functions</title>
+     <para>
+     </para>
+!Inet/ipv6/mobile_ip6/ha.c
+     </sect1>
+
+     <sect1><title>Duplicate Address Detection functions</title>
+     <para>
+       Home Agent does Duplicate Address Detection for Mobile Nodes'
+       addresses.  These functions implement MIPv6 specific DAD
+       functionality.
+     </para>
+!Inet/ipv6/mobile_ip6/dad.c
+     </sect1>
+
+  </chapter>
+  <appendix id="gfdl">
+     <title>GNU Free Documentation License</title>
+
+     <para>
+       Version 1.1, March 2000
+     </para>
+
+     <programlisting>
+       Copyright (C) 2000  Free Software Foundation, Inc.
+       59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+       Everyone is permitted to copy and distribute verbatim copies
+       of this license document, but changing it is not allowed.
+     </programlisting>
+
+     <sect1><title>0. PREAMBLE</title>
+
+     <para>
+       The purpose of this License is to make a manual, textbook, or
+       other written document "free" in the sense of freedom: to
+       assure everyone the effective freedom to copy and redistribute
+       it, with or without modifying it, either commercially or
+       noncommercially. Secondarily, this License preserves for the
+       author and publisher a way to get credit for their work, while
+       not being considered responsible for modifications made by
+       others.
+     </para>
+
+     <para>
+       This License is a kind of "copyleft", which means that
+       derivative works of the document must themselves be free in the
+       same sense. It complements the GNU General Public License,
+       which is a copyleft license designed for free software.
+     </para>
+
+     <para>
+       We have designed this License in order to use it for manuals
+       for free software, because free software needs free
+       documentation: a free program should come with manuals
+       providing the same freedoms that the software does. But this
+       License is not limited to software manuals; it can be used for
+       any textual work, regardless of subject matter or whether it is
+       published as a printed book. We recommend this License
+       principally for works whose purpose is instruction or
+       reference.
+     </para>
+
+     </sect1>
+     <sect1><title>1. APPLICABILITY AND DEFINITIONS</title>
+
+     <para>
+       This License applies to any manual or other work that contains
+       a notice placed by the copyright holder saying it can be
+       distributed under the terms of this License. The "Document",
+       below, refers to any such manual or work. Any member of the
+       public is a licensee, and is addressed as "you".
+     </para>
+
+     <para>
+       A "Modified Version" of the Document means any work containing
+       the Document or a portion of it, either copied verbatim, or
+       with modifications and/or translated into another language.
+     </para>
+
+     <para>
+       A "Secondary Section" is a named appendix or a front-matter
+       section of the Document that deals exclusively with the
+       relationship of the publishers or authors of the Document to
+       the Document's overall subject (or to related matters) and
+       contains nothing that could fall directly within that overall
+       subject. (For example, if the Document is in part a textbook of
+       mathematics, a Secondary Section may not explain any
+       mathematics.) The relationship could be a matter of historical
+       connection with the subject or with related matters, or of
+       legal, commercial, philosophical, ethical or political position
+       regarding them.
+     </para>
+
+     <para>
+       The "Invariant Sections" are certain Secondary Sections whose
+       titles are designated, as being those of Invariant Sections, in
+       the notice that says that the Document is released under this
+       License.
+     </para>
+
+     <para>
+       The "Cover Texts" are certain short passages of text that are
+       listed, as Front-Cover Texts or Back-Cover Texts, in the notice
+       that says that the Document is released under this License.
+     </para>
+
+     <para>
+       A "Transparent" copy of the Document means a machine-readable
+       copy, represented in a format whose specification is available
+       to the general public, whose contents can be viewed and edited
+       directly and straightforwardly with generic text editors or
+       (for images composed of pixels) generic paint programs or (for
+       drawings) some widely available drawing editor, and that is
+       suitable for input to text formatters or for automatic
+       translation to a variety of formats suitable for input to text
+       formatters. A copy made in an otherwise Transparent file format
+       whose markup has been designed to thwart or discourage
+       subsequent modification by readers is not Transparent. A copy
+       that is not "Transparent" is called "Opaque".
+     </para>
+
+     <para>
+       Examples of suitable formats for Transparent copies include
+       plain ASCII without markup, Texinfo input format, LaTeX input
+       format, SGML or XML using a publicly available DTD, and
+       standard-conforming simple HTML designed for human
+       modification. Opaque formats include PostScript, PDF,
+       proprietary formats that can be read and edited only by
+       proprietary word processors, SGML or XML for which the DTD
+       and/or processing tools are not generally available, and the
+       machine-generated HTML produced by some word processors for
+       output purposes only.
+     </para>
+
+     <para>
+       The "Title Page" means, for a printed book, the title page
+       itself, plus such following pages as are needed to hold,
+       legibly, the material this License requires to appear in the
+       title page. For works in formats which do not have any title
+       page as such, "Title Page" means the text near the most
+       prominent appearance of the work's title, preceding the
+       beginning of the body of the text.
+     </para>
+
+     </sect1>
+     <sect1><title>2. VERBATIM COPYING</title>
+
+     <para>
+       You may copy and distribute the Document in any medium, either
+       commercially or noncommercially, provided that this License,
+       the copyright notices, and the license notice saying this
+       License applies to the Document are reproduced in all copies,
+       and that you add no other conditions whatsoever to those of
+       this License. You may not use technical measures to obstruct or
+       control the reading or further copying of the copies you make
+       or distribute. However, you may accept compensation in exchange
+       for copies. If you distribute a large enough number of copies
+       you must also follow the conditions in section 3.
+     </para>
+
+     <para>
+       You may also lend copies, under the same conditions stated
+       above, and you may publicly display copies.
+     </para>
+
+     </sect1>
+     <sect1><title>3. COPYING IN QUANTITY</title>
+
+     <para>
+       If you publish printed copies of the Document numbering more
+       than 100, and the Document's license notice requires Cover
+       Texts, you must enclose the copies in covers that carry,
+       clearly and legibly, all these Cover Texts: Front-Cover Texts
+       on the front cover, and Back-Cover Texts on the back
+       cover. Both covers must also clearly and legibly identify you
+       as the publisher of these copies. The front cover must present
+       the full title with all words of the title equally prominent
+       and visible. You may add other material on the covers in
+       addition. Copying with changes limited to the covers, as long
+       as they preserve the title of the Document and satisfy these
+       conditions, can be treated as verbatim copying in other
+       respects.
+     </para>
+
+     <para>
+       If the required texts for either cover are too voluminous to
+       fit legibly, you should put the first ones listed (as many as
+       fit reasonably) on the actual cover, and continue the rest onto
+       adjacent pages.
+     </para>
+
+     <para>
+       If you publish or distribute Opaque copies of the Document
+       numbering more than 100, you must either include a
+       machine-readable Transparent copy along with each Opaque copy,
+       or state in or with each Opaque copy a publicly-accessible
+       computer-network location containing a complete Transparent
+       copy of the Document, free of added material, which the general
+       network-using public has access to download anonymously at no
+       charge using public-standard network protocols. If you use the
+       latter option, you must take reasonably prudent steps, when you
+       begin distribution of Opaque copies in quantity, to ensure that
+       this Transparent copy will remain thus accessible at the stated
+       location until at least one year after the last time you
+       distribute an Opaque copy (directly or through your agents or
+       retailers) of that edition to the public.
+     </para>
+
+     <para>
+       It is requested, but not required, that you contact the authors
+       of the Document well before redistributing any large number of
+       copies, to give them a chance to provide you with an updated
+       version of the Document.
+     </para>
+
+     </sect1>
+     <sect1><title>4. MODIFICATIONS</title>
+
+     <para>
+       You may copy and distribute a Modified Version of the Document
+       under the conditions of sections 2 and 3 above, provided that
+       you release the Modified Version under precisely this License,
+       with the Modified Version filling the role of the Document,
+       thus licensing distribution and modification of the Modified
+       Version to whoever possesses a copy of it. In addition, you
+       must do these things in the Modified Version:
+     </para>
+
+     <para>
+      <itemizedlist spacing=compact>
+       <listitem>
+        <para>
+        A. Use in the Title Page (and on the covers, if any) a title
+        distinct from that of the Document, and from those of previous
+        versions (which should, if there were any, be listed in the
+        History section of the Document). You may use the same title
+        as a previous version if the original publisher of that
+        version gives permission.
+	</para>
+       </listitem>
+       <listitem>
+        <para>
+	B. List on the Title Page, as authors, one or more persons
+	or entities responsible for authorship of the modifications in
+	the Modified Version, together with at least five of the
+	principal authors of the Document (all of its principal
+	authors, if it has less than five).
+	</para>
+       </listitem>
+       <listitem>
+        <para>
+	C. State on the Title page the name of the publisher of the
+	Modified Version, as the publisher.
+	</para>
+       </listitem>
+       <listitem>
+        <para>
+	D. Preserve all the copyright notices of the Document.
+	</para>
+       </listitem>
+       <listitem>
+        <para>
+	E. Add an appropriate copyright notice for your
+	modifications adjacent to the other copyright notices.
+	</para>
+       </listitem>
+       <listitem>
+        <para>
+	F. Include, immediately after the copyright notices, a
+	license notice giving the public permission to use the
+	Modified Version under the terms of this License, in the form
+	shown in the Addendum below.
+	</para>
+       </listitem>
+       <listitem>
+        <para>
+	G. Preserve in that license notice the full lists of
+	Invariant Sections and required Cover Texts given in the
+	Document's license notice.
+	</para>
+       </listitem>
+       <listitem>
+        <para>
+	H. Include an unaltered copy of this License.
+	</para>
+       </listitem>
+       <listitem>
+        <para>
+	I. Preserve the section entitled "History", and its title,
+	and add to it an item stating at least the title, year, new
+	authors, and publisher of the Modified Version as given on the
+	Title Page. If there is no section entitled "History" in the
+	Document, create one stating the title, year, authors, and
+	publisher of the Document as given on its Title Page, then add
+	an item describing the Modified Version as stated in the
+	previous sentence.
+	</para>
+       </listitem>
+       <listitem>
+        <para>
+        J. Preserve the network location, if any, given in the
+        Document for public access to a Transparent copy of the
+        Document, and likewise the network locations given in the
+        Document for previous versions it was based on. These may be
+        placed in the "History" section. You may omit a network
+        location for a work that was published at least four years
+        before the Document itself, or if the original publisher of
+        the version it refers to gives permission.
+	</para>
+       </listitem>
+       <listitem>
+        <para>
+        K. In any section entitled "Acknowledgements" or
+        "Dedications", preserve the section's title, and preserve in
+        the section all the substance and tone of each of the
+        contributor acknowledgements and/or dedications given therein.
+	</para>
+       </listitem>
+       <listitem>
+        <para>
+	L. Preserve all the Invariant Sections of the Document,
+	unaltered in their text and in their titles. Section numbers
+	or the equivalent are not considered part of the section
+	titles.
+	</para>
+       </listitem>
+       <listitem>
+        <para>
+	M. Delete any section entitled "Endorsements". Such a
+	section may not be included in the Modified Version.
+	</para>
+       </listitem>
+       <listitem>
+        <para>
+	N. Do not retitle any existing section as "Endorsements" or
+	to conflict in title with any Invariant Section.
+	</para>
+       </listitem>
+      </itemizedlist>
+     </para>
+
+     <para>
+       If the Modified Version includes new front-matter sections or
+       appendices that qualify as Secondary Sections and contain no
+       material copied from the Document, you may at your option
+       designate some or all of these sections as invariant. To do
+       this, add their titles to the list of Invariant Sections in the
+       Modified Version's license notice. These titles must be
+       distinct from any other section titles.
+     </para>
+
+     <para>
+       You may add a section entitled "Endorsements", provided it
+       contains nothing but endorsements of your Modified Version by
+       various parties--for example, statements of peer review or that
+       the text has been approved by an organization as the
+       authoritative definition of a standard.
+     </para>
+
+     <para>
+       You may add a passage of up to five words as a Front-Cover
+       Text, and a passage of up to 25 words as a Back-Cover Text, to
+       the end of the list of Cover Texts in the Modified
+       Version. Only one passage of Front-Cover Text and one of
+       Back-Cover Text may be added by (or through arrangements made
+       by) any one entity. If the Document already includes a cover
+       text for the same cover, previously added by you or by
+       arrangement made by the same entity you are acting on behalf
+       of, you may not add another; but you may replace the old one,
+       on explicit permission from the previous publisher that added
+       the old one.
+     </para>
+
+     <para>
+       The author(s) and publisher(s) of the Document do not by this
+       License give permission to use their names for publicity for or
+       to assert or imply endorsement of any Modified Version.
+     </para>
+
+     </sect1>
+     <sect1><title>5. COMBINING DOCUMENTS</title>
+
+     <para>
+       You may combine the Document with other documents released
+       under this License, under the terms defined in section 4 above
+       for modified versions, provided that you include in the
+       combination all of the Invariant Sections of all of the
+       original documents, unmodified, and list them all as Invariant
+       Sections of your combined work in its license notice.
+     </para>
+
+     <para>
+       The combined work need only contain one copy of this License,
+       and multiple identical Invariant Sections may be replaced with
+       a single copy. If there are multiple Invariant Sections with
+       the same name but different contents, make the title of each
+       such section unique by adding at the end of it, in parentheses,
+       the name of the original author or publisher of that section if
+       known, or else a unique number. Make the same adjustment to the
+       section titles in the list of Invariant Sections in the license
+       notice of the combined work.
+     </para>
+
+     <para>
+       In the combination, you must combine any sections entitled
+       "History" in the various original documents, forming one
+       section entitled "History"; likewise combine any sections
+       entitled "Acknowledgements", and any sections entitled
+       "Dedications". You must delete all sections entitled
+       "Endorsements."
+     </para>
+
+     </sect1>
+     <sect1><title>6. COLLECTIONS OF DOCUMENTS</title>
+
+     <para>
+       You may make a collection consisting of the Document and other
+       documents released under this License, and replace the
+       individual copies of this License in the various documents with
+       a single copy that is included in the collection, provided that
+       you follow the rules of this License for verbatim copying of
+       each of the documents in all other respects.
+     </para>
+
+     <para>
+       You may extract a single document from such a collection, and
+       distribute it individually under this License, provided you
+       insert a copy of this License into the extracted document, and
+       follow this License in all other respects regarding verbatim
+       copying of that document.
+     </para>
+
+     </sect1>
+     <sect1><title>7. AGGREGATION WITH INDEPENDENT WORKS</title>
+
+     <para>
+       A compilation of the Document or its derivatives with other
+       separate and independent documents or works, in or on a volume
+       of a storage or distribution medium, does not as a whole count
+       as a Modified Version of the Document, provided no compilation
+       copyright is claimed for the compilation. Such a compilation is
+       called an "aggregate", and this License does not apply to the
+       other self-contained works thus compiled with the Document, on
+       account of their being thus compiled, if they are not
+       themselves derivative works of the Document.
+     </para>
+
+     <para>
+       If the Cover Text requirement of section 3 is applicable to
+       these copies of the Document, then if the Document is less than
+       one quarter of the entire aggregate, the Document's Cover Texts
+       may be placed on covers that surround only the Document within
+       the aggregate. Otherwise they must appear on covers around the
+       whole aggregate.
+     </para>
+
+     </sect1>
+     <sect1><title>8. TRANSLATION</title>
+
+     <para>
+       Translation is considered a kind of modification, so you may
+       distribute translations of the Document under the terms of
+       section 4. Replacing Invariant Sections with translations
+       requires special permission from their copyright holders, but
+       you may include translations of some or all Invariant Sections
+       in addition to the original versions of these Invariant
+       Sections. You may include a translation of this License
+       provided that you also include the original English version of
+       this License. In case of a disagreement between the translation
+       and the original English version of this License, the original
+       English version will prevail.
+     </para>
+
+     </sect1>
+     <sect1><title>9. TERMINATION</title>
+
+     <para>
+       You may not copy, modify, sublicense, or distribute the
+       Document except as expressly provided for under this
+       License. Any other attempt to copy, modify, sublicense or
+       distribute the Document is void, and will automatically
+       terminate your rights under this License. However, parties who
+       have received copies, or rights, from you under this License
+       will not have their licenses terminated so long as such parties
+       remain in full compliance.
+     </para>
+
+     </sect1>
+     <sect1><title>10. FUTURE REVISIONS OF THIS LICENSE</title>
+
+     <para>
+       The Free Software Foundation may publish new, revised versions
+       of the GNU Free Documentation License from time to time. Such
+       new versions will be similar in spirit to the present version,
+       but may differ in detail to address new problems or
+       concerns. See http://www.gnu.org/copyleft/.
+     </para>
+
+     <para>
+       Each version of the License is given a distinguishing version
+       number. If the Document specifies that a particular numbered
+       version of this License "or any later version" applies to it,
+       you have the option of following the terms and conditions
+       either of that specified version or of any later version that
+       has been published (not as a draft) by the Free Software
+       Foundation. If the Document does not specify a version number
+       of this License, you may choose any version ever published (not
+       as a draft) by the Free Software Foundation.
+     </para>
+
+     </sect1>
+  </appendix>
+</book>
diff -ruN linux-2.4.20-wolk4.0-fullkernel/include/linux/icmpv6.h linux-2.4.20-wolk4.0-fullkernel.mipl/include/linux/icmpv6.h
--- linux-2.4.20-wolk4.0-fullkernel/include/linux/icmpv6.h	2003-05-13 12:20:39.000000000 +0200
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/include/linux/icmpv6.h	2003-05-18 11:33:53.000000000 +0200
@@ -40,14 +40,16 @@
                 struct icmpv6_nd_ra {
 			__u8		hop_limit;
 #if defined(__LITTLE_ENDIAN_BITFIELD)
-			__u8		reserved:6,
+			__u8		reserved:5,
+				        home_agent:1,
 					other:1,
 					managed:1;
 
 #elif defined(__BIG_ENDIAN_BITFIELD)
 			__u8		managed:1,
 					other:1,
-					reserved:6;
+				        home_agent:1,
+					reserved:5;
 #else
 #error	"Please fix <asm/byteorder.h>"
 #endif
@@ -70,6 +72,7 @@
 #define icmp6_addrconf_managed	icmp6_dataun.u_nd_ra.managed
 #define icmp6_addrconf_other	icmp6_dataun.u_nd_ra.other
 #define icmp6_rt_lifetime	icmp6_dataun.u_nd_ra.rt_lifetime
+#define icmp6_home_agent	icmp6_dataun.u_nd_ra.home_agent
 };
 
 
diff -ruN linux-2.4.20-wolk4.0-fullkernel/include/linux/if_arp.h linux-2.4.20-wolk4.0-fullkernel.mipl/include/linux/if_arp.h
--- linux-2.4.20-wolk4.0-fullkernel/include/linux/if_arp.h	2003-05-13 12:20:38.000000000 +0200
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/include/linux/if_arp.h	2003-05-18 11:33:53.000000000 +0200
@@ -84,6 +84,8 @@
 #define ARPHRD_IEEE80211 801		/* IEEE 802.11			*/
 #define ARPHRD_IEEE80211_PRISM 802	/* IEEE 802.11 + Prism2 header  */
 
+#define ARPHRD_IPV6_IPV6_TUNNEL 803	/* IPv6-IPv6 tunnel    		*/
+
 #define ARPHRD_VOID	  0xFFFF	/* Void type, nothing is known */
 
 /* ARP protocol opcodes. */
diff -ruN linux-2.4.20-wolk4.0-fullkernel/include/linux/in6.h linux-2.4.20-wolk4.0-fullkernel.mipl/include/linux/in6.h
--- linux-2.4.20-wolk4.0-fullkernel/include/linux/in6.h	2003-05-13 12:19:06.000000000 +0200
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/include/linux/in6.h	2003-05-18 11:33:53.000000000 +0200
@@ -131,6 +131,11 @@
 #define IPV6_TLV_JUMBO		194
 
 /*
+ *	Mobile IPv6 TLV options.
+ */
+#define MIPV6_TLV_HOMEADDR	201
+
+/*
  *	IPV6 socket options
  */
 
diff -ruN linux-2.4.20-wolk4.0-fullkernel/include/linux/ipv6.h linux-2.4.20-wolk4.0-fullkernel.mipl/include/linux/ipv6.h
--- linux-2.4.20-wolk4.0-fullkernel/include/linux/ipv6.h	2003-05-13 12:20:39.000000000 +0200
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/include/linux/ipv6.h	2003-05-18 11:33:53.000000000 +0200
@@ -29,6 +29,7 @@
 
 #define IPV6_SRCRT_STRICT	0x01	/* this hop must be a neighbor	*/
 #define IPV6_SRCRT_TYPE_0	0	/* IPv6 type 0 Routing Header	*/
+#define IPV6_SRCRT_TYPE_2	2	/*      type 2 for Mobile IPv6  */
 
 /*
  *	routing header
@@ -74,6 +75,18 @@
 };
 
 /*
+ *	routing header type 2
+ */
+
+struct rt2_hdr {
+	struct ipv6_rt_hdr	rt_hdr;
+	__u32			reserved;
+	struct in6_addr		addr;
+
+#define rt2_type		rt_hdr.type;
+};
+
+/*
  *	IPv6 fixed header
  *
  *	BEWARE, it is incorrect. The first 4 bits of flow_lbl
@@ -110,11 +123,14 @@
 struct inet6_skb_parm
 {
 	int			iif;
+	__u8			mipv6_flags;
 	__u16			ra;
 	__u16			hop;
 	__u16			auth;
 	__u16			dst0;
 	__u16			srcrt;
+	__u16			srcrt2;
+	__u16			hao;
 	__u16			dst1;
 };
 
diff -ruN linux-2.4.20-wolk4.0-fullkernel/include/linux/ipv6_tunnel.h linux-2.4.20-wolk4.0-fullkernel.mipl/include/linux/ipv6_tunnel.h
--- linux-2.4.20-wolk4.0-fullkernel/include/linux/ipv6_tunnel.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/include/linux/ipv6_tunnel.h	2003-05-18 11:33:53.000000000 +0200
@@ -0,0 +1,36 @@
+/*
+ * $Id: s.ipv6_tunnel.h 1.2 02/08/02 12:31:56-00:00 ville $
+ */
+
+#ifndef _IPV6_TUNNEL_H
+#define _IPV6_TUNNEL_H
+
+#define IPV6_TLV_TNL_ENCAP_LIMIT 4
+#define IPV6_DEFAULT_TNL_ENCAP_LIMIT 4
+
+/* don't add encapsulation limit, if one isn't present in inner packet */
+#define IPV6_TNL_F_IGN_ENCAP_LIMIT 0x1
+/* copy the traffic class field from the inner packet */
+#define IPV6_TNL_F_USE_ORIG_TCLASS 0x2
+/* also encapsulate packets originating from the tunnel entry-point node */
+#define IPV6_TNL_F_ALLOW_LOCAL 0x4
+/* created and maintaned from within the kernel */
+#define IPV6_TNL_F_KERNEL_DEV 0x8
+/* being used for Mobile IPv6 */
+#define IPV6_TNL_F_MIPV6_DEV 0x10
+/* only capable of receiving packets because local address isn't unicast */
+#define IPV6_TNL_F_RCV_ONLY 0x20
+
+struct ipv6_tnl_parm {
+	char name[IFNAMSIZ];	/* name of tunnel device */
+	int link;		/* ifindex of underlying link layer interface */
+	__u8 proto;		/* tunnel protocol */
+	__u8 encap_limit;	/* encapsulation limit for tunnel */
+	__u8 hop_limit;		/* hop limit for tunnel */
+	__u32 flow_lbl;		/* flow  label for tunnel */
+	__u32 flags;		/* tunnel flags */
+	struct in6_addr laddr;	/* local tunnel end-point address */
+	struct in6_addr raddr;	/* remote tunnel end-point address */
+};
+
+#endif
diff -ruN linux-2.4.20-wolk4.0-fullkernel/include/linux/rtnetlink.h linux-2.4.20-wolk4.0-fullkernel.mipl/include/linux/rtnetlink.h
--- linux-2.4.20-wolk4.0-fullkernel/include/linux/rtnetlink.h	2003-05-03 02:00:11.000000000 +0200
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/include/linux/rtnetlink.h	2003-05-18 11:33:53.000000000 +0200
@@ -313,15 +313,17 @@
 	IFA_LABEL,
 	IFA_BROADCAST,
 	IFA_ANYCAST,
-	IFA_CACHEINFO
+	IFA_CACHEINFO,
+	IFA_HOMEAGENT
 };
 
-#define IFA_MAX IFA_CACHEINFO
+#define IFA_MAX IFA_HOMEAGENT
 
 /* ifa_flags */
 
 #define IFA_F_SECONDARY		0x01
 
+#define IFA_F_HOMEADDR		0x10
 #define IFA_F_DEPRECATED	0x20
 #define IFA_F_TENTATIVE		0x40
 #define IFA_F_PERMANENT		0x80
diff -ruN linux-2.4.20-wolk4.0-fullkernel/include/linux/sysctl.h linux-2.4.20-wolk4.0-fullkernel.mipl/include/linux/sysctl.h
--- linux-2.4.20-wolk4.0-fullkernel/include/linux/sysctl.h	2003-05-13 12:18:48.000000000 +0200
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/include/linux/sysctl.h	2003-05-18 11:33:53.000000000 +0200
@@ -397,7 +397,20 @@
 enum {
 	NET_IPV6_CONF=16,
 	NET_IPV6_NEIGH=17,
-	NET_IPV6_ROUTE=18
+	NET_IPV6_ROUTE=18,
+	NET_IPV6_MOBILITY=19
+};
+
+/* /proc/sys/net/ipv6/mobility */
+enum {
+	NET_IPV6_MOBILITY_DEBUG=1,
+	NET_IPV6_MOBILITY_TUNNEL_SITELOCAL=2,
+	NET_IPV6_MOBILITY_ROUTER_SOLICITATION_MAX_SENDTIME=3,
+	NET_IPV6_MOBILITY_ROUTER_REACH=4,
+	NET_IPV6_MOBILITY_MDETECT_MECHANISM=5,
+	NET_IPV6_MOBILITY_AUTH=6,
+	NET_IPV6_MOBILITY_MAX_TNLS=7,
+	NET_IPV6_MOBILITY_MIN_TNLS=8
 };
 
 enum {
diff -ruN linux-2.4.20-wolk4.0-fullkernel/include/net/addrconf.h linux-2.4.20-wolk4.0-fullkernel.mipl/include/net/addrconf.h
--- linux-2.4.20-wolk4.0-fullkernel/include/net/addrconf.h	2003-05-13 12:24:46.000000000 +0200
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/include/net/addrconf.h	2003-05-18 11:33:53.000000000 +0200
@@ -16,9 +16,11 @@
 #if defined(__BIG_ENDIAN_BITFIELD)
 	__u8			onlink : 1,
 			 	autoconf : 1,
-				reserved : 6;
+				router_address : 1,
+				reserved : 5;
 #elif defined(__LITTLE_ENDIAN_BITFIELD)
-	__u8			reserved : 6,
+	__u8			reserved : 5,
+				router_address : 1,
 				autoconf : 1,
 				onlink : 1;
 #else
@@ -31,7 +33,6 @@
 	struct in6_addr		prefix;
 };
 
-
 #ifdef __KERNEL__
 
 #include <linux/in6.h>
@@ -40,6 +41,12 @@
 
 #define IN6_ADDR_HSIZE		16
 
+struct prefix_element {
+	struct list_head list;
+	struct prefix_info pinfo;
+	unsigned long timestamp;
+};
+
 extern void			addrconf_init(void);
 extern void			addrconf_cleanup(void);
 
@@ -88,6 +95,18 @@
 extern void			addrconf_prefix_rcv(struct net_device *dev,
 						    u8 *opt, int len);
 
+extern int			addrconf_pfx_adv_rcv(struct net_device *dev,
+						     struct prefix_info *pinfo,
+						     struct in6_addr *home_addr);
+
+extern int ipv6_get_prefix_entries(struct prefix_info **plist,
+				   int ifindex, int plen);
+
+extern int addrconf_pfx_adv_rcv(struct net_device *dev,
+				struct prefix_info *pinfo,
+				struct in6_addr *home_addr);
+
+
 /* Device notifier */
 extern int register_inet6addr_notifier(struct notifier_block *nb);
 extern int unregister_inet6addr_notifier(struct notifier_block *nb);
diff -ruN linux-2.4.20-wolk4.0-fullkernel/include/net/if_inet6.h linux-2.4.20-wolk4.0-fullkernel.mipl/include/net/if_inet6.h
--- linux-2.4.20-wolk4.0-fullkernel/include/net/if_inet6.h	2000-09-19 00:04:13.000000000 +0200
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/include/net/if_inet6.h	2003-05-18 11:33:53.000000000 +0200
@@ -96,6 +96,9 @@
 
 	struct inet6_ifaddr	*addr_list;
 	struct ifmcaddr6	*mc_list;
+	struct list_head	prefix_list;
+	int			prefix_count;
+	spinlock_t		prefix_lock;
 	rwlock_t		lock;
 	atomic_t		refcnt;
 	__u32			if_flags;
diff -ruN linux-2.4.20-wolk4.0-fullkernel/include/net/ip6_route.h linux-2.4.20-wolk4.0-fullkernel.mipl/include/net/ip6_route.h
--- linux-2.4.20-wolk4.0-fullkernel/include/net/ip6_route.h	2003-05-13 12:24:46.000000000 +0200
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/include/net/ip6_route.h	2003-05-18 11:33:53.000000000 +0200
@@ -2,6 +2,7 @@
 #define _NET_IP6_ROUTE_H
 
 #define IP6_RT_PRIO_FW		16
+#define IP6_RT_PRIO_MIPV6      	64
 #define IP6_RT_PRIO_USER	1024
 #define IP6_RT_PRIO_ADDRCONF	256
 #define IP6_RT_PRIO_KERN	512
@@ -64,6 +65,7 @@
 						    struct net_device *dev);
 extern struct rt6_info *	rt6_add_dflt_router(struct in6_addr *gwaddr,
 						    struct net_device *dev);
+extern struct rt6_info *	rt6_exist_dflt_router(void);
 
 extern void			rt6_purge_dflt_routers(int lst_resort);
 
@@ -95,7 +97,8 @@
  */
 
 static inline void ip6_dst_store(struct sock *sk, struct dst_entry *dst,
-				     struct in6_addr *daddr)
+				 struct in6_addr *daddr, 
+				 struct in6_addr *saddr)
 {
 	struct ipv6_pinfo *np = &sk->net_pinfo.af_inet6;
 	struct rt6_info *rt = (struct rt6_info *) dst;
@@ -103,6 +106,9 @@
 	write_lock(&sk->dst_lock);
 	__sk_dst_set(sk, dst);
 	np->daddr_cache = daddr;
+#ifdef CONFIG_IPV6_SUBTREES
+	np->saddr_cache = saddr;
+#endif
 	np->dst_cookie = rt->rt6i_node ? rt->rt6i_node->fn_sernum : 0;
 	write_unlock(&sk->dst_lock);
 }
diff -ruN linux-2.4.20-wolk4.0-fullkernel/include/net/ipv6.h linux-2.4.20-wolk4.0-fullkernel.mipl/include/net/ipv6.h
--- linux-2.4.20-wolk4.0-fullkernel/include/net/ipv6.h	2003-05-13 12:23:08.000000000 +0200
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/include/net/ipv6.h	2003-05-18 11:33:53.000000000 +0200
@@ -37,6 +37,7 @@
 #define NEXTHDR_ICMP		58	/* ICMP for IPv6. */
 #define NEXTHDR_NONE		59	/* No next header */
 #define NEXTHDR_DEST		60	/* Destination options header. */
+#define NEXTHDR_MH		0xd2	/* Mobility header */
 
 #define NEXTHDR_MAX		255
 
@@ -128,9 +129,12 @@
 	__u16			opt_flen;	/* after fragment hdr */
 	__u16			opt_nflen;	/* before fragment hdr */
 
+	__u8			mipv6_flags;	/* flags set by MIPv6 */
+
 	struct ipv6_opt_hdr	*hopopt;
 	struct ipv6_opt_hdr	*dst0opt;
-	struct ipv6_rt_hdr	*srcrt;	/* Routing Header */
+	struct ipv6_rt_hdr	*srcrt;	/* Routing Header Type 0 */
+	struct ipv6_rt_hdr	*srcrt2; /* Routing Header Type 2 */
 	struct ipv6_opt_hdr	*auth;
 	struct ipv6_opt_hdr	*dst1opt;
 
@@ -239,6 +243,26 @@
 		 a->s6_addr32[2] | a->s6_addr32[3] ) == 0); 
 }
 
+static void inline ipv6_addr_prefix(struct in6_addr *prefix,
+				    const struct in6_addr *addr, int plen)
+{
+	int ncopy, nbits;
+
+	if (plen <= 0)
+		return;
+	if (plen > 128)
+		plen = 128;
+
+	ncopy = plen >> 3;
+	nbits = plen & 7;
+
+	memcpy(prefix, addr, ncopy);
+	if (ncopy < 16)
+		memset(&prefix->s6_addr[ncopy], 0, 16 - ncopy);
+	if (nbits)
+		prefix->s6_addr[ncopy] = addr->s6_addr[ncopy] & (0xff00 >> nbits);
+}
+
 /*
  *	Prototypes exported by ipv6
  */
diff -ruN linux-2.4.20-wolk4.0-fullkernel/include/net/ipv6_tunnel.h linux-2.4.20-wolk4.0-fullkernel.mipl/include/net/ipv6_tunnel.h
--- linux-2.4.20-wolk4.0-fullkernel/include/net/ipv6_tunnel.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/include/net/ipv6_tunnel.h	2003-05-18 11:33:53.000000000 +0200
@@ -0,0 +1,78 @@
+/*
+ * $Id: s.ipv6_tunnel.h 1.7 02/08/09 14:09:15-00:00 ville $
+ */
+
+#ifndef _NET_IPV6_TUNNEL_H
+#define _NET_IPV6_TUNNEL_H
+
+#include <linux/ipv6.h>
+#include <linux/netdevice.h>
+#include <linux/ipv6_tunnel.h>
+#include <linux/skbuff.h>
+#include <asm/atomic.h>
+
+#define IPV6_TNL_MAX 128
+
+/* IPv6 tunnel */
+
+struct ipv6_tnl {
+	struct ipv6_tnl *next;	/* next tunnel in list */
+	struct net_device *dev;	/* virtual device associated with tunnel */
+	struct net_device_stats stat;	/* statistics for tunnel device */
+	int recursion;		/* depth of hard_start_xmit recursion */
+	struct ipv6_tnl_parm parms;	/* tunnel configuration paramters */
+	struct flowi fl;	/* flowi template for xmit */
+	atomic_t refcnt;	/* nr of identical tunnels used by kernel */
+};
+
+#define IPV6_TNL_PRE_ENCAP 0
+#define IPV6_TNL_PRE_DECAP 1
+#define IPV6_TNL_MAXHOOKS 2
+
+#define IPV6_TNL_DROP 0
+#define IPV6_TNL_ACCEPT 1
+#define IPV6_TNL_STOLEN 2
+
+typedef int ipv6_tnl_hookfn(struct ipv6_tnl *t, struct sk_buff *skb);
+
+struct ipv6_tnl_hook_ops {
+	struct list_head list;
+	unsigned int hooknum;
+	int priority;
+	ipv6_tnl_hookfn *hook;
+};
+
+enum ipv6_tnl_hook_priorities {
+	IPV6_TNL_PRI_FIRST = INT_MIN,
+	IPV6_TNL_PRI_LAST = INT_MAX
+};
+
+/* Tunnel encapsulation limit destination sub-option */
+
+struct ipv6_tlv_tnl_enc_lim {
+	__u8 type;		/* type-code for option         */
+	__u8 length;		/* option length                */
+	__u8 encap_limit;	/* tunnel encapsulation limit   */
+} __attribute__ ((packed));
+
+#ifdef __KERNEL__
+extern struct ipv6_tnl *ipv6_ipv6_tnl_lookup(struct in6_addr *remote,
+					     struct in6_addr *local);
+
+extern int ipv6_ipv6_kernel_tnl_add(struct ipv6_tnl_parm *p);
+
+extern int ipv6_ipv6_kernel_tnl_del(struct ipv6_tnl *t);
+
+extern unsigned int ipv6_ipv6_tnl_inc_max_kdev_count(unsigned int n);
+
+extern unsigned int ipv6_ipv6_tnl_dec_max_kdev_count(unsigned int n);
+
+extern unsigned int ipv6_ipv6_tnl_inc_min_kdev_count(unsigned int n);
+
+extern unsigned int ipv6_ipv6_tnl_dec_min_kdev_count(unsigned int n);
+
+extern void ipv6_ipv6_tnl_register_hook(struct ipv6_tnl_hook_ops *reg);
+
+extern void ipv6_ipv6_tnl_unregister_hook(struct ipv6_tnl_hook_ops *reg);
+#endif
+#endif
diff -ruN linux-2.4.20-wolk4.0-fullkernel/include/net/mipglue.h linux-2.4.20-wolk4.0-fullkernel.mipl/include/net/mipglue.h
--- linux-2.4.20-wolk4.0-fullkernel/include/net/mipglue.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/include/net/mipglue.h	2003-05-18 11:33:53.000000000 +0200
@@ -0,0 +1,300 @@
+/*
+ *	Glue for Mobility support integration to IPv6
+ *
+ *	Authors:
+ *	Antti Tuominen		<ajtuomin@cc.hut.fi>	
+ *
+ *	$Id: s.mipglue.h 1.33 02/12/18 19:18:51+02:00 antti@jon.mipl.mediapoli.com $
+ *
+ *	This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef _NET_MIPGLUE_H
+#define _NET_MIPGLUE_H
+
+#ifndef USE_IPV6_MOBILITY
+#if defined(CONFIG_IPV6_MOBILITY) || defined(CONFIG_IPV6_MOBILITY_MODULE)
+#define USE_IPV6_MOBILITY
+#endif
+#endif
+
+/* symbols to indicate whether destination options received should take
+ * effect or not (see exthdrs.c, procrcv.c)
+ */
+#define MIPV6_DSTOPTS_ACCEPT 1
+#define MIPV6_DSTOPTS_DISCARD 0
+
+#define MIPV6_IGN_RTR 0
+#define MIPV6_ADD_RTR 1
+#define MIPV6_CHG_RTR 2
+
+/* MIPV6: Approximate maximum for mobile IPv6 options and headers */
+#define MIPV6_HEADERS 48
+
+#ifdef __KERNEL__
+#include <linux/sched.h>
+#include <linux/in6.h>
+#include <linux/socket.h>
+#include <linux/route.h>
+#include <linux/skbuff.h>
+
+#include <net/mipv6.h>
+#include <net/ipv6.h>
+#include <net/addrconf.h>
+
+#ifdef USE_IPV6_MOBILITY
+
+/* calls a procedure from mipv6-module */
+#define MIPV6_CALLPROC(X) if(mipv6_functions.X) mipv6_functions.X
+
+/* calls a function from mipv6-module, default-value if function not defined
+ */
+#define MIPV6_CALLFUNC(X,Y) (!mipv6_functions.X)?(Y):mipv6_functions.X
+
+/* sets a handler-function to process a call */
+#define MIPV6_SETCALL(X,Y) if(mipv6_functions.X) printk("mipv6: Warning, function assigned twice!\n"); \
+                           mipv6_functions.X = Y
+
+/* pointers to mipv6 callable functions */
+struct mipv6_callable_functions {
+	void (*mipv6_initialize_dstopt_rcv) (struct sk_buff *skb);
+	int (*mipv6_finalize_dstopt_rcv) (int process);
+	int (*mipv6_handle_homeaddr) (struct sk_buff *skb, int optoff);
+	int (*mipv6_ra_rcv) (struct sk_buff *skb);
+	void (*mipv6_icmp_rcv) (struct sk_buff *skb);
+	void (*mipv6_pfxs_modified) (struct prefix_info *pinfo, int ifindex);
+	struct ipv6_txoptions * (*mipv6_modify_txoptions) (
+		struct sock *sk,
+		struct sk_buff *skb, 
+		struct ipv6_txoptions *opt,
+		struct flowi *fl,
+		struct dst_entry **dst);
+	void (*mipv6_set_home) (int ifindex, struct in6_addr *homeaddr, int plen,
+				struct in6_addr *homeagent, int plen2);
+	void (*mipv6_get_home_address) (struct inet6_ifaddr *ifp,
+					struct in6_addr *home_addr);
+	void (*mipv6_get_care_of_address)(struct in6_addr *homeaddr, 
+					  struct in6_addr *coa);
+	void (*mipv6_change_router)(void);
+	void (*mipv6_check_dad)(struct in6_addr *home_addr);      
+	void (*mipv6_icmp_handle_homeaddr)(struct sk_buff *skb);
+        void (*mipv6_prefix_route)(struct in6_addr *pfx, int plen, 
+				   int delete, unsigned long expires);
+	int (*mipv6_mn_may_solicit_ha)(struct in6_addr *target);
+	int (*mipv6_mn_may_advertise)(struct in6_addr *target, 
+				      struct in6_addr *saddr);
+};
+
+extern struct mipv6_callable_functions mipv6_functions;
+
+extern void mipv6_invalidate_calls(void);
+
+extern int mipv6_handle_dstopt(struct sk_buff *skb, int optoff);
+
+static inline int 
+ndisc_mipv6_mn_may_solicit_ha(struct in6_addr *target)
+{
+	return MIPV6_CALLFUNC(mipv6_mn_may_solicit_ha, 0)(target);
+}
+
+extern int 
+ndisc_mipv6_mn_solicit_ha(struct net_device *dev, struct in6_addr *target);
+
+static inline int 
+ndisc_mipv6_mn_may_advertise(struct in6_addr *target, struct in6_addr *saddr)
+{
+	return MIPV6_CALLFUNC(mipv6_mn_may_advertise, 1)(target, saddr);
+}
+
+/* 
+ * Avoid adding new default routers if the old one is still in use 
+ */
+
+static inline  int ndisc_mipv6_ra_rcv(struct sk_buff *skb)
+{
+	return MIPV6_CALLFUNC(mipv6_ra_rcv, MIPV6_ADD_RTR)(skb);
+}
+
+static inline void ndisc_mipv6_change_router(int change_rtr)
+{
+	if (change_rtr == MIPV6_CHG_RTR)
+		MIPV6_CALLPROC(mipv6_change_router)();
+}
+
+static inline void ndisc_check_mipv6_dad(struct in6_addr *target)
+{
+	MIPV6_CALLPROC(mipv6_check_dad)(target);
+}
+
+static inline void icmpv6_handle_mipv6_homeaddr(struct sk_buff *skb)
+{
+	MIPV6_CALLPROC(mipv6_icmp_handle_homeaddr)(skb);
+}
+
+static inline void mipv6_icmp_rcv(struct sk_buff *skb)
+{
+	MIPV6_CALLPROC(mipv6_icmp_rcv)(skb);
+}
+
+static inline int tcp_v6_get_mipv6_header_len(void)
+{
+	return MIPV6_HEADERS;
+}
+
+static inline struct in6_addr *
+mipv6_get_fake_hdr_daddr(struct in6_addr *hdaddr, struct in6_addr *daddr)
+{
+	return daddr;
+}
+
+static inline void 
+addrconf_set_mipv6_mn_home(int ifindex, struct in6_addr *homeaddr, int plen,
+			   struct in6_addr *homeagent, int plen2)
+{
+	MIPV6_CALLPROC(mipv6_set_home)(ifindex, homeaddr, plen, homeagent, plen2);
+}
+
+static inline void addrconf_get_mipv6_home_address(struct inet6_ifaddr *ifp, 
+						   struct in6_addr *saddr)
+{
+	MIPV6_CALLPROC(mipv6_get_home_address)(ifp, saddr);
+}
+
+static inline int 
+addrconf_pfxs_modified(struct prefix_element *p, struct prefix_info *pinfo)
+{
+	return (p->pinfo.valid != pinfo->valid || 
+		p->pinfo.prefered != pinfo->prefered);
+}
+
+static inline void 
+addrconf_mipv6_pfxs_modified(struct prefix_info *pinfo, int ifindex)
+{
+	MIPV6_CALLPROC(mipv6_pfxs_modified)(pinfo, ifindex);
+}
+
+static inline struct ipv6_txoptions *
+ip6_add_mipv6_txoptions(struct sock *sk, struct sk_buff *skb, 
+			struct ipv6_txoptions *opt, struct flowi *fl,
+			struct dst_entry **dst)
+{
+	return MIPV6_CALLFUNC(mipv6_modify_txoptions, opt)(sk, skb, opt, fl, dst); 
+
+}
+
+static inline void
+ip6_mark_mipv6_packet(struct ipv6_txoptions *txopt, struct sk_buff *skb)
+{
+	struct inet6_skb_parm *opt;
+	if (txopt) {
+		opt = (struct inet6_skb_parm *)skb->cb;
+		opt->mipv6_flags = txopt->mipv6_flags;
+	}
+}
+
+static inline void 
+ip6_free_mipv6_txoptions(struct ipv6_txoptions *opt,
+			 struct ipv6_txoptions *orig_opt) 
+{
+	if (opt && opt != orig_opt)
+		kfree(opt);
+}
+
+static inline void 
+addrconf_mipv6_prefix_route(struct in6_addr *pfx, int plen, int delete, 
+			    unsigned long expires)
+{ 
+	MIPV6_CALLPROC(mipv6_prefix_route)(pfx, plen, delete, expires);
+}
+
+#else /* USE_IPV6_MOBILITY */
+
+static inline struct ipv6_txoptions *
+ip6_add_mipv6_txoptions(struct sock *sk, struct sk_buff *skb,
+			struct ipv6_txoptions *opt, struct flowi *fl,
+			struct dst_entry **dst)
+{
+	return opt;
+}
+
+static inline void 
+ip6_free_mipv6_txoptions(struct sock *sk, struct ipv6_txoptions *opt) {}
+
+static inline void
+ip6_mark_mipv6_packet(struct ipv6_txoptions *txopt, struct sk_buff *skb) {}
+
+static inline int ndisc_mipv6_mn_may_solicit_ha(struct in6_addr *target) 
+{
+	return 0;
+}
+
+static inline int
+ndisc_mipv6_mn_solicit_ha(struct net_device *dev, struct in6_addr *target)
+{
+	return 0;
+}
+
+static inline int 
+ndisc_mipv6_mn_may_advertise(struct in6_addr *target, struct in6_addr *saddr)
+{
+	return 1;
+}
+
+static inline int ndisc_mipv6_ra_rcv(struct sk_buff *skb)
+{
+	return MIPV6_ADD_RTR;
+}
+
+static inline void ndisc_mipv6_change_router(int change_rtr) {}
+
+static inline void ndisc_check_mipv6_dad(struct in6_addr *target) {}
+
+static inline void icmpv6_handle_mipv6_homeaddr(struct sk_buff *skb) {}
+
+static inline void mipv6_icmp_rcv(struct sk_buff *skb) {}
+
+static inline int icmpv6_handle_mipv6_type(int type)
+{
+	return 0;
+}
+
+static inline int tcp_v6_get_mipv6_header_len(void)
+{
+	return 0;
+}
+
+static inline struct in6_addr *
+mipv6_get_fake_hdr_daddr(struct in6_addr *hdaddr, struct in6_addr *daddr)
+{
+	return hdaddr;
+}
+
+static inline void 
+addrconf_set_mipv6_mn_home(int ifindex, struct in6_addr *homeaddr, int plen,
+			   struct in6_addr *homeagent, int plen2) {}
+
+static inline void addrconf_get_mipv6_home_address(struct inet6_ifaddr *ifp, 
+						   struct in6_addr *saddr) {}
+
+static inline int 
+addrconf_pfxs_modified(struct prefix_element *p, struct prefix_info *pinfo)
+{
+	return 0;
+}
+
+static inline void 
+addrconf_mipv6_pfxs_modified(struct prefix_info *pinfo, int ifindex) {}
+
+static inline void 
+addrconf_mipv6_prefix_route(struct in6_addr *pfx, int plen, int delete, 
+			    unsigned long expires) {}
+
+#define mipv6_handle_dstopt ip6_tlvopt_unknown
+
+#endif /* USE_IPV6_MOBILITY */
+#endif /* __KERNEL__ */
+#endif /* _NET_MIPGLUE_H */
diff -ruN linux-2.4.20-wolk4.0-fullkernel/include/net/mipv6.h linux-2.4.20-wolk4.0-fullkernel.mipl/include/net/mipv6.h
--- linux-2.4.20-wolk4.0-fullkernel/include/net/mipv6.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/include/net/mipv6.h	2003-05-18 11:33:53.000000000 +0200
@@ -0,0 +1,242 @@
+/*
+ *	Mobile IPv6 header-file
+ *
+ *	Authors:
+ *	Sami Kivisaari		<skivisaa@cc.hut.fi>
+ *
+ *	$Id: s.mipv6.h 1.47 02/12/13 11:46:28-02:00 henkku@mart10.hut.mediapoli.com $
+ *
+ *	This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef _NET_MIPV6_H
+#define _NET_MIPV6_H
+
+#include <linux/types.h>
+#include <asm/byteorder.h>
+#include <linux/in6.h>
+
+/*
+ *
+ * Mobile IPv6 Protocol constants
+ *
+ */
+#define HomeRtrAdvInterval		1000	/* seconds		*/
+#define DHAAD_RETRIES			3	/* transmissions	*/
+#define INITIAL_BINDACK_TIMEOUT		1	/* seconds 		*/
+#define INITIAL_DHAAD_TIMEOUT		2	/* seconds		*/
+#define INITIAL_SOLICIT_TIMER		2	/* seconds		*/
+#define MAX_ADVERT_REXMIT		3 	/* transmissions	*/
+#define MAX_BINDACK_TIMEOUT		256 	/* seconds		*/
+#define MAX_COOKIE_LIFE			240	/* seconds		*/
+#define MAX_FAST_UPDATES		5 	/* transmissions	*/
+#define MAX_PFX_ADV_DELAY		1000	/* seconds		*/
+#define MAX_RR_BINDING_LIFE		420	/* seconds		*/
+#define MAX_UPDATE_RATE			1	/* 1/s (min delay=1s) 	*/
+#define PREFIX_ADV_RETRIES		3	/* transmissions	*/
+#define PREFIX_ADV_TIMEOUT		5	/* seconds		*/
+#define SLOW_UPDATE_RATE		10	/* 1/10s (max delay=10s)*/
+#define INITIAL_BINDACK_DAD_TIMEOUT	3	/* seconds		*/
+
+/* This is not actually specified in the draft, but is needed to avoid
+ * prefix solicitation storm when valid lifetime of a prefix is smaller
+ * than MAX_PFX_ADV_DELAY
+ */
+#define MIN_PFX_SOL_DELAY		5	/* seconds		*/
+
+/* Mobile IPv6 ICMP types		  */
+/*
+ * TODO: Check with IANA
+ */
+#define MIPV6_DHAAD_REQUEST		150
+#define MIPV6_DHAAD_REPLY		151
+#define MIPV6_PREFIX_SOLICIT		152
+#define MIPV6_PREFIX_ADV		153
+
+/* Binding update flag codes              */
+#define MIPV6_BU_F_ACK			0x80
+#define MIPV6_BU_F_HOME			0x40
+#define MIPV6_BU_F_SINGLE		0x20
+#define MIPV6_BU_F_DAD			0x10
+#define MIPV6_BU_F_LLADDR		0x08
+
+/* Binding error status */
+#define MIPV6_BE_HAO_WO_BINDING		1
+#define MIPV6_BE_UNKNOWN_MH_TYPE	2
+
+/* Mobility Header */
+struct mipv6_mh
+{
+	__u8	payload;		/* Payload Protocol 		*/
+	__u8	length;			/* MH Length 			*/
+	__u8	type;			/* MH Type			*/
+	__u8	reserved;		/* Reserved			*/
+	__u16	checksum;		/* Checksum			*/
+	__u8	data[0];		/* Message specific data	*/
+} __attribute__ ((packed));
+
+/* Mobility Header type */
+#define IPPROTO_MOBILITY                62 /* TODO: No official protocol number at this point */                
+/* Mobility Header Message Types */
+
+#define MIPV6_MH_BRR			0
+#define MIPV6_MH_HOTI			1
+#define MIPV6_MH_COTI			2
+#define MIPV6_MH_HOT			3
+#define MIPV6_MH_COT			4
+#define MIPV6_MH_BU			5
+#define MIPV6_MH_BA			6
+#define MIPV6_MH_BE			7
+
+/*
+ * Status codes for Binding Acknowledgements
+ */
+#define SUCCESS				0
+#define REASON_UNSPECIFIED		128
+#define ADMINISTRATIVELY_PROHIBITED	129
+#define INSUFFICIENT_RESOURCES		130
+#define HOME_REGISTRATION_NOT_SUPPORTED	131
+#define NOT_HOME_SUBNET			132
+#define NOT_HA_FOR_MN			133
+#define DUPLICATE_ADDR_DETECT_FAIL	134
+#define SEQUENCE_NUMBER_OUT_OF_WINDOW	135
+#define EXPIRED_HOME_NONCE_INDEX	136
+#define EXPIRED_CAREOF_NONCE_INDEX	137
+#define EXPIRED_NONCES			138
+
+/*
+ * Values for mipv6_flags in struct inet6_skb_parm
+ */
+
+#define MIPV6_RCV_TUNNEL		0x1
+#define MIPV6_SND_HAO			0x2
+
+
+/*
+ * Mobility Header Message structures
+ */
+
+struct mipv6_mh_brr
+{
+	__u16		reserved;
+	/* Mobility options */
+} __attribute__ ((packed));
+
+struct mipv6_mh_bu
+{
+	__u16		sequence;	/* sequence number of BU	*/
+	__u8		flags;		/* flags			*/
+	__u8		reserved;	/* reserved bits		*/
+	__u16		lifetime;	/* lifetime of BU		*/
+	/* Mobility options */
+} __attribute__ ((packed));
+
+struct mipv6_mh_ba
+{
+	__u8		status;		/* statuscode			*/
+	__u8		reserved;	/* reserved bits		*/
+	__u16		sequence;	/* sequence number of BA	*/
+	__u16		lifetime;	/* lifetime in CN's bcache	*/
+	/* Mobility options */
+} __attribute__ ((packed));
+
+struct mipv6_mh_be
+{
+	__u8		status;
+	__u8		reserved;
+	struct in6_addr	home_addr;
+	/* Mobility options */
+} __attribute__ ((packed));
+
+struct mipv6_mh_addr_ti
+{
+	__u16		reserved;	/* Reserved			*/
+	u_int8_t	test_cookie[8]; /* HoT/CoT Cookie		*/
+	/* Mobility options */
+} __attribute__ ((packed));
+
+struct mipv6_mh_addr_test
+{
+	__u16		nonce_index;    /* Home/Care-of Nonce Index	*/
+	u_int8_t	test_cookie[8]; /* HoT/CoT Cookie		*/
+	u_int8_t	addr_cookie[8];	/* Home/Care-of Cookie		*/
+	/* Mobility options */
+} __attribute__ ((packed));
+
+/*
+ * Mobility Options for various MH types.
+ */
+#define MIPV6_OPT_PAD1			0x00
+#define MIPV6_OPT_PADN			0x01
+#define MIPV6_OPT_ALTERNATE_COA		0x03
+#define MIPV6_OPT_NONCE_INDICES		0x04
+#define MIPV6_OPT_AUTH_DATA		0x05
+#define MIPV6_OPT_BIND_REFRESH_ADVICE	0x06
+
+/*
+ * Mobility Option structures
+ */
+
+struct mipv6_mo
+{
+	__u8		type;
+	__u8		length;
+	__u8		value[0];	/* type specific data */
+} __attribute__ ((packed));
+
+struct mipv6_mo_pad1
+{
+	__u8		type;
+} __attribute__ ((packed));
+
+struct mipv6_mo_padn
+{
+	__u8		type;
+	__u8		length;
+	__u8		data[0];
+} __attribute__ ((packed));
+
+struct mipv6_mo_alt_coa
+{
+	__u8		type;
+	__u8		length;
+	struct in6_addr	addr;		/* alternate care-of-address	*/
+} __attribute__ ((packed));
+
+struct mipv6_mo_nonce_indices
+{
+	__u8		type;
+	__u8		length;
+	__u16		home_nonce_i;	/* Home Nonce Index		*/
+	__u16		careof_nonce_i;	/* Careof Nonce Index		*/
+} __attribute__ ((packed)); 
+
+struct mipv6_mo_bauth_data
+{
+	__u8		type;
+	__u8		length;
+	__u8		data[0];
+} __attribute__ ((packed)); 
+
+struct mipv6_mo_br_advice
+{
+	__u8		type;
+	__u8		length;
+	__u16		refresh_interval; /* Refresh Interval		*/
+} __attribute__ ((packed));
+
+/*
+ * Home Address Destination Option structure
+ */
+struct mipv6_dstopt_homeaddr
+{
+	__u8		type;		/* type-code for option 	*/
+	__u8		length;		/* option length 		*/
+	struct in6_addr	addr;		/* home address 		*/
+} __attribute__ ((packed));
+
+#endif /* _NET_MIPV6_H */
diff -ruN linux-2.4.20-wolk4.0-fullkernel/include/net/ndisc.h linux-2.4.20-wolk4.0-fullkernel.mipl/include/net/ndisc.h
--- linux-2.4.20-wolk4.0-fullkernel/include/net/ndisc.h	2003-05-13 12:23:08.000000000 +0200
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/include/net/ndisc.h	2003-05-18 11:33:53.000000000 +0200
@@ -21,6 +21,10 @@
 #define ND_OPT_REDIRECT_HDR		4
 #define ND_OPT_MTU			5
 
+/* Mobile IPv6 specific ndisc options */ 
+#define ND_OPT_RTR_ADV_INTERVAL		7 
+#define ND_OPT_HOME_AGENT_INFO		8  
+
 #define MAX_RTR_SOLICITATION_DELAY	HZ
 
 #define ND_REACHABLE_TIME		(30*HZ)
diff -ruN linux-2.4.20-wolk4.0-fullkernel/include/net/neighbour.h linux-2.4.20-wolk4.0-fullkernel.mipl/include/net/neighbour.h
--- linux-2.4.20-wolk4.0-fullkernel/include/net/neighbour.h	2003-05-13 12:20:38.000000000 +0200
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/include/net/neighbour.h	2003-05-18 11:35:24.000000000 +0200
@@ -48,6 +48,12 @@
 #include <asm/atomic.h>
 #include <linux/skbuff.h>
 
+#ifndef USE_IPV6_MOBILITY
+#if defined(CONFIG_IPV6_MOBILITY) || defined(CONFIG_IPV6_MOBILITY_MODULE)
+#define USE_IPV6_MOBILITY
+#endif
+#endif
+
 #define NUD_IN_TIMER	(NUD_INCOMPLETE|NUD_DELAY|NUD_PROBE|NUD_VERIFY)
 #define NUD_VALID	(NUD_PERMANENT|NUD_NOARP|NUD_REACHABLE|NUD_PROBE|NUD_STALE|NUD_DELAY)
 #define NUD_CONNECTED	(NUD_PERMANENT|NUD_NOARP|NUD_REACHABLE)
@@ -128,8 +134,11 @@
 struct pneigh_entry
 {
 	struct pneigh_entry	*next;
-	struct net_device		*dev;
+	struct net_device      	*dev;
 	u8			key[0];
+#ifdef USE_IPV6_MOBILITY
+	atomic_t       		refcnt;
+#endif
 };
 
 #define NEIGH_HASHMASK		0x1F
@@ -279,6 +288,50 @@
 	return neigh_create(tbl, pkey, dev);
 }
 
+#ifdef USE_IPV6_MOBILITY
+
+static inline struct pneigh_entry *pneigh_clone(struct pneigh_entry *pneigh)
+{
+	if (pneigh)
+		atomic_inc(&pneigh->refcnt);
+	return pneigh;
+}
+
+static inline void pneigh_refcnt_init(struct pneigh_entry *pneigh)
+{
+	atomic_set(&pneigh->refcnt, 1);
+}
+
+static inline int pneigh_refcnt_dec_and_test(struct pneigh_entry *pneigh)
+{
+	return atomic_dec_and_test(&pneigh->refcnt);
+}
+
+static inline int pneigh_alloc_flag(void)
+{
+	return in_interrupt() ? GFP_ATOMIC : GFP_KERNEL;
+}
+
+#else 
+
+static inline struct pneigh_entry *pneigh_clone(struct pneigh_entry *pneigh)
+{
+	return pneigh;
+}
+
+static inline void pneigh_refcnt_init(struct pneigh_entry *pneigh) {}
+
+static inline int pneigh_refcnt_dec_and_test(struct pneigh_entry *pneigh)
+{
+	return 1;
+}
+
+static inline int pneigh_alloc_flag(void)
+{
+	return GFP_KERNEL;
+}
+
+#endif /* USE_IPV6_MOBILITY */
 #endif
 #endif
 
diff -ruN linux-2.4.20-wolk4.0-fullkernel/include/net/sock.h linux-2.4.20-wolk4.0-fullkernel.mipl/include/net/sock.h
--- linux-2.4.20-wolk4.0-fullkernel/include/net/sock.h	2003-05-13 12:20:39.000000000 +0200
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/include/net/sock.h	2003-05-18 11:33:53.000000000 +0200
@@ -146,7 +146,9 @@
 	struct in6_addr 	rcv_saddr;
 	struct in6_addr		daddr;
 	struct in6_addr		*daddr_cache;
-
+#if defined(CONFIG_IPV6_SUBTREES)
+	struct in6_addr		*saddr_cache;
+#endif
 	__u32			flow_label;
 	__u32			frag_size;
 	int			hop_limit;
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/Makefile linux-2.4.20-wolk4.0-fullkernel.mipl/net/Makefile
--- linux-2.4.20-wolk4.0-fullkernel/net/Makefile	2003-05-03 02:35:11.000000000 +0200
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/Makefile	2003-05-18 11:33:53.000000000 +0200
@@ -26,6 +26,7 @@
 ifneq ($(CONFIG_IPV6),n)
 ifneq ($(CONFIG_IPV6),)
 subdir-$(CONFIG_NETFILTER)	+= ipv6/netfilter
+subdir-$(CONFIG_IPV6_MOBILITY)	+= ipv6/mobile_ip6
 endif
 endif
 
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/core/neighbour.c linux-2.4.20-wolk4.0-fullkernel.mipl/net/core/neighbour.c
--- linux-2.4.20-wolk4.0-fullkernel/net/core/neighbour.c	2003-05-03 02:11:59.000000000 +0200
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/core/neighbour.c	2003-05-18 11:33:53.000000000 +0200
@@ -358,10 +358,13 @@
 	if (!creat)
 		return NULL;
 
-	n = kmalloc(sizeof(*n) + key_len, GFP_KERNEL);
+	n = kmalloc(sizeof(*n) + key_len, pneigh_alloc_flag());
+
 	if (n == NULL)
 		return NULL;
 
+	pneigh_refcnt_init(n);
+
 	memcpy(n->key, pkey, key_len);
 	n->dev = dev;
 
@@ -392,6 +395,10 @@
 
 	for (np = &tbl->phash_buckets[hash_val]; (n=*np) != NULL; np = &n->next) {
 		if (memcmp(n->key, pkey, key_len) == 0 && n->dev == dev) {
+
+			if (!pneigh_refcnt_dec_and_test(n)) {
+				return 0;
+			}
 			write_lock_bh(&tbl->lock);
 			*np = n->next;
 			write_unlock_bh(&tbl->lock);
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/Config.in linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/Config.in
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/Config.in	2001-12-21 18:42:05.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/Config.in	2003-05-18 11:33:53.000000000 +0200
@@ -1,10 +1,13 @@
 #
 # IPv6 configuration
 # 
-
+bool '    IPv6: source address subtree support (EXPERIMENTAL)' CONFIG_IPV6_SUBTREES
 #bool '    IPv6: flow policy support' CONFIG_RT6_POLICY
 #bool '    IPv6: firewall support' CONFIG_IPV6_FIREWALL
 
+dep_tristate '    IPv6: IPv6 over IPv6 Tunneling (EXPERIMENTAL)' CONFIG_IPV6_IPV6_TUNNEL m
+source net/ipv6/mobile_ip6/Config.in
+
 if [ "$CONFIG_NETFILTER" != "n" ]; then
    source net/ipv6/netfilter/Config.in
 fi
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/Makefile linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/Makefile
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/Makefile	2000-12-29 23:07:24.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/Makefile	2003-05-18 11:33:53.000000000 +0200
@@ -9,14 +9,25 @@
 
 O_TARGET := ipv6.o
 
+export-objs :=	ipv6_tunnel.o
+
 obj-y :=	af_inet6.o ip6_output.o ip6_input.o addrconf.o sit.o \
 		route.o ip6_fib.o ipv6_sockglue.o ndisc.o udp.o raw.o \
 		protocol.o icmp.o mcast.o reassembly.o tcp_ipv6.o \
 		exthdrs.o sysctl_net_ipv6.o datagram.o proc.o \
 		ip6_flowlabel.o
 
+ifeq ($(CONFIG_IPV6_MOBILITY),m)
+obj-y += mipglue.o
+endif
+
+
 obj-m  := $(O_TARGET)
 
 #obj-$(CONFIG_IPV6_FIREWALL) += ip6_fw.o
 
+ifeq ($(CONFIG_IPV6_IPV6_TUNNEL),m)
+obj-m += ipv6_tunnel.o
+endif
+
 include $(TOPDIR)/Rules.make
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/addrconf.c linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/addrconf.c
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/addrconf.c	2002-12-18 01:04:00.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/addrconf.c	2003-05-18 11:33:53.000000000 +0200
@@ -64,6 +64,8 @@
 
 #include <asm/uaccess.h>
 
+#include <net/mipglue.h>
+
 #define IPV6_MAX_ADDRESSES 16
 
 /* Set to 3 to get tracing... */
@@ -75,6 +77,8 @@
 #define ADBG(x)
 #endif
 
+#define INFINITE	0xffffffff
+
 #ifdef CONFIG_SYSCTL
 static void addrconf_sysctl_register(struct inet6_dev *idev, struct ipv6_devconf *p);
 static void addrconf_sysctl_unregister(struct ipv6_devconf *p);
@@ -232,6 +236,7 @@
 	struct net_device *dev = idev->dev;
 	BUG_TRAP(idev->addr_list==NULL);
 	BUG_TRAP(idev->mc_list==NULL);
+	BUG_TRAP(list_empty(&idev->prefix_list) == 1);
 #ifdef NET_REFCNT_DEBUG
 	printk(KERN_DEBUG "in6_dev_finish_destroy: %s\n", dev ? dev->name : "NIL");
 #endif
@@ -258,6 +263,8 @@
 	if (ndev) {
 		memset(ndev, 0, sizeof(struct inet6_dev));
 
+		INIT_LIST_HEAD(&ndev->prefix_list);
+		ndev->prefix_lock = SPIN_LOCK_UNLOCKED;
 		ndev->lock = RW_LOCK_UNLOCKED;
 		ndev->dev = dev;
 		memcpy(&ndev->cnf, &ipv6_devconf_dflt, sizeof(ndev->cnf));
@@ -450,6 +457,56 @@
 	in6_ifa_put(ifp);
 }
 
+int ipv6_get_prefix_entries(struct prefix_info **plist, int ifindex, int plen)
+{
+	int count;
+	struct net_device *dev;
+	struct inet6_dev *idev;
+	struct list_head *head;
+	struct prefix_element *p;
+
+	if (plist == NULL) {
+		BUG_TRAP(plist != NULL);
+		return -EINVAL;
+	}
+	if ((dev = dev_get_by_index(ifindex)) == NULL) {
+		printk(KERN_WARNING "Bad I/F (%d) in ipv6_get_prefix_entries\n",
+		       ifindex);
+		return -EINVAL;
+	}
+
+	if ((idev = __in6_dev_get(dev)) == NULL) {
+		dev_put(dev);
+		return -EINVAL;
+	}
+
+	read_lock_bh(&idev->lock);
+	if (!(count = idev->prefix_count)) {
+		/* No elements on list */
+		goto out;
+	}
+	if ((*plist = kmalloc(count * sizeof(struct prefix_info),
+			      GFP_ATOMIC)) == NULL) {
+		count = -ENOMEM;
+		goto out;
+	}
+	count = 0;
+	spin_lock_bh(&idev->prefix_lock);
+	list_for_each(head, &idev->prefix_list) {
+		p = list_entry(head, struct prefix_element, list);
+		if (plen == 0 || p->pinfo.prefix_len == plen) {
+			memcpy(*plist + count, &p->pinfo,
+			       sizeof(struct prefix_info));
+			count++;
+		}
+	}
+	spin_unlock_bh(&idev->prefix_lock);
+ out:
+	read_unlock_bh(&idev->lock);
+	dev_put(dev);
+	return count;
+}
+
 /*
  *	Choose an apropriate source address
  *	should do:
@@ -565,6 +622,11 @@
 	if (match)
 		in6_ifa_put(match);
 
+	/* The home address is always used as source address in
+	 * MIPL mobile IPv6
+	 */
+	addrconf_get_mipv6_home_address(ifp, saddr);
+
 	return err;
 }
 
@@ -806,6 +868,70 @@
 	return idev;
 }
 
+static void ipv6_wash_prefix(struct in6_addr *pfx, int plen)
+{
+	int b = plen&0x7;
+	int o = (plen + 7)>>3;
+
+	if (o < 16)
+		memset(pfx->s6_addr + o, 0, 16 - o);
+	if (b != 0)
+		pfx->s6_addr[plen>>3] &= (0xFF<<(8-b));
+}
+
+static int ipv6_add_prefix(struct inet6_dev *idev, struct prefix_info *pinfo)
+{
+	int ifindex;
+	struct in6_addr	prefix;
+	struct list_head *head;
+	struct prefix_element *p;
+
+	ipv6_addr_prefix(&prefix, &pinfo->prefix, (int)pinfo->prefix_len);
+
+	/* Check if the prefix already exists in the list */
+	read_lock_bh(&idev->lock);
+	spin_lock_bh(&idev->prefix_lock);
+
+	ifindex = idev->dev->ifindex;
+
+	list_for_each(head, &idev->prefix_list) {
+		p = list_entry(head, struct prefix_element, list);
+		if (p->pinfo.prefix_len == pinfo->prefix_len
+		    && ipv6_addr_cmp(&p->pinfo.prefix, &prefix) == 0) {
+			int modified = addrconf_pfxs_modified(p, pinfo);
+			p->pinfo.valid = pinfo->valid;
+			p->timestamp = jiffies;
+			spin_unlock_bh(&idev->prefix_lock);
+			read_unlock_bh(&idev->lock);
+			if (modified)
+				addrconf_mipv6_pfxs_modified(pinfo, ifindex);
+			return 0;
+		}
+	}
+
+	/* New Prefix, allocate one and fill in */
+	if ((p = kmalloc(sizeof(struct prefix_element), GFP_ATOMIC)) == NULL) {
+		ADBG(("ipv6_add_prefix: malloc failed\n"));
+		spin_unlock_bh(&idev->prefix_lock);
+		read_unlock_bh(&idev->lock);
+		return -1;
+	}
+
+	memcpy(&p->pinfo, pinfo, sizeof(struct prefix_info));
+	ipv6_wash_prefix(&p->pinfo.prefix, pinfo->prefix_len);
+	p->timestamp = jiffies;
+
+	idev->prefix_count++;
+	list_add(&p->list, idev->prefix_list.prev);	/* add to end of list */
+
+	spin_unlock_bh(&idev->prefix_lock);
+	read_unlock_bh(&idev->lock);
+
+	addrconf_mipv6_pfxs_modified(pinfo, ifindex);
+
+	return 0;
+}
+
 void addrconf_prefix_rcv(struct net_device *dev, u8 *opt, int len)
 {
 	struct prefix_info *pinfo;
@@ -865,11 +991,15 @@
 	else
 		rt_expires = jiffies + valid_lft * HZ;
 
-	rt = rt6_lookup(&pinfo->prefix, NULL, dev->ifindex, 1);
+	addrconf_mipv6_prefix_route(&pinfo->prefix, pinfo->prefix_len,
+				    pinfo->onlink == 0 || valid_lft == 0, 
+				    rt_expires);
 
+	rt = rt6_lookup(&pinfo->prefix, NULL, dev->ifindex, 1);
+	
 	if (rt && ((rt->rt6i_flags & (RTF_GATEWAY | RTF_DEFAULT)) == 0)) {
 		if (rt->rt6i_flags&RTF_EXPIRES) {
-			if (pinfo->onlink == 0 || valid_lft == 0) {
+			if(pinfo->onlink == 0 || valid_lft == 0) {
 				ip6_del_rt(rt);
 				rt = NULL;
 			} else {
@@ -883,6 +1013,9 @@
 	if (rt)
 		dst_release(&rt->u.dst);
 
+	/* Add this prefix to the list of prefixes on this interface */
+	ipv6_add_prefix(in6_dev, pinfo);
+
 	/* Try to figure out our local address for this prefix */
 
 	if (pinfo->autoconf && in6_dev->cnf.autoconf) {
@@ -952,6 +1085,100 @@
 	in6_dev_put(in6_dev);
 }
 
+int addrconf_pfx_adv_rcv(struct net_device *dev, struct prefix_info *pinfo,
+			 struct in6_addr *home_addr)
+{
+	__u32 valid_lft;
+	__u32 prefered_lft;
+	int configured_new = 0;
+	int addr_type;
+	struct inet6_dev *in6_dev;
+
+	addr_type = ipv6_addr_type(&pinfo->prefix);
+
+	if (addr_type & (IPV6_ADDR_MULTICAST|IPV6_ADDR_LINKLOCAL))
+		return -1;
+
+	valid_lft = ntohl(pinfo->valid);
+	prefered_lft = ntohl(pinfo->prefered);
+
+	if (prefered_lft > valid_lft) {
+		if (net_ratelimit())
+			printk(KERN_WARNING "addrconf: prefix option has invalid lifetime\n");
+		return -1;
+	}
+
+        in6_dev = in6_dev_get(dev);
+
+	if (in6_dev == NULL) {
+		if (net_ratelimit())
+			printk(KERN_DEBUG "addrconf: device %s not configured\n", dev->name);
+		return -1;
+	}
+
+	if (pinfo->autoconf && in6_dev->cnf.autoconf) {
+		struct inet6_ifaddr * ifp;
+		struct in6_addr addr;
+		int plen;
+
+		plen = pinfo->prefix_len >> 3;
+
+		if (pinfo->prefix_len == 64) {
+			memcpy(&addr, &pinfo->prefix, 8);
+			if (ipv6_generate_eui64(addr.s6_addr + 8, dev) &&
+			    ipv6_inherit_eui64(addr.s6_addr + 8, in6_dev)) {
+				in6_dev_put(in6_dev);
+				return -1;
+			}
+			goto ok;
+                }
+		if (net_ratelimit())
+			printk(KERN_DEBUG "IPv6 addrconf: prefix with wrong length %d\n",
+			       pinfo->prefix_len);
+		in6_dev_put(in6_dev);
+		return -1;
+
+	ok:
+		ifp = ipv6_get_ifaddr(&addr, dev);
+ 
+		if (ifp == NULL && valid_lft) {
+			ifp = ipv6_add_addr(in6_dev, &addr, pinfo->prefix_len,
+					    addr_type&IPV6_ADDR_SCOPE_MASK, 0);
+
+			if (ifp == NULL) {
+				in6_dev_put(in6_dev);
+				return -1;
+			}
+
+			configured_new = 1;
+
+			ifp->flags &= ~IFA_F_TENTATIVE;
+
+			memcpy(home_addr, &addr, sizeof(struct in6_addr));
+		}
+
+		if (ifp && valid_lft == 0) {
+			ipv6_del_addr(ifp);
+			ifp = NULL;
+		}
+
+		if (ifp) {
+			spin_lock(&ifp->lock);
+			ifp->valid_lft = valid_lft;
+			ifp->prefered_lft = prefered_lft;
+			ifp->tstamp = jiffies;
+			spin_unlock(&ifp->lock);
+
+			if (configured_new)
+				ipv6_ifa_notify(RTM_NEWADDR, ifp);
+
+			in6_ifa_put(ifp);
+		}
+	}
+	in6_dev_put(in6_dev);
+	return configured_new;
+}
+
 /*
  *	Set destination address.
  *	Special case for SIT interfaces where we create a new "virtual"
@@ -1269,6 +1496,24 @@
 		sit_route_add(dev);
 }
 
+/**
+ * addrconf_ipv6_tunnel_config - configure IPv6 tunnel device
+ * @dev: tunnel device
+ **/
+
+static void addrconf_ipv6_tunnel_config(struct net_device *dev)
+{
+	struct inet6_dev *idev;
+
+	ASSERT_RTNL();
+
+	/* Assign inet6_dev structure to tunnel device */
+	if ((idev = ipv6_find_idev(dev)) == NULL) {
+		printk(KERN_DEBUG "init ipv6 tunnel: add_dev failed\n");
+		return;
+	}
+}
+
 
 int addrconf_notify(struct notifier_block *this, unsigned long event, 
 		    void * data)
@@ -1283,6 +1528,10 @@
 			addrconf_sit_config(dev);
 			break;
 
+		case ARPHRD_IPV6_IPV6_TUNNEL:
+			addrconf_ipv6_tunnel_config(dev);
+			break;
+
 		case ARPHRD_LOOPBACK:
 			init_loopback(dev);
 			break;
@@ -1335,6 +1584,8 @@
 {
 	struct inet6_dev *idev;
 	struct inet6_ifaddr *ifa, **bifa;
+	struct list_head	*head, *next;
+	struct prefix_element	*p;
 	int i;
 
 	ASSERT_RTNL();
@@ -1398,6 +1649,15 @@
 	else
 		ipv6_mc_down(idev);
 
+	/* Step 5: Free up Prefix List */
+	spin_lock_bh(&idev->prefix_lock);
+	list_for_each_safe(head, next, &idev->prefix_list) {
+		p = list_entry(head, struct prefix_element, list);
+		kfree(p);
+	}
+	INIT_LIST_HEAD(&idev->prefix_list);
+	spin_unlock_bh(&idev->prefix_lock);
+
 	/* Shot the device (if unregistered) */
 
 	if (how == 1) {
@@ -1620,6 +1880,44 @@
 
 #endif	/* CONFIG_PROC_FS */
 
+static void ipv6_expire_prefixes(void)
+{
+	unsigned long		now = jiffies;
+	struct net_device	*dev;
+	struct inet6_dev	*idev;
+	struct list_head	*head, *next;
+	struct prefix_element	*p;
+	unsigned long		age;
+
+	read_lock(&dev_base_lock);
+	for (dev = dev_base; dev; dev = dev->next) {
+		if (!(idev = __in6_dev_get(dev))) {
+			continue;
+		}
+		read_lock_bh(&idev->lock);
+		spin_lock_bh(&idev->prefix_lock);
+		if (list_empty(&idev->prefix_list)) {
+			spin_unlock_bh(&idev->prefix_lock);
+			read_unlock_bh(&idev->lock);
+			continue;
+		}
+		list_for_each_safe(head, next, &idev->prefix_list) {
+			p = list_entry(head, struct prefix_element, list);
+			if (p->pinfo.valid != INFINITE) {
+				age = (now - p->timestamp) / HZ;
+				if (age > ntohl(p->pinfo.valid)) {
+					idev->prefix_count--;
+					list_del(&p->list);
+					kfree(p);
+				}
+			}
+		}
+		spin_unlock_bh(&idev->prefix_lock);
+		read_unlock_bh(&idev->lock);
+	}
+	read_unlock(&dev_base_lock);
+}
+
 /*
  *	Periodic address status verification
  */
@@ -1687,6 +1985,13 @@
 		write_unlock(&addrconf_hash_lock);
 	}
 
+	/*
+	 * We need to expire prefixes even if no addresses are deleted in the
+	 * loop above, since autoconfiguration may not be set in all router
+	 * advertisements.
+	 */
+	ipv6_expire_prefixes();
+
 	addr_chk_timer.expires = time_before(next, jiffies + HZ) ? jiffies + HZ : next;
 	add_timer(&addr_chk_timer);
 	spin_unlock_bh(&addrconf_verify_lock);
@@ -1732,8 +2037,20 @@
 	if (rta[IFA_LOCAL-1]) {
 		if (pfx && memcmp(pfx, RTA_DATA(rta[IFA_LOCAL-1]), sizeof(*pfx)))
 			return -EINVAL;
+		if (ifm->ifa_flags & IFA_F_HOMEADDR && !rta[IFA_HOMEAGENT-1])
+			return -EINVAL;
 		pfx = RTA_DATA(rta[IFA_LOCAL-1]);
 	}
+	if (rta[IFA_HOMEAGENT-1]) {
+		struct in6_addr *ha;
+		if (pfx == NULL || !(ifm->ifa_flags & IFA_F_HOMEADDR))
+			return -EINVAL;
+		if (RTA_PAYLOAD(rta[IFA_HOMEAGENT-1]) < sizeof(*ha))
+			return -EINVAL;
+		ha = RTA_DATA(rta[IFA_HOMEAGENT-1]);
+		addrconf_set_mipv6_mn_home(ifm->ifa_index, pfx, ifm->ifa_prefixlen,
+					   ha, ifm->ifa_prefixlen);
+	}
 	if (pfx == NULL)
 		return -EINVAL;
 
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/exthdrs.c linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/exthdrs.c
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/exthdrs.c	2003-05-03 02:36:36.000000000 +0200
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/exthdrs.c	2003-05-18 11:37:11.000000000 +0200
@@ -41,6 +41,9 @@
 #include <net/ip6_route.h>
 #include <net/addrconf.h>
 
+#include <net/mipglue.h>
+#include <net/mipv6.h>
+
 #include <asm/uaccess.h>
 
 /*
@@ -160,7 +163,8 @@
  *****************************/
 
 struct tlvtype_proc tlvprocdestopt_lst[] = {
-	/* No destination options are defined now */
+	/* Mobility Support destination options */
+	{MIPV6_TLV_HOMEADDR,    mipv6_handle_dstopt},
 	{-1,			NULL}
 };
 
@@ -210,6 +214,7 @@
 
 	struct ipv6_rt_hdr *hdr;
 	struct rt0_hdr *rthdr;
+	struct rt2_hdr *rt2hdr;
 
 	if (!pskb_may_pull(skb, (skb->h.raw-skb->data)+8) ||
 	    !pskb_may_pull(skb, (skb->h.raw-skb->data)+((skb->h.raw[1]+1)<<3))) {
@@ -228,15 +233,21 @@
 
 looped_back:
 	if (hdr->segments_left == 0) {
-		opt->srcrt = skb->h.raw - skb->nh.raw;
+		if (hdr->type == IPV6_SRCRT_TYPE_0)
+			opt->srcrt = skb->h.raw - skb->nh.raw;
+		else if (hdr->type == IPV6_SRCRT_TYPE_2)
+			opt->srcrt2 = skb->h.raw - skb->nh.raw;
 		skb->h.raw += (hdr->hdrlen + 1) << 3;
 		opt->dst0 = opt->dst1;
 		opt->dst1 = 0;
 		return (&hdr->nexthdr) - skb->nh.raw;
 	}
 
-	if (hdr->type != IPV6_SRCRT_TYPE_0 || (hdr->hdrlen & 0x01)) {
-		icmpv6_param_prob(skb, ICMPV6_HDR_FIELD, hdr->type != IPV6_SRCRT_TYPE_0 ? 2 : 1);
+	if (((hdr->type != IPV6_SRCRT_TYPE_0) &&
+	     (hdr->type != IPV6_SRCRT_TYPE_2)) || (hdr->hdrlen & 0x01)) {
+		icmpv6_param_prob(skb, ICMPV6_HDR_FIELD, 
+				  ((hdr->type != IPV6_SRCRT_TYPE_0) &&
+				   (hdr->type != IPV6_SRCRT_TYPE_2)) ? 2 : 1);
 		return -1;
 	}
 
@@ -270,9 +281,23 @@
 
 	i = n - --hdr->segments_left;
 
-	rthdr = (struct rt0_hdr *) hdr;
-	addr = rthdr->addr;
-	addr += i - 1;
+	if (hdr->type == IPV6_SRCRT_TYPE_0) {
+		rthdr = (struct rt0_hdr *) hdr;
+		addr = rthdr->addr;
+		addr += i - 1;
+	} else {
+		if (hdr->hdrlen != 2 || hdr->segments_left != 0) {
+			icmpv6_param_prob(skb, ICMPV6_HDR_FIELD,
+					  hdr->hdrlen != 2 ? 1 : 3);
+			return -1;
+		}
+		/* check that address is this node's home address */
+		rt2hdr = (struct rt2_hdr *) hdr;
+		addr = &rt2hdr->addr;
+		if (!ipv6_chk_addr(addr, NULL)) {
+			return -1;
+		}
+	}
 
 	addr_type = ipv6_addr_type(addr);
 
@@ -325,6 +350,10 @@
    temporary (or permanent) backdoor.
    If listening socket set IPV6_RTHDR to 2, then we invert header.
                                                    --ANK (980729)
+
+   By the Mobile IPv6 specification Type 2 routing header MUST NOT be
+   inverted.
+                                                   --AJT (20020917)
  */
 
 struct ipv6_txoptions *
@@ -347,6 +376,18 @@
 	struct ipv6_txoptions *opt;
 	int hdrlen = ipv6_optlen(hdr);
 
+	if (hdr->type == IPV6_SRCRT_TYPE_2) {
+		opt = sock_kmalloc(sk, sizeof(*opt) + hdrlen, GFP_ATOMIC);
+		if (opt == NULL)
+			return NULL;
+		memset(opt, 0, sizeof(*opt));
+		opt->tot_len = sizeof(*opt) + hdrlen;
+		opt->srcrt = (void*)(opt+1);
+		opt->opt_nflen = hdrlen;
+		memcpy(opt->srcrt, hdr, sizeof(struct rt2_hdr));
+		return opt;
+	}
+
 	if (hdr->segments_left ||
 	    hdr->type != IPV6_SRCRT_TYPE_0 ||
 	    hdr->hdrlen & 0x01)
@@ -619,6 +660,8 @@
 			prev_hdr = ipv6_build_exthdr(skb, prev_hdr, NEXTHDR_DEST, opt->dst0opt);
 		if (opt->srcrt)
 			prev_hdr = ipv6_build_rthdr(skb, prev_hdr, opt->srcrt, daddr);
+		if (opt->srcrt2)
+			prev_hdr = ipv6_build_rthdr(skb, prev_hdr, opt->srcrt2, daddr);
 	}
 	return prev_hdr;
 }
@@ -681,6 +724,8 @@
 {
 	if (opt->srcrt)
 		ipv6_push_rthdr(skb, proto, opt->srcrt, daddr);
+	if (opt->srcrt2)
+		ipv6_push_rthdr(skb, proto, opt->srcrt2, daddr);
 	if (opt->dst0opt)
 		ipv6_push_exthdr(skb, proto, NEXTHDR_DEST, opt->dst0opt);
 	if (opt->hopopt)
@@ -714,6 +759,8 @@
 			*((char**)&opt2->auth) += dif;
 		if (opt2->srcrt)
 			*((char**)&opt2->srcrt) += dif;
+		if (opt2->srcrt2)
+			*((char**)&opt2->srcrt2) += dif;
 	}
 	return opt2;
 }
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/icmp.c linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/icmp.c
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/icmp.c	2002-12-18 01:04:00.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/icmp.c	2003-05-18 11:33:53.000000000 +0200
@@ -57,6 +57,8 @@
 #include <net/addrconf.h>
 #include <net/icmp.h>
 
+#include <net/mipglue.h>
+
 #include <asm/uaccess.h>
 #include <asm/system.h>
 
@@ -376,6 +378,8 @@
 
 	msg.len = len;
 
+	icmpv6_handle_mipv6_homeaddr(skb);
+
 	ip6_build_xmit(sk, icmpv6_getfrag, &msg, &fl, len, NULL, -1,
 		       MSG_DONTWAIT);
 	if (type >= ICMPV6_DEST_UNREACH && type <= ICMPV6_PARAMPROB)
@@ -573,13 +577,13 @@
 		rt6_pmtu_discovery(&orig_hdr->daddr, &orig_hdr->saddr, dev,
 				   ntohl(hdr->icmp6_mtu));
 
-		/*
-		 *	Drop through to notify
-		 */
+		icmpv6_notify(skb, type, hdr->icmp6_code, hdr->icmp6_mtu);
+		break;
 
 	case ICMPV6_DEST_UNREACH:
-	case ICMPV6_TIME_EXCEED:
 	case ICMPV6_PARAMPROB:
+		mipv6_icmp_rcv(skb);
+	case ICMPV6_TIME_EXCEED:
 		icmpv6_notify(skb, type, hdr->icmp6_code, hdr->icmp6_mtu);
 		break;
 
@@ -608,6 +612,13 @@
 	case ICMPV6_MGM_REDUCTION:
 		break;
 
+	case MIPV6_DHAAD_REQUEST:
+	case MIPV6_DHAAD_REPLY:
+	case MIPV6_PREFIX_SOLICIT:
+	case MIPV6_PREFIX_ADV:
+		mipv6_icmp_rcv(skb);
+		break;
+
 	default:
 		if (net_ratelimit())
 			printk(KERN_DEBUG "icmpv6: msg of unkown type\n");
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/ip6_fib.c linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/ip6_fib.c
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/ip6_fib.c	2002-12-18 01:04:00.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/ip6_fib.c	2003-05-18 11:33:53.000000000 +0200
@@ -18,6 +18,7 @@
  * 	Yuji SEKIYA @USAGI:	Support default route on router node;
  * 				remove ip6_null_entry from the top of
  * 				routing table.
+ * 	Ville Nuorvala:		Fixes to source address sub trees
  */
 #include <linux/config.h>
 #include <linux/errno.h>
@@ -40,7 +41,6 @@
 #include <net/ip6_route.h>
 
 #define RT6_DEBUG 2
-#undef CONFIG_IPV6_SUBTREES
 
 #if RT6_DEBUG >= 3
 #define RT6_TRACE(x...) printk(KERN_DEBUG x)
@@ -499,6 +499,8 @@
 		mod_timer(&ip6_fib_timer, jiffies + ip6_rt_gc_interval);
 }
 
+static struct rt6_info * fib6_find_prefix(struct fib6_node *fn);
+
 /*
  *	Add routing information to the routing tree.
  *	<destination addr>/<source addr>
@@ -510,6 +512,10 @@
 	struct fib6_node *fn;
 	int err = -ENOMEM;
 
+#ifdef CONFIG_IPV6_SUBTREES
+	struct fib6_node *pn = NULL;
+#endif
+
 	fn = fib6_add_1(root, &rt->rt6i_dst.addr, sizeof(struct in6_addr),
 			rt->rt6i_dst.plen, (u8*) &rt->rt6i_dst - (u8*) rt);
 
@@ -561,10 +567,6 @@
 			/* Now link new subtree to main tree */
 			sfn->parent = fn;
 			fn->subtree = sfn;
-			if (fn->leaf == NULL) {
-				fn->leaf = rt;
-				atomic_inc(&rt->rt6i_ref);
-			}
 		} else {
 			sn = fib6_add_1(fn->subtree, &rt->rt6i_src.addr,
 					sizeof(struct in6_addr), rt->rt6i_src.plen,
@@ -574,6 +576,13 @@
 				goto st_failure;
 		}
 
+		/* fib6_add_1 might have cleared the old leaf pointer */
+		if (fn->leaf == NULL) {
+			fn->leaf = rt;
+			atomic_inc(&rt->rt6i_ref);
+		}
+
+		pn = fn;
 		fn = sn;
 	}
 #endif
@@ -587,8 +596,30 @@
 	}
 
 out:
-	if (err)
+	if (err) {
+#ifdef CONFIG_IPV6_SUBTREES
+
+		/* If fib6_add_1 has cleared the old leaf pointer in the 
+		   super-tree leaf node, we have to find a new one for it. 
+		   
+		   This situation will never arise in the sub-tree since 
+		   the node will at least have the duplicate route that 
+		   caused fib6_add_rt2node to fail in the first place.
+		*/
+
+		if (pn && !(pn->fn_flags & RTN_RTINFO)) {
+			pn->leaf = fib6_find_prefix(pn);
+#if RT6_DEBUG >= 2
+			if (!pn->leaf) {
+				BUG_TRAP(pn->leaf);
+				pn->leaf = &ip6_null_entry;
+			}
+#endif
+			atomic_inc(&pn->leaf->rt6i_ref);
+		}
+#endif
 		dst_free(&rt->u.dst);
+	}
 	return err;
 
 #ifdef CONFIG_IPV6_SUBTREES
@@ -596,8 +627,8 @@
 	   is orphan. If it is, shot it.
 	 */
 st_failure:
-	if (fn && !(fn->fn_flags&RTN_RTINFO|RTN_ROOT))
-		fib_repair_tree(fn);
+	if (fn && !(fn->fn_flags & (RTN_RTINFO | RTN_ROOT)))
+		fib6_repair_tree(fn);
 	dst_free(&rt->u.dst);
 	return err;
 #endif
@@ -640,7 +671,7 @@
 		break;
 	}
 
-	while ((fn->fn_flags & RTN_ROOT) == 0) {
+	for (;;) {
 #ifdef CONFIG_IPV6_SUBTREES
 		if (fn->subtree) {
 			struct fib6_node *st;
@@ -656,6 +687,8 @@
 			}
 		}
 #endif
+		if (fn->fn_flags & RTN_ROOT)
+			break;
 
 		if (fn->fn_flags & RTN_RTINFO) {
 			struct rt6key *key;
@@ -745,10 +778,8 @@
 #ifdef CONFIG_IPV6_SUBTREES
 	if (src_len) {
 		BUG_TRAP(saddr!=NULL);
-		if (fn == NULL)
-			fn = fn->subtree;
 		if (fn)
-			fn = fib6_locate_1(fn, saddr, src_len,
+			fn = fib6_locate_1(fn->subtree, saddr, src_len,
 					   (u8*) &rt->rt6i_src - (u8*) rt);
 	}
 #endif
@@ -937,7 +968,7 @@
 			}
 			fn = fn->parent;
 		}
-		/* No more references are possiible at this point. */
+		/* No more references are possible at this point. */
 		if (atomic_read(&rt->rt6i_ref) != 1) BUG();
 	}
 
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/ip6_output.c linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/ip6_output.c
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/ip6_output.c	2002-12-18 01:04:00.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/ip6_output.c	2003-05-18 11:33:53.000000000 +0200
@@ -50,6 +50,8 @@
 #include <net/rawv6.h>
 #include <net/icmp.h>
 
+#include <net/mipglue.h>
+
 static __inline__ void ipv6_select_ident(struct sk_buff *skb, struct frag_hdr *fhdr)
 {
 	static u32 ipv6_fragmentation_id = 1;
@@ -189,7 +191,14 @@
 	u8  proto = fl->proto;
 	int seg_len = skb->len;
 	int hlimit;
+	int retval;
+	struct ipv6_txoptions *orig_opt = opt;
+
+	opt = ip6_add_mipv6_txoptions(sk, skb, orig_opt, fl, &dst);
 
+	if(orig_opt && !opt)
+		return -ENOMEM;
+		
 	if (opt) {
 		int head_room;
 
@@ -204,8 +213,11 @@
 			struct sk_buff *skb2 = skb_realloc_headroom(skb, head_room);
 			kfree_skb(skb);
 			skb = skb2;
-			if (skb == NULL)
+			if (skb == NULL) {
+				ip6_free_mipv6_txoptions(opt, orig_opt);
+
 				return -ENOBUFS;
+			}
 			if (sk)
 				skb_set_owner_w(skb, sk);
 		}
@@ -237,13 +249,19 @@
 
 	if (skb->len <= dst->pmtu) {
 		IP6_INC_STATS(Ip6OutRequests);
-		return NF_HOOK(PF_INET6, NF_IP6_LOCAL_OUT, skb, NULL, dst->dev, ip6_maybe_reroute);
+		ip6_mark_mipv6_packet(opt, skb);
+		retval = NF_HOOK(PF_INET6, NF_IP6_LOCAL_OUT, skb, NULL, dst->dev, ip6_maybe_reroute);
+		ip6_free_mipv6_txoptions(opt, orig_opt);
+		return retval; 
 	}
 
 	if (net_ratelimit())
 		printk(KERN_DEBUG "IPv6: sending pkt_too_big to self\n");
 	icmpv6_send(skb, ICMPV6_PKT_TOOBIG, 0, dst->pmtu, skb->dev);
 	kfree_skb(skb);
+
+	ip6_free_mipv6_txoptions(opt, orig_opt);
+
 	return -EMSGSIZE;
 }
 
@@ -467,6 +485,7 @@
 
 			IP6_INC_STATS(Ip6FragCreates);
 			IP6_INC_STATS(Ip6OutRequests);
+			ip6_mark_mipv6_packet(opt, skb);
 			err = NF_HOOK(PF_INET6,NF_IP6_LOCAL_OUT, skb, NULL, dst->dev, ip6_maybe_reroute);
 			if (err) {
 				kfree_skb(last_skb);
@@ -493,6 +512,7 @@
 	IP6_INC_STATS(Ip6FragCreates);
 	IP6_INC_STATS(Ip6FragOKs);
 	IP6_INC_STATS(Ip6OutRequests);
+	ip6_mark_mipv6_packet(opt, last_skb);
 	return NF_HOOK(PF_INET6, NF_IP6_LOCAL_OUT, last_skb, NULL,dst->dev, ip6_maybe_reroute);
 }
 
@@ -503,15 +523,27 @@
 	struct ipv6_pinfo *np = &sk->net_pinfo.af_inet6;
 	struct in6_addr *final_dst = NULL;
 	struct dst_entry *dst;
+	int reroute = 0;
 	int err = 0;
 	unsigned int pktlength, jumbolen, mtu;
 	struct in6_addr saddr;
+	struct ipv6_txoptions *orig_opt = opt; 
+
+	opt = ip6_add_mipv6_txoptions(sk, NULL, orig_opt, fl, NULL);
+
+	if(orig_opt && !opt)
+		return -ENOMEM;
 
 	if (opt && opt->srcrt) {
 		struct rt0_hdr *rt0 = (struct rt0_hdr *) opt->srcrt;
 		final_dst = fl->fl6_dst;
 		fl->fl6_dst = rt0->addr;
 	}
+	if (opt && opt->srcrt2) {
+                struct rt2_hdr *rt2 = (struct rt2_hdr *) opt->srcrt2;
+                final_dst = fl->fl6_dst;
+                fl->fl6_dst = &rt2->addr;
+        }
 
 	if (!fl->oif && ipv6_addr_is_multicast(fl->nl_u.ip6_u.daddr))
 		fl->oif = np->mcast_oif;
@@ -542,6 +574,14 @@
 		      ipv6_addr_cmp(fl->fl6_dst, &rt->rt6i_dst.addr))
 		     && (np->daddr_cache == NULL ||
 			 ipv6_addr_cmp(fl->fl6_dst, np->daddr_cache)))
+#ifdef CONFIG_IPV6_SUBTREES
+		    || (fl->fl6_src 
+			&& ((rt->rt6i_src.plen != 128 ||
+			     ipv6_addr_cmp(fl->fl6_src, &rt->rt6i_src.addr))
+			    && (np->saddr_cache == NULL ||
+				ipv6_addr_cmp(fl->fl6_dst, np->saddr_cache))))
+
+#endif
 		    || (fl->oif && fl->oif != dst->dev->ifindex)) {
 			dst = NULL;
 		} else
@@ -551,9 +591,13 @@
 	if (dst == NULL)
 		dst = ip6_route_output(sk, fl);
 
-	if (dst->error) {
+#ifdef CONFIG_IPV6_SUBTREES
+	reroute = (dst->error == -EAGAIN);
+#endif
+	if (!reroute && dst->error) {
 		IP6_INC_STATS(Ip6OutNoRoutes);
 		dst_release(dst);
+		ip6_free_mipv6_txoptions(opt, orig_opt);
 		return -ENETUNREACH;
 	}
 
@@ -568,6 +612,16 @@
 			goto out;
 		}
 		fl->fl6_src = &saddr;
+#ifdef CONFIG_IPV6_SUBTREES
+		dst_release(dst);
+		dst = ip6_route_output(sk, fl);
+		if (dst->error) {
+			IP6_INC_STATS(Ip6OutNoRoutes);
+			dst_release(dst);
+			ip6_free_mipv6_txoptions(opt, orig_opt);
+			return -ENETUNREACH;
+		}
+#endif
 	}
 	pktlength = length;
 
@@ -661,6 +715,7 @@
 
 		if (!err) {
 			IP6_INC_STATS(Ip6OutRequests);
+			ip6_mark_mipv6_packet(opt, skb);
 			err = NF_HOOK(PF_INET6, NF_IP6_LOCAL_OUT, skb, NULL, dst->dev, ip6_maybe_reroute);
 		} else {
 			err = -EFAULT;
@@ -682,9 +737,14 @@
 	 *	cleanup
 	 */
 out:
-	ip6_dst_store(sk, dst, fl->nl_u.ip6_u.daddr == &np->daddr ? &np->daddr : NULL);
+	ip6_dst_store(sk, dst, 
+		      fl->nl_u.ip6_u.daddr == &np->daddr ? &np->daddr : NULL,
+		      fl->nl_u.ip6_u.saddr == &np->saddr ? &np->saddr : NULL);
 	if (err > 0)
 		err = np->recverr ? net_xmit_errno(err) : 0;
+
+	ip6_free_mipv6_txoptions(opt, orig_opt);
+
 	return err;
 }
 
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/ipv6_tunnel.c linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/ipv6_tunnel.c
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/ipv6_tunnel.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/ipv6_tunnel.c	2003-05-18 11:33:53.000000000 +0200
@@ -0,0 +1,1896 @@
+/*
+ *	IPv6 over IPv6 tunnel device
+ *	Linux INET6 implementation
+ *
+ *	Authors:
+ *	Ville Nuorvala		<vnuorval@tml.hut.fi>	
+ *
+ *	$Id: s.ipv6_tunnel.c 1.23 02/11/29 15:33:51+02:00 vnuorval@amber.hut.mediapoli.com $
+ *
+ *      Based on:
+ *      linux/net/ipv6/sit.c
+ *
+ *      RFC 2473
+ *
+ *	This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ *
+ */
+
+#define __NO_VERSION__
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/types.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/if.h>
+#include <linux/in.h>
+#include <linux/ip.h>
+#include <linux/if_tunnel.h>
+#include <linux/net.h>
+#include <linux/in6.h>
+#include <linux/netdevice.h>
+#include <linux/if_arp.h>
+#include <linux/icmpv6.h>
+#include <linux/init.h>
+#include <linux/route.h>
+#include <linux/rtnetlink.h>
+#include <linux/tqueue.h>
+
+#include <asm/uaccess.h>
+#include <asm/atomic.h>
+
+#include <net/sock.h>
+#include <net/ipv6.h>
+#include <net/protocol.h>
+#include <net/ip6_route.h>
+#include <net/addrconf.h>
+#include <net/ipv6_tunnel.h>
+
+#ifdef MODULE
+MODULE_AUTHOR("Ville Nuorvala");
+MODULE_DESCRIPTION("IPv6 over IPv6 tunnel");
+MODULE_LICENSE("GPL");
+#endif
+
+#ifdef IPV6_TNL_DEBUG
+#define IPV6_TNL_TRACE(x...) printk(KERN_DEBUG __FUNCTION__ x "\n")
+#else
+#define IPV6_TNL_TRACE(x...) do {;} while(0)
+#endif
+
+/* socket used by ipv6_ipv6_tnl_xmit() for resending packets */
+static struct socket *ipv6_socket;
+
+/* current holder of socket */
+static int ipv6_xmit_holder = -1;
+
+/* socket locking functions copied from net/ipv6/icmp.c */
+
+static int
+ipv6_xmit_lock_bh(void)
+{
+	if (!spin_trylock(&ipv6_socket->sk->lock.slock)) {
+		if (ipv6_xmit_holder == smp_processor_id())
+			return -EAGAIN;
+		spin_lock(&ipv6_socket->sk->lock.slock);
+	}
+	ipv6_xmit_holder = smp_processor_id();
+	return 0;
+}
+
+static inline int
+ipv6_xmit_lock(void)
+{
+	int ret;
+	local_bh_disable();
+	ret = ipv6_xmit_lock_bh();
+	if (ret)
+		local_bh_enable();
+	return ret;
+}
+
+static void
+ipv6_xmit_unlock_bh(void)
+{
+	ipv6_xmit_holder = -1;
+	spin_unlock(&ipv6_socket->sk->lock.slock);
+}
+
+static inline void
+ipv6_xmit_unlock(void)
+{
+	ipv6_xmit_unlock_bh();
+	local_bh_enable();
+}
+
+#define HASH_SIZE  32
+
+#define HASH(addr) (((addr)->s6_addr16[0] ^ (addr)->s6_addr16[1] ^ \
+	             (addr)->s6_addr16[2] ^ (addr)->s6_addr16[3] ^ \
+                     (addr)->s6_addr16[4] ^ (addr)->s6_addr16[5] ^ \
+	             (addr)->s6_addr16[6] ^ (addr)->s6_addr16[7]) & \
+                    (HASH_SIZE - 1))
+
+static int ipv6_ipv6_fb_tnl_dev_init(struct net_device *dev);
+static int ipv6_ipv6_tnl_dev_init(struct net_device *dev);
+
+/* the IPv6 IPv6 tunnel fallback device */
+static struct net_device ipv6_ipv6_fb_tnl_dev = {
+	name:"ip6tnl0",
+	init:ipv6_ipv6_fb_tnl_dev_init
+};
+
+/* the IPv6 IPv6 fallback tunnel */
+static struct ipv6_tnl ipv6_ipv6_fb_tnl = {
+	dev:&ipv6_ipv6_fb_tnl_dev,
+      parms:{name: "ip6tnl0", proto:IPPROTO_IPV6}
+};
+
+/* lists for storing tunnels in use */
+static struct ipv6_tnl *tnls_r_l[HASH_SIZE];
+static struct ipv6_tnl *tnls_wc[1];
+static struct ipv6_tnl **tnls[2] = { tnls_wc, tnls_r_l };
+
+/* list for unused cached kernel tunnels */
+static struct ipv6_tnl *tnls_kernel[1];
+/* maximum number of cached kernel tunnels */
+static unsigned int max_kdev_count = 0;
+/* minimum number of cached kernel tunnels */
+static unsigned int min_kdev_count = 0;
+/* current number of cached kernel tunnels */
+static unsigned int kdev_count = 0;
+
+/* lists for tunnel hook functions */
+static struct list_head hooks[IPV6_TNL_MAXHOOKS];
+
+/* locks for the different lists */
+static rwlock_t ipv6_ipv6_lock = RW_LOCK_UNLOCKED;
+static rwlock_t ipv6_ipv6_kernel_lock = RW_LOCK_UNLOCKED;
+static rwlock_t ipv6_ipv6_hook_lock = RW_LOCK_UNLOCKED;
+
+/* flag indicating if the module is being removed */
+static int shutdown = 0;
+
+/**
+ * ipv6_ipv6_tnl_lookup - fetch tunnel matching the end-point addresses
+ *   @remote: the address of the tunnel exit-point 
+ *   @local: the address of the tunnel entry-point 
+ *
+ * Return:  
+ *   tunnel matching given end-points if found,
+ *   else fallback tunnel if its device is up, 
+ *   else %NULL
+ **/
+
+struct ipv6_tnl *
+ipv6_ipv6_tnl_lookup(struct in6_addr *remote, struct in6_addr *local)
+{
+	unsigned h0 = HASH(remote);
+	unsigned h1 = HASH(local);
+	struct ipv6_tnl *t;
+
+	IPV6_TNL_TRACE();
+
+	for (t = tnls_r_l[h0 ^ h1]; t; t = t->next) {
+		if (!ipv6_addr_cmp(local, &t->parms.laddr) &&
+		    !ipv6_addr_cmp(remote, &t->parms.raddr) &&
+		    (t->dev->flags & IFF_UP))
+			return t;
+	}
+	if ((t = tnls_wc[0]) != NULL && (t->dev->flags & IFF_UP))
+		return t;
+
+	return NULL;
+}
+
+/**
+ * ipv6_ipv6_bucket - get head of list matching given tunnel parameters
+ *   @p: parameters containing tunnel end-points 
+ *
+ * Description:
+ *   ipv6_ipv6_bucket() returns the head of the list matching the 
+ *   &struct in6_addr entries laddr and raddr in @p.
+ *
+ * Return: head of IPv6 tunnel list 
+ **/
+
+static struct ipv6_tnl **
+ipv6_ipv6_bucket(struct ipv6_tnl_parm *p)
+{
+	struct in6_addr *remote = &p->raddr;
+	struct in6_addr *local = &p->laddr;
+	unsigned h = 0;
+	int prio = 0;
+
+	IPV6_TNL_TRACE();
+
+	if (!ipv6_addr_any(remote) || !ipv6_addr_any(local)) {
+		prio = 1;
+		h = HASH(remote) ^ HASH(local);
+	}
+	return &tnls[prio][h];
+}
+
+/**
+ * ipv6_ipv6_kernel_tnl_link - add new kernel tunnel to cache
+ *   @t: kernel tunnel
+ *
+ * Note:
+ *   %IPV6_TNL_F_KERNEL_DEV is assumed to be raised in t->parms.flags. 
+ *   See the comments on ipv6_ipv6_kernel_tnl_add() for more information.
+ **/
+
+static inline void
+ipv6_ipv6_kernel_tnl_link(struct ipv6_tnl *t)
+{
+	IPV6_TNL_TRACE();
+
+	write_lock_bh(&ipv6_ipv6_kernel_lock);
+	t->next = tnls_kernel[0];
+	tnls_kernel[0] = t;
+	kdev_count++;
+	write_unlock_bh(&ipv6_ipv6_kernel_lock);
+}
+
+/**
+ * ipv6_ipv6_kernel_tnl_unlink - remove first kernel tunnel from cache
+ *
+ * Return: first free kernel tunnel
+ *
+ * Note:
+ *   See the comments on ipv6_ipv6_kernel_tnl_add() for more information.
+ **/
+
+static inline struct ipv6_tnl *
+ipv6_ipv6_kernel_tnl_unlink(void)
+{
+	struct ipv6_tnl *t;
+
+	IPV6_TNL_TRACE();
+
+	write_lock_bh(&ipv6_ipv6_kernel_lock);
+	if ((t = tnls_kernel[0]) != NULL) {
+		tnls_kernel[0] = t->next;
+		kdev_count--;
+	}
+	write_unlock_bh(&ipv6_ipv6_kernel_lock);
+	return t;
+}
+
+/**
+ * ipv6_ipv6_tnl_link - add tunnel to hash table
+ *   @t: tunnel to be added
+ **/
+
+static void
+ipv6_ipv6_tnl_link(struct ipv6_tnl *t)
+{
+	struct ipv6_tnl **tp = ipv6_ipv6_bucket(&t->parms);
+
+	IPV6_TNL_TRACE();
+
+	write_lock_bh(&ipv6_ipv6_lock);
+	t->next = *tp;
+	write_unlock_bh(&ipv6_ipv6_lock);
+	*tp = t;
+}
+
+/**
+ * ipv6_ipv6_tnl_unlink - remove tunnel from hash table
+ *   @t: tunnel to be removed
+ **/
+
+static void
+ipv6_ipv6_tnl_unlink(struct ipv6_tnl *t)
+{
+	struct ipv6_tnl **tp;
+
+	IPV6_TNL_TRACE();
+
+	for (tp = ipv6_ipv6_bucket(&t->parms); *tp; tp = &(*tp)->next) {
+		if (t == *tp) {
+			write_lock_bh(&ipv6_ipv6_lock);
+			*tp = t->next;
+			write_unlock_bh(&ipv6_ipv6_lock);
+			break;
+		}
+	}
+}
+
+/**
+ * ipv6_addr_local() - check if address is local
+ *   @addr: address to be checked
+ * 
+ * Return: 
+ *   1 if @addr assigned to any local network device,
+ *   0 otherwise
+ **/
+
+static inline int
+ipv6_addr_local(struct in6_addr *addr)
+{
+	struct inet6_ifaddr *ifr;
+	int local = 0;
+
+	IPV6_TNL_TRACE();
+
+	if ((ifr = ipv6_get_ifaddr(addr, NULL)) != NULL) {
+		local = 1;
+		in6_ifa_put(ifr);
+	}
+	return local;
+}
+
+/**
+ * ipv6_tnl_addrs_sane() - check that the tunnel end points are sane
+ *   @laddr: tunnel entry-point
+ *   @raddr: tunnel exit-point
+ *
+ * Description:
+ *   Sanity checks performed on tunnel end-points as suggested by
+ *   RFCs 1853, 2003 and 2473.
+ * 
+ * Return: 
+ *   1 if sane,
+ *   0 otherwise 
+ **/
+
+static inline int
+ipv6_tnl_addrs_sane(struct in6_addr *laddr, struct in6_addr *raddr)
+{
+	int laddr_type = ipv6_addr_type(laddr);
+	int raddr_type = ipv6_addr_type(raddr);
+
+	IPV6_TNL_TRACE();
+
+	if ((laddr_type &
+	     (IPV6_ADDR_ANY | IPV6_ADDR_LOOPBACK | IPV6_ADDR_RESERVED)) ||
+	    (raddr_type &
+	     (IPV6_ADDR_ANY | IPV6_ADDR_LOOPBACK | IPV6_ADDR_RESERVED)) ||
+	    ((laddr_type & IPV6_ADDR_UNICAST) && !ipv6_addr_local(laddr)) ||
+	    ((raddr_type & IPV6_ADDR_UNICAST) && ipv6_addr_local(raddr))) {
+		return 0;
+	}
+	return 1;
+}
+
+/**
+ * ipv6_tnl_create() - create a new tunnel
+ *   @p: tunnel parameters
+ *   @pt: pointer to new tunnel
+ *
+ * Description:
+ *   Create tunnel matching given parameters. New kernel managed devices are 
+ *   not put in the normal hash structure, but are instead cached for later
+ *   use.
+ * 
+ * Return: 
+ *   0 on success
+ **/
+
+static int
+ipv6_tnl_create(struct ipv6_tnl_parm *p, struct ipv6_tnl **pt)
+{
+	struct net_device *dev;
+	int kernel_dev;
+	int err = -ENOBUFS;
+	struct ipv6_tnl *t;
+
+	IPV6_TNL_TRACE();
+
+	kernel_dev = (p->flags & IPV6_TNL_F_KERNEL_DEV);
+
+	MOD_INC_USE_COUNT;
+	dev = kmalloc(sizeof (*dev) + sizeof (*t), GFP_KERNEL);
+	if (!dev) {
+		MOD_DEC_USE_COUNT;
+		return err;
+	}
+	memset(dev, 0, sizeof (*dev) + sizeof (*t));
+	dev->priv = (void *) (dev + 1);
+	t = (struct ipv6_tnl *) dev->priv;
+	t->dev = dev;
+	dev->init = ipv6_ipv6_tnl_dev_init;
+	dev->features |= NETIF_F_DYNALLOC;
+	if (kernel_dev) {
+		memcpy(t->parms.name, p->name, IFNAMSIZ - 1);
+		t->parms.proto = IPPROTO_IPV6;
+		t->parms.flags = IPV6_TNL_F_KERNEL_DEV;
+	} else {
+		memcpy(&t->parms, p, sizeof (*p));
+	}
+	t->parms.name[IFNAMSIZ - 1] = '\0';
+	if (t->parms.hop_limit > 255)
+		t->parms.hop_limit = -1;
+	strcpy(dev->name, t->parms.name);
+	if (!dev->name[0]) {
+		int i = 0;
+		int exists = 0;
+
+		do {
+			sprintf(dev->name, "ip6tnl%d", ++i);
+			exists = (__dev_get_by_name(dev->name) != NULL);
+		} while (i < IPV6_TNL_MAX && exists);
+
+		if (i == IPV6_TNL_MAX) {
+			goto failed;
+		}
+		memcpy(t->parms.name, dev->name, IFNAMSIZ);
+	}
+	if ((err = register_netdevice(dev)) < 0) {
+		goto failed;
+	}
+	if (kernel_dev) {
+		ipv6_ipv6_kernel_tnl_link(t);
+	} else {
+		ipv6_ipv6_tnl_link(t);
+	}
+	*pt = t;
+	return 0;
+      failed:
+	kfree(dev);
+	MOD_DEC_USE_COUNT;
+	return err;
+}
+
+/**
+ * ipv6_tnl_destroy() - destroy old tunnel
+ *   @t: tunnel to be destroyed
+ *
+ * Return:
+ *   whatever unregister_netdevice() returns
+ **/
+
+static inline int
+ipv6_tnl_destroy(struct ipv6_tnl *t)
+{
+	IPV6_TNL_TRACE();
+	return unregister_netdevice(t->dev);
+}
+
+static void manage_kernel_tnls(void *foo);
+
+static struct tq_struct manager_task = {
+	routine:manage_kernel_tnls,
+	data:NULL
+};
+
+/**
+ * manage_kernel_tnls() - create and destroy kernel tunnels
+ *
+ * Description:
+ *   manage_kernel_tnls() creates new kernel devices if there
+ *   are less than $min_kdev_count of them and deletes old ones if
+ *   there are less than $max_kdev_count of them in the cache
+ *
+ * Note:
+ *   Schedules itself to be run later in process context if called from 
+ *   interrupt. Therefore only works synchronously when called from process 
+ *   context.
+ **/
+
+static void
+manage_kernel_tnls(void *foo)
+{
+	struct ipv6_tnl *t = NULL;
+	struct ipv6_tnl_parm parm;
+
+	IPV6_TNL_TRACE();
+
+	/* We can't do this processing in interrupt 
+	   context so schedule it for later */
+	if (in_interrupt()) {
+		read_lock(&ipv6_ipv6_kernel_lock);
+		if (!shutdown &&
+		    (kdev_count < min_kdev_count ||
+		     kdev_count > max_kdev_count)) {
+			schedule_task(&manager_task);
+		}
+		read_unlock(&ipv6_ipv6_kernel_lock);
+		return;
+	}
+
+	rtnl_lock();
+	read_lock_bh(&ipv6_ipv6_kernel_lock);
+	memset(&parm, 0, sizeof (parm));
+	parm.flags = IPV6_TNL_F_KERNEL_DEV;
+	/* Create tunnels until there are at least min_kdev_count */
+	while (kdev_count < min_kdev_count) {
+		read_unlock_bh(&ipv6_ipv6_kernel_lock);
+		if (!ipv6_tnl_create(&parm, &t)) {
+			dev_open(t->dev);
+		} else {
+			goto err;
+		}
+		read_lock_bh(&ipv6_ipv6_kernel_lock);
+	}
+
+	/* Destroy tunnels until there are at most max_kdev_count */
+	while (kdev_count > max_kdev_count) {
+		read_unlock_bh(&ipv6_ipv6_kernel_lock);
+		if ((t = ipv6_ipv6_kernel_tnl_unlink()) != NULL) {
+			ipv6_tnl_destroy(t);
+		} else {
+			goto err;
+		}
+		read_lock_bh(&ipv6_ipv6_kernel_lock);
+	}
+	read_unlock_bh(&ipv6_ipv6_kernel_lock);
+      err:
+	rtnl_unlock();
+}
+
+/**
+ * ipv6_ipv6_tnl_inc_max_kdev_count() - increase max kernel dev cache size
+ *   @n: size increase
+ * Description:
+ *   Increase the upper limit for the number of kernel devices allowed in the 
+ *   cache at any on time.
+ **/
+
+unsigned int
+ipv6_ipv6_tnl_inc_max_kdev_count(unsigned int n)
+{
+	IPV6_TNL_TRACE();
+
+	write_lock_bh(&ipv6_ipv6_kernel_lock);
+	max_kdev_count += n;
+	write_unlock_bh(&ipv6_ipv6_kernel_lock);
+	manage_kernel_tnls(NULL);
+	return max_kdev_count;
+}
+
+/**
+ * ipv6_ipv6_tnl_dec_max_kdev_count() -  decrease max kernel dev cache size
+ *   @n: size decrement
+ * Description:
+ *   Decrease the upper limit for the number of kernel devices allowed in the 
+ *   cache at any on time.
+ **/
+
+unsigned int
+ipv6_ipv6_tnl_dec_max_kdev_count(unsigned int n)
+{
+	IPV6_TNL_TRACE();
+
+	write_lock_bh(&ipv6_ipv6_kernel_lock);
+	max_kdev_count -= min(max_kdev_count, n);
+	if (max_kdev_count < min_kdev_count)
+		min_kdev_count = max_kdev_count;
+	write_unlock_bh(&ipv6_ipv6_kernel_lock);
+	manage_kernel_tnls(NULL);
+	return max_kdev_count;
+}
+
+/**
+ * ipv6_ipv6_tnl_inc_min_kdev_count() - increase min kernel dev cache size
+ *   @n: size increase
+ * Description:
+ *   Increase the lower limit for the number of kernel devices allowed in the 
+ *   cache at any on time.
+ **/
+
+unsigned int
+ipv6_ipv6_tnl_inc_min_kdev_count(unsigned int n)
+{
+	IPV6_TNL_TRACE();
+
+	write_lock_bh(&ipv6_ipv6_kernel_lock);
+	min_kdev_count += n;
+	if (min_kdev_count > max_kdev_count)
+		max_kdev_count = min_kdev_count;
+	write_unlock_bh(&ipv6_ipv6_kernel_lock);
+	manage_kernel_tnls(NULL);
+	return min_kdev_count;
+}
+
+/**
+ * ipv6_ipv6_tnl_dec_min_kdev_count() -  decrease min kernel dev cache size
+ *   @n: size decrement
+ * Description:
+ *   Decrease the lower limit for the number of kernel devices allowed in the 
+ *   cache at any on time.
+ **/
+
+unsigned int
+ipv6_ipv6_tnl_dec_min_kdev_count(unsigned int n)
+{
+	IPV6_TNL_TRACE();
+
+	write_lock_bh(&ipv6_ipv6_kernel_lock);
+	min_kdev_count -= min(min_kdev_count, n);
+	write_unlock_bh(&ipv6_ipv6_kernel_lock);
+	manage_kernel_tnls(NULL);
+	return min_kdev_count;
+}
+
+/**
+ * ipv6_ipv6_tnl_locate - find or create tunnel matching given parameters
+ *   @p: tunnel parameters 
+ *   @create: != 0 if allowed to create new tunnel if no match found
+ *
+ * Description:
+ *   ipv6_ipv6_tnl_locate() first tries to locate an existing tunnel
+ *   based on @parms. If this is unsuccessful, but @create is set a new
+ *   tunnel device is created and registered for use.
+ *
+ * Return:
+ *   0 if tunnel located or created,
+ *   -EINVAL if parameters incorrect,
+ *   -ENODEV if no matching tunnel available
+ **/
+
+static int
+ipv6_ipv6_tnl_locate(struct ipv6_tnl_parm *p, struct ipv6_tnl **pt, int create)
+{
+	struct in6_addr *remote = &p->raddr;
+	struct in6_addr *local = &p->laddr;
+	struct ipv6_tnl *t;
+
+	IPV6_TNL_TRACE();
+
+	if (p->proto != IPPROTO_IPV6 ||
+	    (!(p->flags & IPV6_TNL_F_KERNEL_DEV) &&
+	     !ipv6_tnl_addrs_sane(local, remote)))
+		return -EINVAL;
+
+	for (t = *ipv6_ipv6_bucket(p); t; t = t->next) {
+		if (!ipv6_addr_cmp(local, &t->parms.laddr) &&
+		    !ipv6_addr_cmp(remote, &t->parms.raddr)) {
+			*pt = t;
+			return (create ? -EEXIST : 0);
+		}
+	}
+	/* Kernel devices are created on demand in 
+	   manage_kernel_tnls() */
+	if (!create || (p->flags & IPV6_TNL_F_KERNEL_DEV)) {
+		return -ENODEV;
+	}
+	return ipv6_tnl_create(p, pt);
+}
+
+/**
+ * ipv6_ipv6_tnl_dev_destructor - tunnel device destructor
+ *   @dev: the device to be destroyed
+ **/
+
+static void
+ipv6_ipv6_tnl_dev_destructor(struct net_device *dev)
+{
+	IPV6_TNL_TRACE();
+
+	if (dev != &ipv6_ipv6_fb_tnl_dev) {
+		MOD_DEC_USE_COUNT;
+	}
+}
+
+/**
+ * ipv6_ipv6_tnl_dev_uninit - tunnel device uninitializer
+ *   @dev: the device to be destroyed
+ *   
+ * Description:
+ *   ipv6_ipv6_tnl_dev_uninit() removes tunnel from its list
+ **/
+
+static void
+ipv6_ipv6_tnl_dev_uninit(struct net_device *dev)
+{
+	IPV6_TNL_TRACE();
+
+	if (dev == &ipv6_ipv6_fb_tnl_dev) {
+		write_lock_bh(&ipv6_ipv6_lock);
+		tnls_wc[0] = NULL;
+		write_unlock_bh(&ipv6_ipv6_lock);
+	} else {
+		struct ipv6_tnl *t = (struct ipv6_tnl *) dev->priv;
+		ipv6_ipv6_tnl_unlink(t);
+	}
+}
+
+/**
+ * parse_tvl_tnl_enc_lim - handle encapsulation limit option
+ *   @skb: received socket buffer
+ *
+ * Return: 
+ *   0 if none was found, 
+ *   else index to encapsulation limit
+ **/
+
+static __u16
+parse_tlv_tnl_enc_lim(struct sk_buff *skb, __u8 * raw)
+{
+	struct ipv6hdr *ipv6h = (struct ipv6hdr *) raw;
+	__u8 nexthdr = ipv6h->nexthdr;
+	__u16 off = sizeof (*ipv6h);
+
+	IPV6_TNL_TRACE();
+
+	while (ipv6_ext_hdr(nexthdr) && nexthdr != NEXTHDR_NONE) {
+		__u16 optlen = 0;
+		struct ipv6_opt_hdr *hdr;
+		if (raw + off + sizeof (*hdr) > skb->data &&
+		    !pskb_may_pull(skb, raw - skb->data + off + sizeof (*hdr)))
+			break;
+
+		hdr = (struct ipv6_opt_hdr *) (raw + off);
+		if (nexthdr == NEXTHDR_FRAGMENT) {
+			struct frag_hdr *frag_hdr = (struct frag_hdr *) hdr;
+			if (frag_hdr->frag_off)
+				break;
+			optlen = 8;
+		} else if (nexthdr == NEXTHDR_AUTH) {
+			optlen = (hdr->hdrlen + 2) << 2;
+		} else {
+			optlen = ipv6_optlen(hdr);
+		}
+		if (nexthdr == NEXTHDR_DEST) {
+			__u16 i = off + 2;
+			while (1) {
+				struct ipv6_tlv_tnl_enc_lim *tel;
+
+				/* No more room for encapsulation limit */
+				if (i + sizeof (*tel) > off + optlen)
+					break;
+
+				tel = (struct ipv6_tlv_tnl_enc_lim *) &raw[i];
+				/* return index of option if found and valid */
+				if (tel->type == IPV6_TLV_TNL_ENCAP_LIMIT &&
+				    tel->length == 1)
+					return i;
+				/* else jump to next option */
+				if (tel->type)
+					i += tel->length + 2;
+				else
+					i++;
+			}
+		}
+		nexthdr = hdr->nexthdr;
+		off += optlen;
+	}
+	return 0;
+}
+
+/**
+ * ipv6_ipv6_err - tunnel error handler
+ *
+ * Description:
+ *   ipv6_ipv6_err() should handle errors in the tunnel according
+ *   to the specifications in RFC 2473.
+ **/
+
+void
+ipv6_ipv6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,
+	      int type, int code, int offset, __u32 info)
+{
+	struct ipv6hdr *tipv6h = (struct ipv6hdr *) skb->data;
+	struct ipv6hdr *ipv6h = NULL;
+	struct ipv6_tnl *t;
+	int rel_msg = 0;
+	int rel_type = ICMPV6_DEST_UNREACH;
+	int rel_code = ICMPV6_ADDR_UNREACH;
+	__u32 rel_info = 0;
+	__u16 len;
+
+	IPV6_TNL_TRACE();
+
+	/* If the packet doesn't contain the original IPv6 header we are 
+	   in trouble since we might need the source address for furter 
+	   processing of the error. */
+
+	if (pskb_may_pull(skb, offset + sizeof (*ipv6h)))
+		ipv6h = (struct ipv6hdr *) &skb->data[offset];
+
+	read_lock(&ipv6_ipv6_lock);
+	if ((t = ipv6_ipv6_tnl_lookup(&tipv6h->daddr, &tipv6h->saddr)) == NULL)
+		goto out;
+
+	switch (type) {
+		__u32 teli;
+		struct ipv6_tlv_tnl_enc_lim *tel;
+		__u32 mtu;
+	case ICMPV6_DEST_UNREACH:
+		printk(KERN_ERR
+		       "%s: Path to destination invalid or inactive!\n",
+		       t->parms.name);
+		rel_msg = 1;
+		break;
+	case ICMPV6_TIME_EXCEED:
+		if (code == ICMPV6_EXC_HOPLIMIT) {
+			printk(KERN_ERR
+			       "%s: Too small hop limit or "
+			       "routing loop in tunnel!\n", t->parms.name);
+			rel_msg = 1;
+		}
+		break;
+	case ICMPV6_PARAMPROB:
+		/* ignore if parameter problem not caused by a tunnel
+		   encapsulation limit sub-option */
+		if (code != ICMPV6_HDR_FIELD) {
+			break;
+		}
+		teli = parse_tlv_tnl_enc_lim(skb, skb->data);
+
+		if (teli && teli == info - 2) {
+			tel = (struct ipv6_tlv_tnl_enc_lim *) &skb->data[teli];
+			if (tel->encap_limit <= 1) {
+				printk(KERN_ERR
+				       "%s: Too small encapsulation limit or "
+				       "routing loop in tunnel!\n",
+				       t->parms.name);
+				rel_msg = 1;
+			}
+		}
+		break;
+	case ICMPV6_PKT_TOOBIG:
+		mtu = info - offset;
+		if (mtu <= IPV6_MIN_MTU) {
+			mtu = IPV6_MIN_MTU;
+		}
+		t->dev->mtu = mtu;
+
+		if (ipv6h && (len = sizeof (*ipv6h) + ipv6h->payload_len) > mtu) {
+			rel_type = ICMPV6_PKT_TOOBIG;
+			rel_code = 0;
+			rel_info = mtu;
+			rel_msg = 1;
+		}
+		break;
+	}
+	if (rel_msg && ipv6h) {
+		struct rt6_info *rt6i;
+		struct sk_buff *skb2 = skb_clone(skb, GFP_ATOMIC);
+
+		if (!skb2)
+			goto out;
+
+		dst_release(skb2->dst);
+		skb2->dst = NULL;
+		skb_pull(skb2, offset);
+		skb2->nh.raw = skb2->data;
+
+		/* Try to guess incoming interface */
+		rt6i = rt6_lookup(&ipv6h->saddr, NULL, 0, 0);
+		if (rt6i && rt6i->rt6i_dev)
+			skb2->dev = rt6i->rt6i_dev;
+
+		icmpv6_send(skb2, rel_type, rel_code, rel_info, skb2->dev);
+		kfree_skb(skb2);
+	}
+      out:
+	read_unlock(&ipv6_ipv6_lock);
+}
+
+/**
+ * call_hooks - call ipv6 tunnel hooks
+ *   @hooknum: hook number, either %IPV6_TNL_PRE_ENCAP, or 
+ *   %IPV6_TNL_PRE_DECAP
+ *   @t: the current tunnel
+ *   @skb: the tunneled packet
+ *
+ * Description:
+ *   Pass packet to all the hook functions until %IPV6_TNL_DROP or
+ *   %IPV6_TNL_STOLEN returned by one of them.
+ *
+ * Return:
+ *   %IPV6_TNL_ACCEPT, %IPV6_TNL_DROP or %IPV6_TNL_STOLEN
+ **/
+
+static inline int
+call_hooks(unsigned int hooknum, struct ipv6_tnl *t, struct sk_buff *skb)
+{
+	struct ipv6_tnl_hook_ops *h;
+	int accept = IPV6_TNL_ACCEPT;
+
+	IPV6_TNL_TRACE();
+
+	if (hooknum < IPV6_TNL_MAXHOOKS) {
+		struct list_head *i;
+		read_lock(&ipv6_ipv6_hook_lock);
+		for (i = hooks[hooknum].next; i != &hooks[hooknum]; i = i->next) {
+			h = (struct ipv6_tnl_hook_ops *) i;
+
+			if (h->hook) {
+				accept = h->hook(t, skb);
+
+				if (accept != IPV6_TNL_ACCEPT)
+					break;
+			}
+		}
+		read_unlock(&ipv6_ipv6_hook_lock);
+	}
+	return accept;
+}
+
+/**
+ * ipv6_ipv6_rcv - decapsulate IPv6 packet and retransmit it locally
+ *   @skb: received socket buffer
+ *
+ * Return: 0
+ **/
+
+int
+ipv6_ipv6_rcv(struct sk_buff *skb)
+{
+	struct ipv6hdr *ipv6h;
+	struct ipv6_tnl *t;
+
+	IPV6_TNL_TRACE();
+
+	if (!pskb_may_pull(skb, sizeof (*ipv6h)))
+		goto out;
+
+	ipv6h = skb->nh.ipv6h;
+
+	read_lock(&ipv6_ipv6_lock);
+
+	if ((t = ipv6_ipv6_tnl_lookup(&ipv6h->saddr, &ipv6h->daddr)) != NULL) {
+		int hookval = call_hooks(IPV6_TNL_PRE_DECAP, t, skb);
+		switch (hookval) {
+		case IPV6_TNL_ACCEPT:
+			break;
+		case IPV6_TNL_STOLEN:
+			goto ignore_packet;
+		default:
+			if (hookval != IPV6_TNL_DROP) {
+				printk(KERN_ERR
+				       "%s: Unknown return value for tunnel hook!\n",
+				       t->parms.name);
+			}
+			t->stat.rx_dropped++;
+			goto drop_packet;
+		}
+		skb->mac.raw = skb->nh.raw;
+		skb->nh.raw = skb->data;
+		skb->protocol = htons(ETH_P_IPV6);
+		skb->pkt_type = PACKET_HOST;
+		skb->dev = t->dev;
+		dst_release(skb->dst);
+		skb->dst = NULL;
+		t->stat.rx_packets++;
+		t->stat.rx_bytes += skb->len;
+		netif_rx(skb);
+		read_unlock(&ipv6_ipv6_lock);
+		return 0;
+	}
+	icmpv6_send(skb, ICMPV6_DEST_UNREACH, ICMPV6_ADDR_UNREACH, 0, skb->dev);
+      drop_packet:
+	kfree_skb(skb);
+      ignore_packet:
+	read_unlock(&ipv6_ipv6_lock);
+      out:
+	return 0;
+}
+
+/**
+ * txopt_len - get necessary size for new &struct ipv6_txoptions
+ *   @orig_opt: old options
+ *
+ * Return:
+ *   Size of old one plus size of tunnel encapsulation limit option
+ **/
+
+static inline int
+txopt_len(struct ipv6_txoptions *orig_opt)
+{
+	int len = sizeof (*orig_opt) + 8;
+
+	IPV6_TNL_TRACE();
+
+	if (orig_opt && orig_opt->dst0opt)
+		len += ipv6_optlen(orig_opt->dst0opt);
+	return len;
+}
+
+/**
+ * merge_options - add encapsulation limit to original options
+ *   @encap_limit: number of allowed encapsulation limits
+ *   @orig_opt: original options
+ * 
+ * Return:
+ *   Pointer to new &struct ipv6_txoptions containing the tunnel
+ *   encapsulation limit
+ **/
+
+static inline struct ipv6_txoptions *
+merge_options(struct sock *sk, __u8 encap_limit,
+	      struct ipv6_txoptions *orig_opt)
+{
+	struct ipv6_tlv_tnl_enc_lim *tel;
+	struct ipv6_txoptions *opt;
+	__u8 *raw;
+	__u8 pad_to = 8;
+	int opt_len = txopt_len(orig_opt);
+
+	IPV6_TNL_TRACE();
+
+	if (!(opt = sock_kmalloc(sk, opt_len, GFP_ATOMIC))) {
+		return NULL;
+	}
+
+	memset(opt, 0, opt_len);
+	opt->tot_len = opt_len;
+	opt->dst0opt = (struct ipv6_opt_hdr *) (opt + 1);
+	opt->opt_nflen = 8;
+
+	raw = (__u8 *) opt->dst0opt;
+
+	tel = (struct ipv6_tlv_tnl_enc_lim *) (opt->dst0opt + 1);
+	tel->type = IPV6_TLV_TNL_ENCAP_LIMIT;
+	tel->length = 1;
+	tel->encap_limit = encap_limit;
+
+	if (orig_opt) {
+		__u8 *orig_raw;
+
+		opt->hopopt = orig_opt->hopopt;
+
+		/* Keep the original destination options properly
+		   aligned and merge possible old paddings to the
+		   new padding option */
+		if ((orig_raw = (__u8 *) orig_opt->dst0opt) != NULL) {
+			__u8 type;
+			int i = sizeof (struct ipv6_opt_hdr);
+			pad_to += sizeof (struct ipv6_opt_hdr);
+			while (i < ipv6_optlen(orig_opt->dst0opt)) {
+				type = orig_raw[i++];
+				if (type == IPV6_TLV_PAD0)
+					pad_to++;
+				else if (type == IPV6_TLV_PADN) {
+					int len = orig_raw[i++];
+					i += len;
+					pad_to += len + 2;
+				} else {
+					break;
+				}
+			}
+			opt->dst0opt->hdrlen = orig_opt->dst0opt->hdrlen + 1;
+			memcpy(raw + pad_to, orig_raw + pad_to - 8,
+			       opt_len - sizeof (*opt) - pad_to);
+		}
+		opt->srcrt = orig_opt->srcrt;
+		opt->opt_nflen += orig_opt->opt_nflen;
+
+		opt->dst1opt = orig_opt->dst1opt;
+		opt->auth = orig_opt->auth;
+		opt->opt_flen = orig_opt->opt_flen;
+	}
+	raw[5] = IPV6_TLV_PADN;
+
+	/* subtract lengths of destination suboption header,
+	   tunnel encapsulation limit and pad N header */
+	raw[6] = pad_to - 7;
+
+	return opt;
+}
+
+static int
+ipv6_ipv6_getfrag(const void *data, struct in6_addr *addr,
+		  char *buff, unsigned int offset, unsigned int len)
+{
+	memcpy(buff, data + offset, len);
+	return 0;
+}
+
+/**
+ * ipv6_ipv6_tnl_addr_conflict - compare packet addresses to tunnel's own
+ *   @t: the outgoing tunnel device
+ *   @hdr: IPv6 header from the incoming packet 
+ *
+ * Description:
+ *   Avoid trivial tunneling loop by checking that tunnel exit-point 
+ *   doesn't match source of incoming packet.
+ *
+ * Return: 
+ *   1 if conflict,
+ *   0 else
+ **/
+
+static inline int
+ipv6_ipv6_tnl_addr_conflict(struct ipv6_tnl *t, struct ipv6hdr *hdr)
+{
+	return !ipv6_addr_cmp(&t->parms.raddr, &hdr->saddr);
+}
+
+/**
+ * ipv6_ipv6_tnl_xmit - encapsulate packet and send 
+ *   @skb: the outgoing socket buffer
+ *   @dev: the outgoing tunnel device 
+ *
+ * Description:
+ *   Build new header and do some sanity checks on the packet before sending
+ *   it to ip6_build_xmit().
+ *
+ * Return: 
+ *   0
+ **/
+
+static int
+ipv6_ipv6_tnl_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct ipv6_tnl *t = (struct ipv6_tnl *) dev->priv;
+	struct net_device_stats *stats = &t->stat;
+	struct ipv6hdr *ipv6h = skb->nh.ipv6h;
+	int hookval;
+	struct ipv6_txoptions *orig_opt = NULL;
+	struct ipv6_txoptions *opt = NULL;
+	__u8 encap_limit = 0;
+	__u16 offset;
+	struct flowi fl;
+	struct ip6_flowlabel *fl_lbl = NULL;
+	int err = 0;
+	struct dst_entry *dst;
+	int link_failure = 0;
+	struct sock *sk = ipv6_socket->sk;
+	struct net_device *tdev;
+	int mtu;
+
+	IPV6_TNL_TRACE();
+
+	if (t->recursion++) {
+		stats->collisions++;
+		goto tx_err;
+	}
+	if (skb->protocol != htons(ETH_P_IPV6) ||
+	    (t->parms.flags & IPV6_TNL_F_RCV_ONLY) ||
+	    ipv6_ipv6_tnl_addr_conflict(t, ipv6h) ||
+	    (!(t->parms.flags & IPV6_TNL_F_ALLOW_LOCAL) &&
+	     ipv6_addr_local(&ipv6h->saddr))) {
+		goto tx_err;
+	}
+	if ((offset = parse_tlv_tnl_enc_lim(skb, skb->nh.raw)) > 0) {
+		struct ipv6_tlv_tnl_enc_lim *tel;
+		tel = (struct ipv6_tlv_tnl_enc_lim *) &skb->nh.raw[offset];
+		if (tel->encap_limit <= 1) {
+			icmpv6_send(skb, ICMPV6_PARAMPROB,
+				    ICMPV6_HDR_FIELD, offset + 2, skb->dev);
+			goto tx_err;
+		}
+		encap_limit = tel->encap_limit - 1;
+	} else if (!(t->parms.flags & IPV6_TNL_F_IGN_ENCAP_LIMIT)) {
+		encap_limit = t->parms.encap_limit;
+	}
+	hookval = call_hooks(IPV6_TNL_PRE_ENCAP, t, skb);
+	switch (hookval) {
+	case IPV6_TNL_ACCEPT:
+		break;
+	case IPV6_TNL_STOLEN:
+		goto ignore_packet;
+	default:
+		if (hookval != IPV6_TNL_DROP) {
+			printk(KERN_ERR
+			       "%s: Unknown return value for tunnel hook!\n",
+			       t->parms.name);
+		}
+		goto drop_packet;
+	}
+	if ((err = ipv6_xmit_lock()))
+		goto tx_err;
+
+	memcpy(&fl, &t->fl, sizeof (fl));
+
+	if (fl.fl6_flowlabel) {
+		fl_lbl = fl6_sock_lookup(sk, fl.fl6_flowlabel);
+		if (fl_lbl)
+			orig_opt = fl_lbl->opt;
+	}
+	if ((t->parms.flags & IPV6_TNL_F_USE_ORIG_TCLASS)) {
+		fl.fl6_flowlabel |= (*(__u32 *) ipv6h &
+				     IPV6_FLOWINFO_MASK & ~IPV6_FLOWLABEL_MASK);
+	}
+	if (encap_limit > 0) {
+		if (!(opt = merge_options(sk, encap_limit, orig_opt))) {
+			goto tx_err_free_fl_lbl;
+		}
+	} else {
+		opt = orig_opt;
+	}
+	dst = ip6_route_output(sk, &fl);
+
+	if (dst->error) {
+		stats->tx_carrier_errors++;
+		link_failure = 1;
+		goto tx_err_dst_release;
+	}
+	tdev = dst->dev;
+
+	/* local routing loop */
+	if (tdev == dev) {
+		stats->collisions++;
+		printk(KERN_ERR "%s: Local routing loop detected!\n",
+		       t->parms.name);
+		goto tx_err_dst_release;
+	}
+	mtu = dst->pmtu - sizeof (*ipv6h);
+	if (opt) {
+		mtu -= (opt->opt_nflen + opt->opt_flen);
+	}
+	if (mtu < IPV6_MIN_MTU)
+		mtu = IPV6_MIN_MTU;
+	if (skb->dst && mtu < skb->dst->pmtu) {
+		struct rt6_info *rt6 = (struct rt6_info *) skb->dst;
+		rt6->rt6i_flags |= RTF_MODIFIED;
+		rt6->u.dst.pmtu = mtu;
+	}
+	if (skb->len > mtu) {
+		icmpv6_send(skb, ICMPV6_PKT_TOOBIG, 0, mtu, dev);
+		goto tx_err_dst_release;
+	}
+	err = ip6_build_xmit(sk, ipv6_ipv6_getfrag, (void *) skb->nh.raw,
+			     &fl, skb->len, opt, t->parms.hop_limit,
+			     MSG_DONTWAIT);
+
+	if (err == NET_XMIT_SUCCESS || err == NET_XMIT_CN) {
+		stats->tx_bytes += skb->len;
+		stats->tx_packets++;
+	} else {
+		stats->tx_errors++;
+		stats->tx_aborted_errors++;
+	}
+	dst_release(dst);
+	if (opt && opt != orig_opt)
+		sock_kfree_s(sk, opt, opt->tot_len);
+	fl6_sock_release(fl_lbl);
+	ipv6_xmit_unlock();
+	kfree_skb(skb);
+	t->recursion--;
+	return 0;
+      tx_err_dst_release:
+	dst_release(dst);
+	if (opt && opt != orig_opt)
+		sock_kfree_s(sk, opt, opt->tot_len);
+      tx_err_free_fl_lbl:
+	fl6_sock_release(fl_lbl);
+	ipv6_xmit_unlock();
+	if (link_failure)
+		dst_link_failure(skb);
+      tx_err:
+	stats->tx_errors++;
+      drop_packet:
+	stats->tx_dropped++;
+	kfree_skb(skb);
+      ignore_packet:
+	t->recursion--;
+	return 0;
+}
+
+struct ipv6_tnl_link_parm {
+	int iflink;
+	unsigned short hard_header_len;
+	unsigned mtu;
+};
+
+static int
+ipv6_ipv6_tnl_link_parm_get(struct ipv6_tnl_parm *p,
+			    int active, struct ipv6_tnl_link_parm *lp)
+{
+	int err = 0;
+
+	if (active) {
+		struct rt6_info *rt = rt6_lookup(&p->raddr, &p->laddr,
+						 p->link, 0);
+		struct net_device *rtdev;
+		if (!rt) {
+			err = -ENOENT;
+		} else if ((rtdev = rt->rt6i_dev) == NULL) {
+			err = -ENODEV;
+		} else if (rtdev->type == ARPHRD_IPV6_IPV6_TUNNEL) {
+			/* as long as all tunnels use the same socket 
+			   (ipv6_socket) for transmission (locally) 
+			   nested tunnels won't work */
+			err = -ENOMEDIUM;
+		} else {
+			lp->iflink = rtdev->ifindex;
+			lp->hard_header_len = rtdev->hard_header_len +
+			    sizeof (struct ipv6hdr);
+			lp->mtu = rtdev->mtu - sizeof (struct ipv6hdr);
+
+			if (lp->mtu < IPV6_MIN_MTU)
+				lp->mtu = IPV6_MIN_MTU;
+		}
+		if (rt) {
+			dst_release(&rt->u.dst);
+		}
+	} else {
+		lp->iflink = 0;
+		lp->hard_header_len = LL_MAX_HEADER + sizeof (struct ipv6hdr);
+		lp->mtu = ETH_DATA_LEN - sizeof (struct ipv6hdr);
+	}
+	return err;
+}
+
+static void
+ipv6_ipv6_tnl_dev_config(struct net_device *dev, struct ipv6_tnl_link_parm *lp)
+{
+	struct ipv6_tnl *t = (struct ipv6_tnl *) dev->priv;
+	struct flowi *fl;
+
+	IPV6_TNL_TRACE();
+
+	/* Set up flowi template */
+	fl = &t->fl;
+	fl->fl6_src = &t->parms.laddr;
+	fl->fl6_dst = &t->parms.raddr;
+	fl->oif = t->parms.link;
+	fl->fl6_flowlabel = IPV6_FLOWLABEL_MASK & htonl(t->parms.flow_lbl);
+
+	dev->iflink = lp->iflink;
+	dev->hard_header_len = lp->hard_header_len;
+	dev->mtu = lp->mtu;
+}
+
+/**
+ * ipv6_ipv6_tnl_change - update the tunnel parameters
+ *   @t: tunnel to be changed
+ *   @p: tunnel configuration parameters
+ *   @active: != 0 if tunnel is ready for use
+ *
+ * Description:
+ *   ipv6_ipv6_tnl_change() updates the tunnel parameters
+ **/
+
+static int
+ipv6_ipv6_tnl_change(struct ipv6_tnl *t, struct ipv6_tnl_parm *p, int active)
+{
+	struct net_device *dev = t->dev;
+	int laddr_uc = (ipv6_addr_type(&p->laddr) & IPV6_ADDR_UNICAST);
+	int raddr_uc = (ipv6_addr_type(&p->raddr) & IPV6_ADDR_UNICAST);
+	int err;
+	struct ipv6_tnl_link_parm lp;
+
+	IPV6_TNL_TRACE();
+
+	if ((err = ipv6_ipv6_tnl_link_parm_get(p, active, &lp)))
+		return err;
+
+	if (laddr_uc && raddr_uc) {
+		dev->flags |= IFF_POINTOPOINT;
+	} else {
+		dev->flags &= ~IFF_POINTOPOINT;
+	}
+	ipv6_addr_copy(&t->parms.laddr, &p->laddr);
+	ipv6_addr_copy(&t->parms.raddr, &p->raddr);
+	t->parms.flags = p->flags;
+
+	if (active) {
+		/* Only allow xmit if the tunnel is configured 
+		   with a valid unicast source address */
+		if (laddr_uc) {
+			t->parms.flags &= ~IPV6_TNL_F_RCV_ONLY;
+		} else {
+			t->parms.flags |= IPV6_TNL_F_RCV_ONLY;
+		}
+	}
+	t->parms.hop_limit = (p->hop_limit <= 255 ? p->hop_limit : -1);
+	t->parms.encap_limit = p->encap_limit;
+	t->parms.flow_lbl = p->flow_lbl;
+
+	ipv6_ipv6_tnl_dev_config(dev, &lp);
+	return 0;
+}
+
+static inline int
+ipv6_tnl_flag_cmp(__u32 f1, __u32 f2)
+{
+	return ((f1 & ~IPV6_TNL_F_RCV_ONLY) != (f2 & ~IPV6_TNL_F_RCV_ONLY));
+}
+
+/**
+ * ipv6_ipv6_kernel_tnl_add - configure and add kernel tunnel to hash 
+ *   @p: kernel tunnel configuration parameters
+ *
+ * Description:
+ *   ipv6_ipv6_kernel_tnl_add() fetches an unused kernel tunnel configures
+ *   it according to @p and places it among the active tunnels.
+ * 
+ * Return:
+ *   number of references to tunnel on success,
+ *   %-EEXIST if there is already a device matching description
+ *   %-EINVAL if p->flags doesn't have %IPV6_TNL_F_KERNEL_DEV raised,
+ *   %-ENODEV if there are no unused kernel tunnels available 
+ * 
+ * Note:
+ *   The code for creating, opening, closing and destroying network devices
+ *   must be called from process context, while the Mobile IP code, which 
+ *   needs the tunnel devices, unfortunately runs in interrupt context. 
+ *   
+ *   The devices must be created and opened in advance, then placed in a 
+ *   list where the kernel can fetch and ready them for use at a later time.
+ *
+ **/
+
+int
+ipv6_ipv6_kernel_tnl_add(struct ipv6_tnl_parm *p)
+{
+	struct ipv6_tnl *t;
+	int err;
+
+	IPV6_TNL_TRACE();
+
+	if (!(p->flags & IPV6_TNL_F_KERNEL_DEV) ||
+	    !ipv6_tnl_addrs_sane(&p->laddr, &p->raddr))
+		return -EINVAL;
+	if ((t = ipv6_ipv6_tnl_lookup(&p->raddr, &p->laddr)) != NULL &&
+	    t != &ipv6_ipv6_fb_tnl) {
+		if (ipv6_tnl_flag_cmp(p->flags, t->parms.flags)) {
+			/* Incompatible tunnel already exists for endpoints */
+			return -EEXIST;
+		} else {
+			/* Handle duplicate tunnels by incrementing 
+			   reference count */
+			atomic_inc(&t->refcnt);
+			goto out;
+		}
+	}
+	if ((t = ipv6_ipv6_kernel_tnl_unlink()) == NULL)
+		return -ENODEV;
+	if ((err = ipv6_ipv6_tnl_change(t, p, 1))) {
+		ipv6_ipv6_kernel_tnl_link(t);
+		return err;
+	}
+	atomic_inc(&t->refcnt);
+
+	ipv6_ipv6_tnl_link(t);
+
+	manage_kernel_tnls(NULL);
+      out:
+	return atomic_read(&t->refcnt);
+}
+
+/**
+ * ipv6_ipv6_kernel_tnl_del - delete no longer needed kernel tunnel 
+ *   @t: kernel tunnel to be removed from hash
+ *
+ * Description:
+ *   ipv6_ipv6_kernel_tnl_del() removes and deconfigures the tunnel @t
+ *   and places it among the unused kernel devices.
+ * 
+ * Return:
+ *   number of references on success,
+ *   %-EINVAL if p->flags doesn't have %IPV6_TNL_F_KERNEL_DEV raised,
+ * 
+ * Note:
+ *   See the comments on ipv6_ipv6_kernel_tnl_add() for more information.
+ **/
+
+int
+ipv6_ipv6_kernel_tnl_del(struct ipv6_tnl *t)
+{
+	IPV6_TNL_TRACE();
+
+	if (!t)
+		return -ENODEV;
+
+	if (!(t->parms.flags & IPV6_TNL_F_KERNEL_DEV))
+		return -EINVAL;
+
+	if (atomic_dec_and_test(&t->refcnt)) {
+		struct ipv6_tnl_parm p;
+		ipv6_ipv6_tnl_unlink(t);
+		memset(&p, 0, sizeof (p));
+		p.flags = IPV6_TNL_F_KERNEL_DEV;
+
+		ipv6_ipv6_tnl_change(t, &p, 0);
+
+		ipv6_ipv6_kernel_tnl_link(t);
+
+		manage_kernel_tnls(NULL);
+	}
+	return atomic_read(&t->refcnt);
+}
+
+/**
+ * ipv6_ipv6_tnl_ioctl - configure ipv6 tunnels from userspace 
+ *   @dev: virtual device associated with tunnel
+ *   @ifr: parameters passed from userspace
+ *   @cmd: command to be performed
+ *
+ * Description:
+ *   ipv6_ipv6_tnl_ioctl() is used for managing IPv6 tunnels 
+ *   from userspace. 
+ *
+ *   The possible commands are the following:
+ *     %SIOCGETTUNNEL: get tunnel parameters for device
+ *     %SIOCADDTUNNEL: add tunnel matching given tunnel parameters
+ *     %SIOCCHGTUNNEL: change tunnel parameters to those given
+ *     %SIOCDELTUNNEL: delete tunnel
+ *
+ *   The fallback device "ip6tnl0", created during module 
+ *   initialization, can be used for creating other tunnel devices.
+ *
+ * Return:
+ *   0 on success,
+ *   %-EFAULT if unable to copy data to or from userspace,
+ *   %-EPERM if current process hasn't %CAP_NET_ADMIN set or attempting
+ *   to configure kernel devices from userspace, 
+ *   %-EINVAL if passed tunnel parameters are invalid,
+ *   %-EEXIST if changing a tunnel's parameters would cause a conflict
+ *   %-ENODEV if attempting to change or delete a nonexisting device
+ *
+ * Note:
+ *   See the comments on ipv6_ipv6_kernel_tnl_add() for more information 
+ *   about kernel tunnels.
+ * **/
+
+static int
+ipv6_ipv6_tnl_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
+{
+	int err = 0;
+	int create;
+	struct ipv6_tnl_parm p;
+	struct ipv6_tnl *t = NULL;
+
+	IPV6_TNL_TRACE();
+
+	MOD_INC_USE_COUNT;
+
+	switch (cmd) {
+	case SIOCGETTUNNEL:
+		if (dev == &ipv6_ipv6_fb_tnl_dev) {
+			if (copy_from_user(&p,
+					   ifr->ifr_ifru.ifru_data,
+					   sizeof (p))) {
+				err = -EFAULT;
+				break;
+			}
+			if ((err = ipv6_ipv6_tnl_locate(&p, &t, 0)) == -ENODEV)
+				t = (struct ipv6_tnl *) dev->priv;
+			else if (err)
+				break;
+		} else
+			t = (struct ipv6_tnl *) dev->priv;
+
+		memcpy(&p, &t->parms, sizeof (p));
+		if (copy_to_user(ifr->ifr_ifru.ifru_data, &p, sizeof (p))) {
+			err = -EFAULT;
+		}
+		break;
+	case SIOCADDTUNNEL:
+	case SIOCCHGTUNNEL:
+		err = -EPERM;
+		create = (cmd == SIOCADDTUNNEL);
+		if (!capable(CAP_NET_ADMIN))
+			break;
+		if (copy_from_user(&p, ifr->ifr_ifru.ifru_data, sizeof (p))) {
+			err = -EFAULT;
+			break;
+		}
+		if (p.flags & IPV6_TNL_F_KERNEL_DEV) {
+			break;
+		}
+		if (!create && dev != &ipv6_ipv6_fb_tnl_dev) {
+			t = (struct ipv6_tnl *) dev->priv;
+		}
+		if (!t && (err = ipv6_ipv6_tnl_locate(&p, &t, create))) {
+			break;
+		}
+		if (cmd == SIOCCHGTUNNEL) {
+			if (t->dev != dev) {
+				err = -EEXIST;
+				break;
+			}
+			if (t->parms.flags & IPV6_TNL_F_KERNEL_DEV) {
+				err = -EPERM;
+				break;
+			}
+			ipv6_ipv6_tnl_unlink(t);
+			err = ipv6_ipv6_tnl_change(t, &p, 1);
+			ipv6_ipv6_tnl_link(t);
+			netdev_state_change(dev);
+		}
+		if (copy_to_user(ifr->ifr_ifru.ifru_data,
+				 &t->parms, sizeof (p))) {
+			err = -EFAULT;
+		} else {
+			err = 0;
+		}
+		break;
+	case SIOCDELTUNNEL:
+		err = -EPERM;
+		if (!capable(CAP_NET_ADMIN))
+			break;
+
+		if (dev == &ipv6_ipv6_fb_tnl_dev) {
+			if (copy_from_user(&p, ifr->ifr_ifru.ifru_data,
+					   sizeof (p))) {
+				err = -EFAULT;
+				break;
+			}
+			err = ipv6_ipv6_tnl_locate(&p, &t, 0);
+			if (err)
+				break;
+			if (t == &ipv6_ipv6_fb_tnl) {
+				err = -EPERM;
+				break;
+			}
+		} else {
+			t = (struct ipv6_tnl *) dev->priv;
+		}
+		if (t->parms.flags & IPV6_TNL_F_KERNEL_DEV)
+			err = -EPERM;
+		else
+			err = ipv6_tnl_destroy(t);
+		break;
+	default:
+		err = -EINVAL;
+	}
+	MOD_DEC_USE_COUNT;
+	return err;
+}
+
+/**
+ * ipv6_ipv6_tnl_get_stats - return the stats for tunnel device 
+ *   @dev: virtual device associated with tunnel
+ *
+ * Return: stats for device
+ **/
+
+static struct net_device_stats *
+ipv6_ipv6_tnl_get_stats(struct net_device *dev)
+{
+	IPV6_TNL_TRACE();
+
+	return &(((struct ipv6_tnl *) dev->priv)->stat);
+}
+
+/**
+ * ipv6_ipv6_tnl_change_mtu - change mtu manually for tunnel device
+ *   @dev: virtual device associated with tunnel
+ *   @new_mtu: the new mtu
+ *
+ * Return:
+ *   0 on success,
+ *   %-EINVAL if mtu too small
+ **/
+
+static int
+ipv6_ipv6_tnl_change_mtu(struct net_device *dev, int new_mtu)
+{
+	IPV6_TNL_TRACE();
+
+	if (new_mtu < IPV6_MIN_MTU) {
+		return -EINVAL;
+	}
+	dev->mtu = new_mtu;
+	return 0;
+}
+
+/**
+ * ipv6_ipv6_tnl_dev_init_gen - general initializer for all tunnel devices
+ *   @dev: virtual device associated with tunnel
+ *
+ * Description:
+ *   Set function pointers and initialize the &struct flowi template used
+ *   by the tunnel.
+ **/
+
+static void
+ipv6_ipv6_tnl_dev_init_gen(struct net_device *dev)
+{
+	struct ipv6_tnl *t = (struct ipv6_tnl *) dev->priv;
+	struct flowi *fl = &t->fl;
+
+	IPV6_TNL_TRACE();
+
+	memset(fl, 0, sizeof (*fl));
+	fl->proto = IPPROTO_IPV6;
+
+	dev->destructor = ipv6_ipv6_tnl_dev_destructor;
+	dev->uninit = ipv6_ipv6_tnl_dev_uninit;
+	dev->hard_start_xmit = ipv6_ipv6_tnl_xmit;
+	dev->get_stats = ipv6_ipv6_tnl_get_stats;
+	dev->do_ioctl = ipv6_ipv6_tnl_ioctl;
+	dev->change_mtu = ipv6_ipv6_tnl_change_mtu;
+	dev->type = ARPHRD_IPV6_IPV6_TUNNEL;
+	dev->flags |= IFF_NOARP;
+	if (ipv6_addr_type(&t->parms.raddr) & IPV6_ADDR_UNICAST)
+		dev->flags |= IFF_POINTOPOINT;
+	dev->iflink = 0;
+	/* Hmm... MAX_ADDR_LEN is 8, so the ipv6 addresses can't be 
+	   copied to dev->dev_addr and dev->broadcast, like the ipv4
+	   addresses were in ipip.c, ip_gre.c and sit.c. */
+	dev->addr_len = 0;
+}
+
+/**
+ * ipv6_ipv6_tnl_dev_init - initializer for all non fallback tunnel devices
+ *   @dev: virtual device associated with tunnel
+ **/
+
+static int
+ipv6_ipv6_tnl_dev_init(struct net_device *dev)
+{
+	struct ipv6_tnl *t = (struct ipv6_tnl *) dev->priv;
+	int active = !(t->parms.flags & IPV6_TNL_F_KERNEL_DEV);
+	struct ipv6_tnl_link_parm lp;
+	int err;
+
+	IPV6_TNL_TRACE();
+
+	if ((err = ipv6_ipv6_tnl_link_parm_get(&t->parms, active, &lp))) {
+		return err;
+	}
+	ipv6_ipv6_tnl_dev_init_gen(dev);
+	ipv6_ipv6_tnl_dev_config(dev, &lp);
+	return 0;
+}
+
+#ifdef MODULE
+
+/**
+ * ipv6_ipv6_fb_tnl_open - function called when fallback device opened
+ *   @dev: fallback device
+ *
+ * Return: 0 
+ **/
+
+static int
+ipv6_ipv6_fb_tnl_open(struct net_device *dev)
+{
+	IPV6_TNL_TRACE();
+
+	MOD_INC_USE_COUNT;
+	return 0;
+}
+
+/**
+ * ipv6_ipv6_fb_tnl_close - function called when fallback device closed
+ *   @dev: fallback device
+ *
+ * Return: 0 
+ **/
+
+static int
+ipv6_ipv6_fb_tnl_close(struct net_device *dev)
+{
+	IPV6_TNL_TRACE();
+
+	MOD_DEC_USE_COUNT;
+	return 0;
+}
+#endif
+
+/**
+ * ipv6_ipv6_fb_tnl_dev_init - initializer for fallback tunnel device
+ *   @dev: fallback device
+ *
+ * Return: 0
+ **/
+
+int __init
+ipv6_ipv6_fb_tnl_dev_init(struct net_device *dev)
+{
+	IPV6_TNL_TRACE();
+
+	ipv6_ipv6_tnl_dev_init_gen(dev);
+#ifdef MODULE
+	dev->open = ipv6_ipv6_fb_tnl_open;
+	dev->stop = ipv6_ipv6_fb_tnl_close;
+#endif
+	tnls_wc[0] = &ipv6_ipv6_fb_tnl;
+	return 0;
+}
+
+/**
+ * ipv6_ipv6_tnl_register_hook - add hook for processing of tunneled packets
+ *   @reg: hook function and its parameters
+ * 
+ * Description:
+ *   Add a netfilter like hook function for special handling of tunneled 
+ *   packets. The hook functions are called before encapsulation 
+ *   (%IPV6_TNL_PRE_ENCAP) and before decapsulation 
+ *   (%IPV6_TNL_PRE_DECAP). The possible return values by the hook 
+ *   functions are %IPV6_TNL_DROP, %IPV6_TNL_ACCEPT and 
+ *   %IPV6_TNL_STOLEN (in case the hook function took care of the packet
+ *   and it doesn't have to be processed any further).
+ **/
+
+void
+ipv6_ipv6_tnl_register_hook(struct ipv6_tnl_hook_ops *reg)
+{
+	IPV6_TNL_TRACE();
+
+	if (reg->hooknum < IPV6_TNL_MAXHOOKS) {
+		struct list_head *i;
+
+		write_lock_bh(&ipv6_ipv6_hook_lock);
+		for (i = hooks[reg->hooknum].next;
+		     i != &hooks[reg->hooknum]; i = i->next) {
+			if (reg->priority <
+			    ((struct ipv6_tnl_hook_ops *) i)->priority) {
+				break;
+			}
+		}
+		list_add(&reg->list, i->prev);
+		write_unlock_bh(&ipv6_ipv6_hook_lock);
+	}
+}
+
+/**
+ * ipv6_ipv6_tnl_unregister_hook - remove tunnel hook
+ *   @reg: hook function and its parameters
+ **/
+
+void
+ipv6_ipv6_tnl_unregister_hook(struct ipv6_tnl_hook_ops *reg)
+{
+	IPV6_TNL_TRACE();
+
+	if (reg->hooknum < IPV6_TNL_MAXHOOKS) {
+		write_lock_bh(&ipv6_ipv6_hook_lock);
+		list_del(&reg->list);
+		write_unlock_bh(&ipv6_ipv6_hook_lock);
+	}
+}
+
+/* the IPv6 over IPv6 protocol structure */
+static struct inet6_protocol ipv6_ipv6_protocol = {
+	ipv6_ipv6_rcv,		/* IPv6 handler         */
+	ipv6_ipv6_err,		/* IPv6 error control   */
+	NULL,			/* next                 */
+	IPPROTO_IPV6,		/* protocol ID          */
+	0,			/* copy                 */
+	NULL,			/* data                 */
+	"IPv6 over IPv6"	/* name                 */
+};
+
+/**
+ * ipv6_ipv6_tnl_init - register protocol and reserve needed resources
+ *
+ * Return: 0 on success
+ **/
+
+int __init
+ipv6_ipv6_tnl_init(void)
+{
+	int i, err;
+	struct sock *sk;
+
+	IPV6_TNL_TRACE();
+
+	ipv6_ipv6_fb_tnl_dev.priv = (void *) &ipv6_ipv6_fb_tnl;
+	err = sock_create(PF_INET6, SOCK_RAW, IPPROTO_IPV6, &ipv6_socket);
+	if (err < 0) {
+		printk(KERN_ERR "Failed to create the IPv6 tunnel socket.\n");
+		return err;
+	}
+	sk = ipv6_socket->sk;
+	sk->allocation = GFP_ATOMIC;
+	sk->net_pinfo.af_inet6.hop_limit = 254;
+	sk->net_pinfo.af_inet6.mc_loop = 0;
+	sk->prot->unhash(sk);
+
+	for (i = 0; i < IPV6_TNL_MAXHOOKS; i++) {
+		INIT_LIST_HEAD(&hooks[i]);
+	}
+	register_netdev(&ipv6_ipv6_fb_tnl_dev);
+	inet6_add_protocol(&ipv6_ipv6_protocol);
+	return 0;
+}
+
+/**
+ * ipv6_ipv6_tnl_exit - free resources and unregister protocol
+ **/
+
+void __exit
+ipv6_ipv6_tnl_exit(void)
+{
+	IPV6_TNL_TRACE();
+
+	write_lock_bh(&ipv6_ipv6_kernel_lock);
+	shutdown = 1;
+	write_unlock_bh(&ipv6_ipv6_kernel_lock);
+	flush_scheduled_tasks();
+	manage_kernel_tnls(NULL);
+	inet6_del_protocol(&ipv6_ipv6_protocol);
+	unregister_netdev(&ipv6_ipv6_fb_tnl_dev);
+	sock_release(ipv6_socket);
+}
+
+#ifdef MODULE
+module_init(ipv6_ipv6_tnl_init);
+module_exit(ipv6_ipv6_tnl_exit);
+#endif
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mipglue.c linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mipglue.c
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mipglue.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mipglue.c	2003-05-18 11:33:53.000000000 +0200
@@ -0,0 +1,80 @@
+/*
+ *	Glue for Mobility support integration to IPv6
+ *
+ *	Authors:
+ *	Antti Tuominen		<ajtuomin@cc.hut.fi>	
+ *
+ *	$Id: s.mipglue.c 1.6 02/09/23 18:27:48+03:00 antti@jon.mipl.mediapoli.com $
+ *
+ *	This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/sched.h>
+
+#include <net/ipv6.h>
+#include <net/addrconf.h>
+#include <net/neighbour.h>
+#include <net/mipglue.h>
+
+extern int ip6_tlvopt_unknown(struct sk_buff *skb, int optoff);
+
+/*  Initialize all zero  */
+struct mipv6_callable_functions mipv6_functions = { NULL };
+
+/* Sets mipv6_functions struct to zero to invalidate all successive
+ * calls to mipv6 functions. Used on module unload. */
+
+void mipv6_invalidate_calls(void)
+{
+	memset(&mipv6_functions, 0, sizeof(mipv6_functions));
+}
+
+
+/* Selects correct handler for tlv encoded destination option. Called
+ * by ip6_parse_tlv. Checks if mipv6 calls are valid before calling. */
+
+int mipv6_handle_dstopt(struct sk_buff *skb, int optoff)
+{
+	int ret;
+
+        switch (skb->nh.raw[optoff]) {
+	case MIPV6_TLV_HOMEADDR: 
+		ret = MIPV6_CALLFUNC(mipv6_handle_homeaddr, 0)(skb, optoff);
+		break;
+	default:
+		/* Should never happen */
+		printk(KERN_ERR __FILE__ ": Invalid destination option code (%d)\n",
+		       skb->nh.raw[optoff]);
+		ret = 1;
+		break;
+	}
+
+	/* If mipv6 handlers are not valid, pass the packet to
+         * ip6_tlvopt_unknown() for correct handling. */
+	if (!ret)
+		return ip6_tlvopt_unknown(skb, optoff);
+
+	return ret;
+}
+
+
+/*
+ * Misuse DAD to find out L2 address of the HA when the MN is returning home
+ */
+
+int ndisc_mipv6_mn_solicit_ha(struct net_device *dev, struct in6_addr *target) 
+{
+
+	int ret;
+	if ((ret = ndisc_mipv6_mn_may_solicit_ha(target))) {
+		struct in6_addr unspec, mcaddr;
+		memset(&unspec, 0, sizeof(unspec));
+		addrconf_addr_solict_mult(target, &mcaddr);
+		ndisc_send_ns(dev, NULL, target, &mcaddr, &unspec);
+	}
+	return ret;
+}
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/Config.in linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/Config.in
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/Config.in	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/Config.in	2003-05-18 11:33:53.000000000 +0200
@@ -0,0 +1,15 @@
+#
+# Mobile IPv6 Configuration
+#
+dep_tristate '    IPv6: Mobility Support (Correspondent Node)' CONFIG_IPV6_MOBILITY $CONFIG_IPV6
+if [ "$CONFIG_IPV6_IPV6_TUNNEL" != "n" ]; then
+   if [ "$CONFIG_IPV6_MOBILITY" != "n" ]; then
+      if [ "$CONFIG_IPV6_MOBILITY_HA" != "y" ]; then
+         bool '      MIPv6: Mobile Node Support' CONFIG_IPV6_MOBILITY_MN 
+      fi
+      if [ "$CONFIG_IPV6_MOBILITY_MN" != "y" ]; then
+         bool '      MIPv6: Home Agent Support' CONFIG_IPV6_MOBILITY_HA
+      fi
+      bool '      MIPv6: Debug messages' CONFIG_IPV6_MOBILITY_DEBUG
+   fi
+fi
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/Makefile linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/Makefile
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/Makefile	2003-05-18 11:33:53.000000000 +0200
@@ -0,0 +1,34 @@
+#
+# Makefile for the MIPL Mobile IPv6 for Linux.
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+
+
+O_TARGET := mobile_ip6.o
+
+obj-y := hashlist.o util.o bcache.o mobhdr_common.o stats.o \
+	exthdrs.o rr_crypto.o hmac.o auth_opt.o
+
+ifeq ($(CONFIG_IPV6_MOBILITY_HA),)
+ifeq ($(CONFIG_IPV6_MOBILITY_MN),)
+obj-y += module_cn.o
+endif
+endif
+
+ifeq ($(CONFIG_IPV6_MOBILITY_HA),y)
+obj-y += tunnel.o halist.o mipv6_icmp.o mipv6_icmp_ha.o \
+	sortedlist.o prefix.o prefix_ha.o dad.o ha.o module_ha.o
+endif
+
+ifeq ($(CONFIG_IPV6_MOBILITY_MN),y)
+obj-y += tunnel.o halist.o mipv6_icmp.o mipv6_icmp_mn.o ioctl_mn.o \
+	sortedlist.o prefix.o mdetect.o bul.o multiaccess_ctl.o \
+	mobhdr_mn.o mn.o module_mn.o
+endif
+
+obj-m	:= $(O_TARGET)
+
+include $(TOPDIR)/Rules.make
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/README linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/README
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/README	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/README	2003-05-18 11:33:53.000000000 +0200
@@ -0,0 +1,15 @@
+MIPL Mobile IPv6 for Linux
+
+More information at http://www.mipl.mediapoli.com/.
+
+To join MIPL Mobile IPv6 for Linux mailing lists go to:
+
+	http://www.mipl.mediapoli.com/cgi-bin/mailman/listinfo
+
+Or send mail with subject "subscribe" for the general list to:
+
+	mipl-request@list.mipl.mediapoli.com
+
+or for the developer list to:
+
+	mipl-devel-request@list.mail.mediapoli.com
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/auth_opt.c linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/auth_opt.c
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/auth_opt.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/auth_opt.c	2003-05-18 11:33:53.000000000 +0200
@@ -0,0 +1,122 @@
+/*
+ *	MIPv6 Binding Authentication Data Option functions
+ *	
+ *      Authors: 
+ *      Henrik Petander         <lpetande@tml.hut.fi>
+ * 
+ *      $Id: s.auth_opt.c 1.33 02/12/12 15:48:48-02:00 henkku@mart10.hut.mediapoli.com $
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/autoconf.h>
+#include <linux/icmpv6.h>
+#include <net/mipv6.h>
+
+#include "debug.h"
+#include "util.h"
+#include "hmac.h"
+#include "mobhdr.h"
+
+#define DBG_KEY 5
+
+int mipv6_auth_build(struct in6_addr *cn_addr, struct in6_addr *coa, 
+		     __u8 *mh, __u8 *aud_data, __u8 *k_bu)
+{
+	/* First look up the peer from sadb based on his address */ 
+	struct ah_processing ahp;
+
+	/* Don't add any other options or this system is screwed */
+
+	__u8 buf[MAX_HASH_LENGTH];  
+	
+	
+	if (!k_bu) {
+		DEBUG(DBG_ERROR, "k_bu missing, aborting");
+		return -1;
+	}
+	DEBUG(DBG_KEY, "Key for building authenticator:");
+	debug_print_buffer(DBG_KEY, k_bu, HMAC_SHA1_KEY_SIZE);
+
+	if (ah_hmac_sha1_init(&ahp, k_bu,  HMAC_SHA1_KEY_SIZE) < 0) {
+		DEBUG(DBG_ERROR, "Failed to initialize hmac sha1");
+                return -1; 
+        } 
+
+	DEBUG(DBG_KEY, "coa: ");
+	debug_print_buffer(DBG_KEY, coa, 16);
+	DEBUG(DBG_KEY, "cn_addr: ");
+	debug_print_buffer(DBG_KEY, cn_addr, 16);
+	DEBUG(DBG_KEY, "MH contents: ");
+	debug_print_buffer(DBG_KEY, mh, aud_data - mh);
+
+	/* First the common part */
+	ah_hmac_sha1_loop(&ahp, coa, sizeof(struct in6_addr));
+	ah_hmac_sha1_loop(&ahp, cn_addr, sizeof(struct in6_addr));
+	ah_hmac_sha1_loop(&ahp, mh, aud_data - mh);
+	ah_hmac_sha1_result(&ahp, buf);
+
+	memcpy(aud_data, buf,  MIPV6_RR_MAC_LENGTH);
+
+	return 0;
+}
+
+int mipv6_auth_check(struct in6_addr *cn_addr, struct in6_addr *coa,
+		     __u8 *opt, __u8 optlen, 
+		     struct mipv6_mo_bauth_data *aud, __u8 *k_bu)
+{
+	int ret = -1;
+	struct ah_processing ahp;
+	__u8 htarget[MAX_HASH_LENGTH];
+
+	/* Look up peer by home address */ 
+	if (!k_bu) {
+		DEBUG(DBG_ERROR, "k_bu missing, aborting"); 
+		return -1;
+	}
+
+	DEBUG(DBG_KEY, "Key for checking authenticator:");
+	debug_print_buffer(DBG_KEY, k_bu, HMAC_SHA1_KEY_SIZE);
+
+	if (!aud || !coa) {
+		DEBUG(DBG_INFO, "%s is NULL", aud ? "coa" : "aud");
+		goto out;
+	}
+
+	if (aud->length != MIPV6_RR_MAC_LENGTH) {
+		DEBUG(DBG_ERROR,
+			 ": Incorrect authentication option length %d", aud->length); 
+		goto out; 
+	}
+	
+	if (ah_hmac_sha1_init(&ahp, k_bu, HMAC_SHA1_KEY_SIZE) < 0) { 
+                DEBUG(DBG_ERROR,
+			 "internal error in initialization of authentication algorithm");
+		goto out;
+        } 
+	DEBUG(DBG_KEY, "coa: ");
+	debug_print_buffer(DBG_KEY, coa, 16);
+	DEBUG(DBG_KEY, "cn_addr: ");
+	debug_print_buffer(DBG_KEY, cn_addr, 16);
+	DEBUG(DBG_KEY, "MH contents: ");
+	debug_print_buffer(DBG_KEY, opt, (u8*) aud->data - opt);
+
+	ah_hmac_sha1_loop(&ahp, coa, sizeof(struct in6_addr));
+	ah_hmac_sha1_loop(&ahp, cn_addr, sizeof(struct in6_addr));
+
+	/* 
+	 * Process MH + options till the start of the authenticator in
+	 * Auth. data option
+	 */
+	ah_hmac_sha1_loop(&ahp, opt,  (u8 *)aud->data - opt);
+	ah_hmac_sha1_result(&ahp, htarget);
+	if (memcmp(htarget, aud->data, MIPV6_RR_MAC_LENGTH) == 0)
+		ret = 0;
+
+	DEBUG(DBG_ERROR, "returning %d", ret);
+out:	
+	return ret;
+}
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/bcache.c linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/bcache.c
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/bcache.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/bcache.c	2003-05-18 11:33:53.000000000 +0200
@@ -0,0 +1,914 @@
+/*
+ *      Binding Cache
+ *
+ *      Authors:
+ *      Juha Mynttinen            <jmynttin@cc.hut.fi>
+ *
+ *      $Id: s.bcache.c 1.68 02/12/19 13:57:09+02:00 vnuorval@dsl-hkigw1d8c.dial.inet.fi $
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ */
+
+/*
+ *	Changes:
+ *
+ *	Nanno Langstraat	:	Timer code cleaned up, active socket
+ *					test rewritten
+ */
+
+#include <linux/autoconf.h>
+#include <linux/sched.h>
+#include <linux/timer.h>
+#include <linux/in6.h>
+#include <linux/init.h>
+#include <linux/spinlock.h>
+#include <linux/proc_fs.h>
+#include <net/ipv6.h>
+#include <net/addrconf.h>
+#include <net/tcp.h>
+#include <net/udp.h>
+#include <net/mipv6.h>
+
+#include "bcache.h"
+#include "hashlist.h"
+#include "debug.h"
+#include "mobhdr.h"
+#include "util.h"
+#include "tunnel.h"
+#include "ha.h"
+
+#define TIMERDELAY HZ/10
+
+struct mipv6_bcache {
+	struct hashlist *entries;
+	__u32 size;
+	struct timer_list callback_timer;
+};
+
+static rwlock_t bcache_lock = RW_LOCK_UNLOCKED;
+
+static struct mipv6_bcache bcache;
+
+static int bcache_proc_info(char *buffer, char **start, off_t offset,
+			    int length);
+
+static void set_timer(void);
+
+
+#define MIPV6_BCACHE_HASHSIZE  32
+
+/* Moment of transmission of a BR, in seconds before bcache entry expiry */
+#define BCACHE_BR_SEND_LEAD  3
+
+/* No BR is sent if the bcache entry hasn't been used in the last
+ * BCACHE_BR_SEND_THRESHOLD seconds before expiry */
+#define BCACHE_BR_SEND_THRESHOLD  10
+
+/* 
+ * Internal functions.
+ *
+ * Assume that synchronization is taken care by the callers of these
+ * functions, in the top level of the module. This is to avoid
+ * deadlocks, when called function tries to get the same lock with the
+ * caller.
+ */
+
+/*
+ * Callback for hashlist_iterate
+ */
+
+struct cache_entry_iterator_args {
+	struct mipv6_bcache_entry **entry;
+};
+
+static int find_first_cache_entry_iterator(void *data, void *args,
+					   unsigned long *lifetime)
+{
+	struct mipv6_bcache_entry *entry =
+	    (struct mipv6_bcache_entry *) data;
+	struct cache_entry_iterator_args *state =
+	    (struct cache_entry_iterator_args *) args;
+
+	if (entry == NULL) {
+		DEBUG(DBG_ERROR, "iterator called with NULL argument");
+		return ITERATOR_ERR;	/* continue iteration ?? */
+	}
+
+	if (entry->type == CACHE_ENTRY) {
+		*(state->entry) = entry;
+		return ITERATOR_STOP;	/* stop iteration */
+	} else {
+		return ITERATOR_CONT;	/* continue iteration */
+	}
+}
+
+
+/* 
+ * Get memory for a new bcache entry.  If bcache is full, a cache
+ * entry may be deleted to get space for a home registration, but not
+ * vice versa.
+ */
+static struct mipv6_bcache_entry *mipv6_bcache_get_entry(__u8 type)
+{
+	struct mipv6_bcache_entry *entry;
+	struct cache_entry_iterator_args args;
+
+	DEBUG_FUNC();
+
+	entry = (struct mipv6_bcache_entry *)
+		hashlist_alloc(bcache.entries, SLAB_ATOMIC);
+
+	/* Different cache replacement policies for HOME_REGISTRATION
+           and CACHE_ENTRY could be implemented here, but for now we
+           always replace the CACHE_ENTRY closest to expiration.  Type
+           HOME_REGISTRATION entry may never be deleted before
+           expiration. */
+	if (entry == NULL) {
+		/* cache full, try to delete a CACHE_ENTRY */
+		args.entry = &entry;
+		hashlist_iterate(bcache.entries, &args,
+				 find_first_cache_entry_iterator);
+		if (entry == NULL)
+			return NULL;
+		hashlist_delete(bcache.entries,
+				(struct hashlist_entry *)entry);
+		entry = (struct mipv6_bcache_entry *)
+			hashlist_alloc(bcache.entries, SLAB_ATOMIC);
+	}
+	return entry;
+}
+
+/*
+ * Frees entry's memory allocated with mipv6_bcache_get_entry
+ */
+static void mipv6_bcache_entry_free(struct mipv6_bcache_entry *entry)
+{
+	hashlist_free(bcache.entries, (void *) entry);
+}
+
+static int is_valid_type(__u8 type)
+{
+	if (type != CACHE_ENTRY && type != HOME_REGISTRATION)
+		return 0;
+	else
+		return 1;
+}
+
+/*
+ * Removes all expired entries 
+ */
+static void expire(void)
+{
+	struct mipv6_bcache_entry *entry;
+	unsigned long now = jiffies;
+	struct br_addrs {
+		struct in6_addr daddr;
+		struct in6_addr saddr;
+		struct br_addrs *next;
+	};
+	struct br_addrs *br_info = NULL;
+
+	DEBUG_FUNC();
+
+	write_lock(&bcache_lock);
+
+	while ((entry = (struct mipv6_bcache_entry *)
+		hashlist_get_first(bcache.entries)) != NULL) {
+		if (entry->callback_time <= now) {
+			DEBUG(DBG_INFO, "an entry expired");
+
+			if (entry->type & HOME_REGISTRATION) {
+				del_proxy(&entry->home_addr, entry);
+			}
+			hashlist_delete(bcache.entries, (void *)entry);
+			mipv6_bcache_entry_free(entry);
+			entry = NULL;
+		} else if (entry->br_callback_time != 0 &&
+			   entry->br_callback_time <= now &&
+			   entry->type & !HOME_REGISTRATION) {
+			if (now - entry->last_used <
+			    BCACHE_BR_SEND_THRESHOLD * HZ) {
+				struct br_addrs *tmp;
+
+				tmp = br_info;
+				DEBUG(DBG_INFO,
+				      "bcache entry recently used. Sending BR.");
+				/* queue for sending */
+				br_info =
+				    kmalloc(sizeof(struct br_addrs),
+					    GFP_ATOMIC);
+				if (br_info) {
+					ipv6_addr_copy(&br_info->saddr,
+						       &entry->our_addr);
+					ipv6_addr_copy(&br_info->daddr,
+						       &entry->home_addr);
+					br_info->next = tmp;
+					entry->last_br = now;
+				} else {
+					br_info = tmp;
+					DEBUG(DBG_ERROR, "Out of memory");
+				}
+			}
+			entry->br_callback_time = 0;
+		} else {
+			break;
+		}
+	}
+	write_unlock(&bcache_lock);
+
+	while (br_info) {
+		struct br_addrs *tmp = br_info->next;
+		if (mipv6_send_brr(&br_info->saddr, &br_info->daddr, 0, NULL) < 0)
+			DEBUG(DBG_WARNING,
+			      "BR send for %x:%x:%x:%x:%x:%x:%x:%x failed",
+			      NIPV6ADDR(&br_info->daddr));
+		kfree(br_info);
+		br_info = tmp;
+	}
+}
+
+/* 
+ * The function that is scheduled to do the callback functions. May be
+ * modified e.g to allow Binding Requests, now only calls expire() and
+ * schedules a new timer.
+ *
+ * Important: This function is a 'top-level' function in this module,
+ * it is not called from any other function inside the module although
+ * it is static. So it must take care of the syncronization, like the
+ * other static functions need not.  
+ */
+static void timer_handler(unsigned long dummy)
+{
+	expire();
+	write_lock(&bcache_lock);
+	set_timer();
+	write_unlock(&bcache_lock);
+}
+
+static void set_timer(void)
+{
+	struct mipv6_bcache_entry *entry;
+	unsigned long callback_time;
+
+	DEBUG_FUNC();
+
+	entry = (struct mipv6_bcache_entry *)
+		hashlist_get_first(bcache.entries);
+	if (entry != NULL) {
+		if (entry->callback_time == EXPIRE_INFINITE) {
+			DEBUG(DBG_WARNING, "expire at infinity, "
+			      "not setting a new timer");
+		} else {
+			if (entry->br_callback_time > 0)
+				callback_time = entry->br_callback_time;
+			else if (entry->callback_time > jiffies)
+				callback_time = entry->callback_time;
+			else {
+				DEBUG(DBG_WARNING, 
+				      "bcache timer attempted to schedule"
+				      " for a historical jiffies count!");
+				callback_time = jiffies + TIMERDELAY;
+			}
+
+			DEBUG(DBG_INFO, "setting timer to now");
+			mod_timer(&bcache.callback_timer, callback_time);
+		}
+	} else {
+		del_timer(&bcache.callback_timer);
+		DEBUG(DBG_INFO, "BC empty, not setting a new timer");
+	}
+}
+
+/*
+ * Generic list handling routine :
+ * 
+ * On each element on the prefix list, apply the home_addr's 2 low order words
+ * to create a full IPv6 address, and call the passed function with this
+ * address and the argument.
+ * 
+ * Assumes EUI64 prefix/ID.
+ *
+ * Returns :
+ * 	on success, the number of elements on the list for which the function
+ *		returned success.
+ * 	on failure, the negative value of the number of elements on the list
+ *		processed before the failure occurred.
+ *
+ */
+int mipv6_execute_list(struct prefix_info *plist, struct in6_addr *home_addr,
+		int count, int (*func)(struct in6_addr *, void *), void *arg)
+{
+	int i = 1;
+	struct in6_addr addr;
+	DEBUG_FUNC();
+	ipv6_addr_set(&addr, 0, 0, home_addr->s6_addr32[2],
+			home_addr->s6_addr32[3]);
+	while (i <= count) {
+		addr.s6_addr32[0] = plist->prefix.s6_addr32[0];
+		addr.s6_addr32[1] = plist->prefix.s6_addr32[1];
+		if (func(&addr, arg) < 0)
+			return -i;
+		plist ++;
+		i ++;
+	}
+	return count;
+}
+
+int mipv6_get_prefix_entries(struct in6_addr *home_addr,
+			struct prefix_info **plist, int single, int ifindex)
+{
+	int count;
+
+	extern int ipv6_get_prefix_entries(struct prefix_info **plist,
+			int ifindex, int plen);
+	DEBUG_FUNC();
+	if (single || (count = ipv6_get_prefix_entries(plist,
+				ifindex, 64)) <= 0) {
+		*plist = kmalloc(sizeof(struct prefix_info), GFP_ATOMIC);
+		if (*plist) {
+			ipv6_addr_copy(&((*plist)->prefix), home_addr);
+			(*plist)->prefix_len = 64;
+			return 1;
+		} else {
+			return 0;
+		}
+	}
+	return count;
+}
+
+static int plist_cleanup(struct in6_addr *home_addr, void *arg)
+{
+	struct in6_addr *ha_addr = (struct in6_addr *)arg;
+	struct in6_addr_pair hashkey;
+	struct mipv6_bcache_entry *entry;
+
+	hashkey.a1 = home_addr;
+	hashkey.a2 = ha_addr;
+
+	if ((entry = (struct mipv6_bcache_entry *)
+	     hashlist_get(bcache.entries, &hashkey)) != NULL) {
+		if (entry->type & HOME_REGISTRATION) {
+			del_proxy(home_addr, entry);
+		}
+		hashlist_delete(bcache.entries, (void *)entry);
+		mipv6_bcache_entry_free(entry);
+	}
+	return 0;
+}
+
+/*
+ * Interface functions visible to other modules
+ */
+
+/**
+ * mipv6_bcache_add - add Binding Cache entry
+ * @ifindex: interface index
+ * @our_addr: own address
+ * @home_addr_org: MN's home address
+ * @coa: MN's care-of address
+ * @lifetime: lifetime for this binding
+ * @prefix: prefix length
+ * @seq: sequence number
+ * @single: single address bit
+ * @type: type of entry
+ *
+ * Adds an entry for this @home_addr_org in the Binding Cache.  If entry
+ * already exists, old entry is updated.  @type may be %CACHE_ENTRY or
+ * %HOME_REGISTRATION.
+ **/
+int mipv6_bcache_add(int ifindex,
+		     struct in6_addr *our_addr,
+		     struct in6_addr *home_addr_org,
+		     struct in6_addr *coa,
+		     __u32 lifetime,
+		     __u8 prefix, __u16 seq, __u8 single, __u8 type)
+{
+	struct mipv6_bcache_entry *entry;
+	int update = 0;
+	int create_tunnel = 0;
+	unsigned long now = jiffies;
+	struct in6_addr_pair hashkey;
+	int count, count_org;
+	struct prefix_info *plist, *plist_org;
+	struct in6_addr home_addr;	/* calculated home address */
+	int processed_count = 0;
+	int ret = -1;
+	int update_pneigh_tbl = 0;
+
+	DEBUG_FUNC();
+
+	if (type != HOME_REGISTRATION) {
+		/*
+		 * If we are not doing a home registration, don't defend
+		 * multiple addresses.
+		 */
+		single = 1;
+		count_org = count = 1;
+		if ((plist = kmalloc(sizeof(struct prefix_info), GFP_ATOMIC)) 
+		    == NULL)
+			return -ENOMEM;
+
+		plist_org = plist;
+		ipv6_addr_copy(&plist->prefix, home_addr_org);
+		plist->prefix_len = 64;
+	} else {
+		single = 1;
+		if ((count =
+		     mipv6_get_prefix_entries(home_addr_org, &plist, single,
+					      ifindex)) <= 0) {
+			/* Memory failure, return failure */
+			DEBUG(DBG_INFO, "could not allocate"
+			      " memory for creating bcache entries");
+			return -ENOMEM;
+		}
+		count_org = count;
+		plist_org = plist;
+	}
+
+	hashkey.a2 = our_addr;
+
+	write_lock(&bcache_lock);
+
+	if (unlikely(bcache.entries == NULL)) {
+		ret = -ENOMEM;
+		goto err;
+	}
+process_next_home_address:
+	ipv6_addr_set(&home_addr, plist->prefix.s6_addr32[0],
+		      plist->prefix.s6_addr32[1],
+		      home_addr_org->s6_addr32[2],
+		      home_addr_org->s6_addr32[3]);
+	hashkey.a1 = &home_addr;
+	plist++;
+
+	if ((entry = (struct mipv6_bcache_entry *)
+	     hashlist_get(bcache.entries, &hashkey)) != NULL) {
+		/* if an entry for this home_addr exists (with smaller
+		 * seq than the new seq), update it by removing it
+		 * first
+		 */
+		if (modGT65536(seq, entry->seq)) {
+			DEBUG(DBG_INFO, "updating an existing entry");
+			update = 1;
+			create_tunnel = (type == HOME_REGISTRATION &&
+					 (entry->type != HOME_REGISTRATION ||
+					  ipv6_addr_cmp(&entry->coa, coa) ||
+					  entry->ifindex != ifindex || 
+					  entry->prefix != prefix || 
+					  entry->single != single));
+			mipv6_check_entry(entry, create_tunnel, type, single,
+						&update_pneigh_tbl);
+		} else {
+			DEBUG(DBG_INFO, "smaller seq than existing, not updating");
+			goto out;
+		}
+	} else {
+		/* no entry for this home_addr, try to create a new entry */
+		DEBUG(DBG_INFO, "creating a new entry");
+		entry = mipv6_bcache_get_entry(type);
+
+		update = 0;
+
+		if (entry == NULL) {
+			DEBUG(DBG_INFO, "cache full, entry not added");
+			goto err;
+		}
+
+		create_tunnel = (type == HOME_REGISTRATION);
+	}
+
+	ipv6_addr_copy(&(entry->our_addr), our_addr);
+	ipv6_addr_copy(&(entry->home_addr), &home_addr);
+	ipv6_addr_copy(&(entry->coa), coa);
+	entry->ifindex = ifindex;
+	entry->prefix = prefix;
+	entry->seq = seq;
+	entry->type = type;
+	entry->last_used = 0;
+
+	hashkey.a1 = &entry->home_addr;
+	hashkey.a2 = &entry->our_addr;
+
+	if ((ret = mipv6_create_tnl(type, single, create_tunnel, ifindex,
+					prefix, entry, coa,
+					our_addr, &home_addr,
+					update_pneigh_tbl))) {
+		if (ret == 1)
+			goto err_plist;
+		else goto err_tnl;
+	}
+
+	entry->last_br = 0;
+	if (lifetime == EXPIRE_INFINITE) {
+		entry->callback_time = EXPIRE_INFINITE;
+	} else {
+		entry->callback_time = now + lifetime * HZ;
+		if (entry->type & HOME_REGISTRATION)
+			entry->br_callback_time = 0;
+		else
+			entry->br_callback_time = now +
+				(lifetime - BCACHE_BR_SEND_LEAD) * HZ;
+	}
+	
+	if (update) {
+		DEBUG(DBG_INFO, "updating entry : %x", entry);
+		hashlist_reposition(bcache.entries, (void *)entry, 
+				    entry->callback_time);
+	} else {
+		DEBUG(DBG_INFO, "adding entry: %x", entry);
+		if ((hashlist_add(bcache.entries,
+				  &hashkey,
+				  entry->callback_time, entry)) < 0) {
+			
+			DEBUG(DBG_ERROR, "Hash add failed");
+			goto err_proxy;
+		}
+	}
+	processed_count++;
+	if (--count) {
+		goto process_next_home_address;
+	}
+	
+	set_timer();
+	
+out:
+	write_unlock(&bcache_lock);
+	kfree(plist_org);
+	return 0;
+	
+err_proxy:
+	if (create_tunnel || update_pneigh_tbl) {
+		bcache_proxy_nd_rem(entry);
+	}
+err_tnl:
+#ifdef CONFIG_IPV6_MOBILITY_HA
+	if (create_tunnel) {
+		mipv6_del_tnl_to_mn(coa, our_addr, &home_addr);
+	}
+#endif
+err_plist:
+	mipv6_execute_list(plist_org, &home_addr, 
+			   processed_count,
+			   plist_cleanup, our_addr);
+	
+	if (update) {
+		hashlist_delete(bcache.entries, (void *)entry);
+	}
+	mipv6_bcache_entry_free(entry);
+err:
+	write_unlock(&bcache_lock);
+	kfree(plist_org);
+	return ret;
+}
+
+static int __mipv6_bcache_delete(struct in6_addr *addr, void *arg)
+{
+	struct in6_addr_pair hashkey;
+	struct mipv6_bcache_entry *entry;
+
+	hashkey.a1 = addr;
+	hashkey.a2 = (struct in6_addr *) arg;
+	entry = (struct mipv6_bcache_entry *)
+	    hashlist_get(bcache.entries, &hashkey);
+	if (entry == NULL) {
+		DEBUG(DBG_INFO, "No such entry");
+		return 0;
+	}
+	if (entry->type == HOME_REGISTRATION) {
+		del_proxy(&entry->home_addr, entry);
+	}
+	hashlist_delete(bcache.entries, (void *) entry);
+	mipv6_bcache_entry_free(entry);
+	return 0;
+}
+
+/**
+ * mipv6_bcache_delete - delete Binding Cache entry
+ * @home_addr: MN's home address
+ * @our_addr: our address
+ * @type: type of entry
+ *
+ * Deletes an entry associated with @home_addr from Binding Cache.
+ * Valid values for @type are %CACHE_ENTRY, %HOME_REGISTRATION and
+ * %ANY_ENTRY.  %ANY_ENTRY deletes any type of entry.
+ **/
+int mipv6_bcache_delete(struct in6_addr *home_addr,
+			struct in6_addr *our_addr, __u8 type)
+{
+	struct mipv6_bcache_entry *entry;
+	struct in6_addr_pair hashkey;
+	int count;
+	struct prefix_info *plist;
+	int err = 0;
+
+	DEBUG_FUNC();
+
+	if (home_addr == NULL || our_addr == NULL || !is_valid_type(type)) {
+		DEBUG(DBG_INFO, "error in arguments");
+		return -EINVAL;
+	}
+
+	hashkey.a1 = home_addr;
+	hashkey.a2 = our_addr;
+
+	write_lock(&bcache_lock);
+
+	if (unlikely(bcache.entries == NULL) ||
+	    (entry = (struct mipv6_bcache_entry *)
+	     hashlist_get(bcache.entries, &hashkey)) == NULL ||
+	    !(entry->type & type)) {
+		DEBUG(DBG_INFO, "No matching entry found");
+		err = -ENOENT;
+		goto out;
+	}
+	if (type != HOME_REGISTRATION) {
+		count = 1;
+		if ((plist = kmalloc(sizeof(struct prefix_info), GFP_ATOMIC)) == NULL) {
+			err = -ENOMEM;
+			goto out;
+		}
+		ipv6_addr_copy(&plist->prefix, home_addr);
+		plist->prefix_len = 64;
+	} else {
+		if ((count = mipv6_get_prefix_entries(home_addr, &plist,
+						      entry->single,
+						      entry->ifindex)) <= 0) {
+			err = -ENOMEM;
+			goto out;
+		}
+	}
+
+	mipv6_execute_list(plist, home_addr, count, __mipv6_bcache_delete,
+			   our_addr);
+	kfree(plist);
+	
+	set_timer();
+out:
+	write_unlock(&bcache_lock);
+	return err;
+}
+
+/**
+ * mipv6_bcache_exists - check if entry exists
+ * @home_addr: home address to check
+ * @our_addr: our address
+ *
+ * Determines if a binding exists for @home_addr.  Returns type of the
+ * entry or negative if entry does not exist.
+ **/
+int mipv6_bcache_exists(struct in6_addr *home_addr,
+			struct in6_addr *our_addr)
+{
+	struct mipv6_bcache_entry *entry;
+	struct in6_addr_pair hashkey;
+	int type = -ENOENT;
+
+	DEBUG_FUNC();
+
+	if (home_addr == NULL || our_addr == NULL)
+		return -EINVAL;
+
+	hashkey.a1 = home_addr;
+	hashkey.a2 = our_addr;
+
+	read_lock(&bcache_lock);
+	if (likely(bcache.entries != NULL) &&
+	    (entry = (struct mipv6_bcache_entry *)
+	     hashlist_get(bcache.entries, &hashkey)) != NULL) {
+		type = entry->type;
+	}
+	read_unlock(&bcache_lock);
+
+	return type;
+}
+
+/**
+ * mipv6_bcache_get - get entry from Binding Cache
+ * @home_addr: home address to search
+ * @our_addr: our address
+ * @entry: pointer to buffer
+ *
+ * Gets a copy of Binding Cache entry for @home_addr.  Entry's
+ * @last_used field is updated.  If entry exists entry is copied to
+ * @entry and zero is returned.  Otherwise returns negative.
+ **/
+int mipv6_bcache_get(struct in6_addr *home_addr,
+		     struct in6_addr *our_addr,
+		     struct mipv6_bcache_entry *entry)
+{
+	struct mipv6_bcache_entry *entry2;
+	struct in6_addr_pair hashkey;
+	int ret = -1;
+
+	DEBUG_FUNC();
+
+	if (home_addr == NULL || our_addr == NULL || entry == NULL)
+		return -1;
+
+	hashkey.a1 = home_addr;
+	hashkey.a2 = our_addr;
+
+	read_lock_bh(&bcache_lock);
+
+	entry2 = (struct mipv6_bcache_entry *)
+	    hashlist_get(bcache.entries, &hashkey);
+	if (entry2 != NULL) {
+		entry2->last_used = jiffies;
+		memcpy(entry, entry2, sizeof(struct mipv6_bcache_entry));
+		ret = 0;
+	}
+	read_unlock_bh(&bcache_lock);
+	return ret;
+}
+
+int mipv6_bcache_iterate(hashlist_iterator_t func, void *args)
+{
+	int ret;
+
+	read_lock_bh(&bcache_lock);
+	ret = hashlist_iterate(bcache.entries, args, func);
+	read_unlock_bh(&bcache_lock);
+
+	return ret;
+}
+
+/*
+ * Proc-filesystem functions
+ */
+
+#define BC_INFO_LEN 90
+
+struct procinfo_iterator_args {
+	char *buffer;
+	int offset;
+	int length;
+	int skip;
+	int len;
+};
+
+static int procinfo_iterator(void *data, void *args, unsigned long *pref)
+{
+	struct procinfo_iterator_args *arg =
+	    (struct procinfo_iterator_args *) args;
+	struct mipv6_bcache_entry *entry =
+	    (struct mipv6_bcache_entry *) data;
+
+	DEBUG_FUNC();
+
+	if (entry == NULL)
+		return ITERATOR_ERR;
+
+	if (arg->skip < arg->offset / BC_INFO_LEN) {
+		arg->skip++;
+		return ITERATOR_CONT;
+	}
+
+	if (arg->len >= arg->length)
+		return ITERATOR_CONT;
+
+	arg->len += sprintf(arg->buffer + arg->len,
+			    "h=%04x%04x%04x%04x%04x%04x%04x%04x "
+			    "c=%04x%04x%04x%04x%04x%04x%04x%04x "
+			    "(e=%010lu,t=%02d)\n",
+			    NIPV6ADDR(&entry->home_addr),
+			    NIPV6ADDR(&entry->coa),
+			    ((entry->callback_time) - jiffies) / HZ,
+			    (int) entry->type);
+
+	return ITERATOR_CONT;
+}
+
+ /*
+  * Callback function for proc filesystem.
+  */
+static int bcache_proc_info(char *buffer, char **start, off_t offset,
+			    int length)
+{
+	struct procinfo_iterator_args args;
+
+	args.buffer = buffer;
+	args.offset = offset;
+	args.length = length;
+	args.skip = 0;
+	args.len = 0;
+
+	read_lock_bh(&bcache_lock);
+	hashlist_iterate(bcache.entries, &args, procinfo_iterator);
+	read_unlock_bh(&bcache_lock);
+
+	*start = buffer;
+	if (offset)
+		*start += offset % BC_INFO_LEN;
+
+	args.len -= offset % BC_INFO_LEN;
+
+	if (args.len > length)
+		args.len = length;
+	if (args.len < 0)
+		args.len = 0;
+
+	return args.len;
+}
+
+/* Router bit leftovers.  See if we need this later on with mobile
+ * networks.  Prototype removed. */
+
+static int bcache_compare(void *data, void *hashkey)
+{
+	struct in6_addr_pair *p = (struct in6_addr_pair *) hashkey;
+	struct mipv6_bcache_entry *e = (struct mipv6_bcache_entry *) data;
+
+	if (ipv6_addr_cmp(&e->home_addr, p->a1) == 0
+	    && ipv6_addr_cmp(&e->our_addr, p->a2) == 0)
+		return 0;
+	else
+		return -1;
+}
+
+static __u32 bcache_hash(void *hashkey)
+{
+	struct in6_addr_pair *p = (struct in6_addr_pair *) hashkey;
+
+	return p->a1->s6_addr32[0] ^ p->a1->s6_addr32[1] ^
+		p->a2->s6_addr32[2] ^ p->a2->s6_addr32[3];
+}
+
+static void *bcache_hashkey(void *data)
+{
+	struct in6_addr_pair *p;
+	struct mipv6_bcache_entry *e = (struct mipv6_bcache_entry *) data;
+
+	if ((p = kmalloc(sizeof(struct in6_addr_pair), GFP_KERNEL)) == NULL)
+		return NULL;
+
+	p->a1 = &e->home_addr;
+	p->a2 = &e->our_addr;
+
+	return p;
+}
+
+/* 
+ * Initialization and shutdown functions
+ */
+
+int __init mipv6_bcache_init(__u32 size)
+{
+	if (size < 1) {
+		DEBUG(DBG_ERROR, "Binding cache size must be at least 1");
+		return -EINVAL;
+	}
+	bcache.entries = hashlist_create(MIPV6_BCACHE_HASHSIZE, size,
+					 sizeof(struct mipv6_bcache_entry),
+					 "mip6_bcache", NULL, NULL,
+					 bcache_compare, bcache_hash,
+					 bcache_hashkey);
+
+	if (bcache.entries == NULL) {
+		DEBUG(DBG_ERROR, "Failed to initialize hashlist");
+		return -ENOMEM;
+	}
+
+	init_timer(&bcache.callback_timer);
+	bcache.callback_timer.data = 0;
+	bcache.callback_timer.function = timer_handler;
+	bcache.size = size;
+
+	proc_net_create("mip6_bcache", 0, bcache_proc_info);
+
+	DEBUG(DBG_INFO, "Binding cache initialized");
+	return 0;
+}
+
+int __exit mipv6_bcache_exit(void)
+{
+	struct mipv6_bcache_entry *entry;
+	struct hashlist *entries;
+
+	DEBUG_FUNC();
+
+	proc_net_remove("mip6_bcache");
+
+	write_lock_bh(&bcache_lock);
+	DEBUG(DBG_INFO, "Stopping the bcache timer");
+	del_timer(&bcache.callback_timer);
+
+	while ((entry = (struct mipv6_bcache_entry *)
+		hashlist_get_first(bcache.entries)) != NULL) {
+		
+		/*      hashlist_delete_first(bcache.entries); */
+		if (entry->type == HOME_REGISTRATION) {
+			del_proxy(&entry->home_addr, entry);
+		}
+		hashlist_delete(bcache.entries, (void *) entry);
+		mipv6_bcache_entry_free(entry);
+	}
+	entries = bcache.entries;
+	bcache.entries = NULL;
+	write_unlock_bh(&bcache_lock);
+
+	hashlist_destroy(entries);
+	return 0;
+}
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/bcache.h linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/bcache.h
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/bcache.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/bcache.h	2003-05-18 11:33:53.000000000 +0200
@@ -0,0 +1,68 @@
+/*
+ *      Binding Cache header file
+ *
+ *      Authors:
+ *      Juha Mynttinen            <jmynttin@cc.hut.fi>
+ *
+ *      $Id: s.bcache.h 1.18 02/11/25 11:18:16+02:00 vnuorval@amber.hut.mediapoli.com $
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef _BCACHE_H
+#define _BCACHE_H
+
+#include <linux/in6.h>
+#include <linux/timer.h>
+#include "hashlist.h"
+
+#define CACHE_ENTRY 1 /* this and HOME_REGISTRATION are the entry types */
+#define HOME_REGISTRATION 2
+#define ANY_ENTRY 3
+
+#define EXPIRE_INFINITE 0xffffffff
+
+struct mipv6_bcache_entry {
+	struct hashlist_entry e;
+	int ifindex;				/* Interface identifier */
+	struct in6_addr our_addr;		/* our address (as seen by the MN) */
+	struct in6_addr home_addr;		/* MN home address */
+	struct in6_addr coa;			/* MN care-of address */
+	unsigned long callback_time;		/* time of expiration     (in jiffies) */
+	unsigned long br_callback_time;		/* time for sending a BR  (in jiffies) */
+	int (*callback_function)(struct mipv6_bcache_entry *entry);
+	__u8 type;				/* home registration */
+	__u8 router;				/* mn is router */
+	__u8 single;				/* single address bit */
+	__u8 prefix;				/* prefix length */
+	__u16 seq;				/* sequence number */
+	unsigned long last_br;			/* time when last BR sent */
+	unsigned long last_used;		/* time of last use       (in jiffies) */
+};
+
+int mipv6_bcache_add(int ifindex, struct in6_addr *our_addr, 
+		     struct in6_addr *home_addr, struct in6_addr *coa,
+		     __u32 lifetime, __u8 prefix, __u16 seq, __u8 single,
+		     __u8 type);
+
+int mipv6_bcache_delete(struct in6_addr *home_addr, struct in6_addr *our_addr,
+			__u8 type);
+
+int mipv6_bcache_exists(struct in6_addr *home_addr,
+			struct in6_addr *our_addr);
+
+int mipv6_bcache_get(struct in6_addr *home_addr,
+		     struct in6_addr *our_addr,
+		     struct mipv6_bcache_entry *entry);
+
+int mipv6_bcache_iterate(int (*func)(void *, void *, unsigned long *), void *args);
+
+int mipv6_bcache_init(__u32 size);
+
+int mipv6_bcache_exit(void);
+
+#endif /* _BCACHE_H */
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/bul.c linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/bul.c
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/bul.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/bul.c	2003-05-18 11:33:53.000000000 +0200
@@ -0,0 +1,661 @@
+/*
+ *      Binding update list
+ *
+ *      Authors:
+ *      Juha Mynttinen            <jmynttin@cc.hut.fi>
+ *
+ *      $Id: s.bul.c 1.81 02/12/19 16:14:47+02:00 antti@jon.mipl.mediapoli.com $
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ */
+
+/*
+ *	Changes:
+ *
+ *	Nanno Langstraat	:	Timer code cleaned up
+ */
+
+#include <linux/autoconf.h>
+#include <linux/sched.h>
+#include <linux/timer.h>
+#include <linux/in6.h>
+#include <linux/init.h>
+#include <linux/spinlock.h>
+#include <net/ipv6.h>
+#include <net/mipv6.h>
+#include <linux/proc_fs.h>
+
+#include "bul.h"
+#include "debug.h"
+#include "hashlist.h"
+#include "tunnel.h"
+#include "util.h"
+#include "mn.h"
+#include "mobhdr.h"
+
+#define TIMERDELAY HZ/10
+#define MIPV6_BUL_HASHSIZE 32
+
+rwlock_t bul_lock = RW_LOCK_UNLOCKED;
+
+struct mipv6_bul {
+	struct hashlist *entries;
+	struct timer_list callback_timer;
+};
+
+static struct mipv6_bul bul;
+
+/**********************************************************************
+ *
+ * Private functions
+ *
+ **********************************************************************/
+
+static int bul_compare(void *data, void *hashkey)
+{
+	struct in6_addr_pair *p = (struct in6_addr_pair *)hashkey;
+	struct mipv6_bul_entry *e = (struct mipv6_bul_entry *)data;
+
+	if (ipv6_addr_cmp(&e->cn_addr, p->a1) == 0
+	    && ipv6_addr_cmp(&e->home_addr, p->a2) == 0)
+		return 0;
+	else
+		return -1;
+}
+
+static __u32 bul_hash(void *hashkey)
+{
+	struct in6_addr_pair *p = (struct in6_addr_pair *)hashkey;
+	
+	return p->a1->s6_addr32[0] ^
+		p->a1->s6_addr32[1] ^
+		p->a2->s6_addr32[2] ^
+		p->a2->s6_addr32[3];
+}
+
+static void *bul_hashkey(void *data)
+{
+	struct in6_addr_pair *p;
+	struct mipv6_bul_entry *e = (struct mipv6_bul_entry *)data;
+
+	if ((p = kmalloc(sizeof(struct in6_addr_pair), GFP_ATOMIC)) == NULL)
+		return NULL;
+
+	p->a1 = &e->cn_addr;
+	p->a2 = &e->home_addr;
+
+	return p;
+}
+
+static int bul_proc_info(char *buffer, char **start, off_t offset,
+			    int length);
+
+static void set_timer(void);
+
+static struct mipv6_bul_entry *mipv6_bul_get_entry(void)
+{
+	DEBUG_FUNC();
+	return ((struct mipv6_bul_entry *) 
+		hashlist_alloc(bul.entries, SLAB_ATOMIC));
+}
+
+static void mipv6_bul_entry_free(struct mipv6_bul_entry *entry)
+{
+	DEBUG_FUNC();		
+
+	if (entry->rr) {
+		if (entry->rr->kbu)
+			kfree(entry->rr->kbu);
+		kfree(entry->rr);
+	}
+	if (entry->ops)
+		kfree(entry->ops);
+	hashlist_free(bul.entries, (void *)entry);
+}
+
+static __inline__ int del_bul_entry_tnl(struct mipv6_bul_entry *entry) 
+{
+       if (entry->flags & MIPV6_BU_F_HOME) {
+               return mipv6_del_tnl_to_ha(&entry->cn_addr, 
+                                          &entry->coa,
+                                          &entry->home_addr);
+       }
+       return 0;
+}
+
+static void timer_handler(unsigned long dummy)
+{
+	struct mipv6_bul_entry *entry;
+
+	DEBUG_FUNC();
+
+	write_lock(&bul_lock);
+
+	entry = hashlist_get_first(bul.entries);
+
+	if (entry == NULL) {
+		DEBUG(DBG_ERROR, "bul task_handler executed but found no work to do");
+		write_unlock(&bul_lock);
+		return;
+	}
+
+	while (time_after_eq(jiffies, entry->callback_time)) {
+		if (time_after_eq(jiffies, entry->expire) ||
+		    entry->callback(entry) != 0) {
+			/*
+			 * Either the entry has expired, or the callback
+			 * indicated that it should be deleted.
+			 */
+			hashlist_delete(bul.entries, (void *)entry);
+			
+			del_bul_entry_tnl(entry);
+			 if (entry->flags & MIPV6_BU_F_HOME)
+				 mipv6_mninfo_del(&entry->home_addr, 1);
+			mipv6_bul_entry_free(entry);
+			DEBUG(DBG_INFO, "Entry deleted (was expired) from "
+			      "binding update list");
+		} else {
+			/* move entry to its right place in the hashlist */
+			DEBUG(DBG_INFO, "Rescheduling");
+			hashlist_reposition(bul.entries, (void *)entry,
+					    entry->callback_time);
+		}
+		if ((entry = (struct mipv6_bul_entry *)
+		     hashlist_get_first(bul.entries)) == NULL)
+			break;
+	}
+
+	set_timer();
+
+	write_unlock(&bul_lock);
+}
+
+static void set_timer(void)
+{
+	struct mipv6_bul_entry *entry;
+	unsigned long callback_time;
+
+	DEBUG_FUNC();
+
+	/* no locking here */
+	entry = (struct mipv6_bul_entry *)hashlist_get_first(bul.entries);
+	if (entry != NULL) {
+		callback_time = entry->callback_time;
+		if (entry->callback_time < jiffies) {
+			DEBUG(DBG_INFO, "bul.c: set_timer: bul timer "
+			      "attempted to schedule a timer with a "
+			      "historical jiffies count!");
+			callback_time = jiffies+TIMERDELAY;
+			DEBUG(DBG_INFO, 
+			      "bul.c: set_timer: setting timer to now");
+
+		}
+		mod_timer(&bul.callback_timer, callback_time);
+	} else {
+		DEBUG(DBG_INFO, "bul.c: set_timer: bul empty, not "
+		      "setting a new timer");
+		del_timer(&bul.callback_timer);
+	}
+}
+
+/**********************************************************************
+ *
+ * Public interface functions
+ *
+ **********************************************************************/
+
+/**
+ * bul_iterate - apply interator function to all entries
+ * @func: function to apply
+ * @args: extra arguments for iterator
+ *
+ * Applies @func for each entry in Binding Update List.  Extra
+ * arguments given in @args are also passed to the iterator function.
+ * Caller must hold @bul_lock.
+ **/
+int bul_iterate(hashlist_iterator_t func, void *args)
+{
+	DEBUG_FUNC();
+
+	return hashlist_iterate(bul.entries, args, func);
+}
+
+/**
+ * mipv6_bul_exists - check if Binding Update List entry exists
+ * @cn: address to check
+ *
+ * Checks if Binding Update List has an entry for @cn.  Returns true
+ * if entry exists, false otherwise. Caller may not hold @bul_lock.
+ **/
+int mipv6_bul_exists(struct in6_addr *cn, struct in6_addr *haddr)
+{
+	int exists;
+	struct in6_addr_pair hashkey;
+
+	DEBUG_FUNC();
+
+	hashkey.a1 = cn;
+	hashkey.a2 = haddr;
+	
+	read_lock_bh(&bul_lock);
+
+	if (unlikely(bul.entries == NULL))
+		exists = 0;
+	else
+		exists = hashlist_exists(bul.entries, &hashkey);
+
+	read_unlock_bh(&bul_lock);
+	return exists;
+}
+
+/**
+ * mipv6_bul_get - get Binding Update List entry
+ * @cn_addr: CN address to search
+ * @home_addr: home address to search
+ *
+ * Returns Binding Update List entry for @cn_addr if it exists.
+ * Otherwise returns %NULL.  Caller must hold @bul_lock.
+ **/
+struct mipv6_bul_entry *mipv6_bul_get(struct in6_addr *cn_addr, 
+				      struct in6_addr *home_addr)
+{
+	struct mipv6_bul_entry *entry;
+	struct in6_addr_pair hashkey;
+	
+	DEBUG_FUNC();
+
+	if (unlikely(bul.entries == NULL)) {
+		return NULL;
+	}
+	hashkey.a1 = cn_addr;
+	hashkey.a2 = home_addr;
+
+	entry = (struct mipv6_bul_entry *) 
+		hashlist_get(bul.entries, &hashkey);
+		
+	return entry;
+}
+
+/**
+ * mipv6_bul_reschedule - reschedule Binding Update List entry
+ * @entry: entry to reschedule
+ *
+ * Reschedules a Binding Update List entry.  Must be called after
+ * modifying entry lifetime.  Caller must hold @bul_lock (write).
+ **/
+void mipv6_bul_reschedule(struct mipv6_bul_entry *entry)
+{
+	DEBUG_FUNC();
+
+	hashlist_reposition(bul.entries,
+			    (void *)entry,
+			    entry->callback_time);
+	set_timer();
+}
+
+/**
+ * mipv6_bul_add - add binding update to Binding Update List
+ * @cn_addr: IPv6 address where BU was sent
+ * @home_addr: Home address for this binding
+ * @coa: Care-of address for this binding
+ * @lifetime: expiration time of the binding in seconds
+ * @seq: sequence number of the BU
+ * @prefix: length of prefix in bits
+ * @flags: %MIPV6_BU_F_* flags
+ * @callback: callback function called on expiration
+ * @callback_time: expiration time for callback
+ * @state: binding send state
+ * @delay: retransmission delay
+ * @maxdelay: retransmission maximum delay
+ * @ops: Mobility header options for BU
+ * @rr: Return routability information
+ *
+ * Adds a binding update sent to @cn_addr for @home_addr to the
+ * Binding Update List.  If entry already exists, it is updated.
+ * Entry is set to expire in @lifetime seconds.  Entry has a callback
+ * function @callback that is called at @callback_time.  Entry @state
+ * controls resending of this binding update and it can be set to
+ * %ACK_OK, %RESEND_EXP or %ACK_ERROR.  Returns a pointer to the newly
+ * created or updated entry.  Caller must hold @bul_lock (write).
+ **/
+struct mipv6_bul_entry *mipv6_bul_add(
+	struct in6_addr *cn_addr, struct in6_addr *home_addr,
+	struct in6_addr *coa, 
+	__u32 lifetime,	__u8 seq, __u8 prefix, __u8 flags,
+	int (*callback)(struct mipv6_bul_entry *entry),
+	__u32 callback_time, 
+	__u8 state, __u32 delay, __u32 maxdelay,
+	struct mipv6_mh_opt *ops, 
+	struct mipv6_rr_info *rr)
+{
+	struct mipv6_bul_entry *entry;
+	int update = 0;
+	int create_tunnel = 0;
+	struct in6_addr_pair hashkey;
+
+	DEBUG_FUNC();
+
+	if (unlikely(bul.entries == NULL))
+		return NULL;
+
+	if (cn_addr == NULL || home_addr == NULL || 
+	    coa == NULL || lifetime < 0 ||
+	    prefix > 128 || callback == NULL || 
+	    callback_time < 0 || 
+	    (state != ACK_OK && state != RESEND_EXP && state != ACK_ERROR) ||
+	    delay < 0 || maxdelay < 0) {
+		DEBUG(DBG_WARNING, "invalid arguments");
+		return NULL;
+	}
+	DEBUG(DBG_INFO, "cn_addr: %x:%x:%x:%x:%x:%x:%x:%x, "
+	      "home_addr: %x:%x:%x:%x:%x:%x:%x:%x"
+	      "coaddr: %x:%x:%x:%x:%x:%x:%x:%x", NIPV6ADDR(cn_addr), 
+	       NIPV6ADDR(home_addr), NIPV6ADDR(coa));
+	hashkey.a1 = cn_addr;
+	hashkey.a2 = home_addr;
+	
+	/* 
+	 * decide whether to add a new entry or update existing, also
+	 * check if there's room for a new entry when adding a new
+	 * entry (latter is handled by mipv6_bul_get_entry() 
+	 */
+	if ((entry = (struct mipv6_bul_entry *)
+	     hashlist_get(bul.entries, &hashkey)) != NULL) {
+		/* if an entry for this cn_addr exists (with smaller
+		 * seq than the new entry's seq), update it */
+		
+		if (modGT65536(seq, entry->seq)) {
+			DEBUG(DBG_INFO, "updating an existing entry");
+			update = 1;
+			if ((entry->flags & MIPV6_BU_F_HOME) &&
+			    (!(flags & MIPV6_BU_F_HOME) || 
+			     ipv6_addr_cmp(&entry->coa, coa))) {
+				/* old tunnel no longer valid */
+				mipv6_del_tnl_to_ha(&entry->cn_addr, 
+						    &entry->coa,
+						    &entry->home_addr);
+				create_tunnel = ipv6_addr_cmp(coa, home_addr) && (flags & MIPV6_BU_F_HOME) && lifetime;
+			} else if (!(entry->flags & MIPV6_BU_F_HOME)) {
+				create_tunnel = 0;
+			} 
+		} else {
+			DEBUG(DBG_INFO, "smaller seq than existing, not updating");
+			return NULL;
+		}
+	} else {
+		entry = mipv6_bul_get_entry();
+		if (entry == NULL) {
+			DEBUG(DBG_WARNING, "binding update list full, can't add!!!");
+			return NULL;
+		}
+		memset(entry, 0, sizeof(*entry));
+		/* First BU send happens here, save count in the entry */
+		entry->consecutive_sends = 1;
+		create_tunnel =  ipv6_addr_cmp(coa, home_addr) && (flags & MIPV6_BU_F_HOME) && lifetime;
+	}
+
+	if (!update) {
+		ipv6_addr_copy(&(entry->cn_addr), cn_addr);
+		ipv6_addr_copy(&(entry->home_addr), home_addr);
+		entry->ops = ops;
+	}
+	/* Add Return Routability info to bul entry */
+	if (rr) {
+		if(entry->rr)
+			kfree(entry->rr); 
+		entry->rr = rr;
+	}
+
+	ipv6_addr_copy(&(entry->coa), coa);
+	entry->lifetime = lifetime;
+	if (lifetime)
+		entry->expire = jiffies + lifetime * HZ;
+	else if (flags & MIPV6_BU_F_ACK)
+		entry->expire = jiffies + HOME_RESEND_EXPIRE * HZ;
+	entry->seq = seq;
+	entry->prefix = prefix;
+	entry->flags = flags;
+	entry->lastsend = jiffies; /* current time = last use of the entry */
+	entry->state = state;
+	entry->delay = delay;
+	entry->maxdelay = maxdelay;
+	entry->callback_time = jiffies + callback_time * HZ;
+	entry->callback = callback;
+
+	if (create_tunnel) {
+               int ret = mipv6_add_tnl_to_ha(cn_addr, coa, home_addr);
+               if(ret <= 0) {
+                       DEBUG(DBG_INFO, "tunnel add failed with code %d", ret);
+                       if (update) 
+                               hashlist_delete(bul.entries, (void *)entry);
+			mipv6_bul_entry_free(entry);
+			return NULL;
+		}
+
+	}
+	if (update) {
+		DEBUG(DBG_INFO, "updating entry: %x", entry);
+		hashlist_reposition(bul.entries, (void *)entry,
+				    entry->callback_time);
+	} else {
+		DEBUG(DBG_INFO, "adding entry: %x", entry);
+
+		hashkey.a1 = &entry->cn_addr;
+		hashkey.a2 = &entry->home_addr;
+
+		if ((hashlist_add(bul.entries, &hashkey,
+				  entry->callback_time,
+				  entry)) < 0) {
+			DEBUG(DBG_ERROR, "Hash add failed");
+			if (create_tunnel) {
+				mipv6_del_tnl_to_ha(cn_addr, coa, home_addr);
+			}
+			mipv6_bul_entry_free(entry);			
+			return NULL;
+		}
+	}
+	set_timer();	
+
+	return entry;
+}
+
+/**
+ * mipv6_bul_delete - delete Binding Update List entry
+ * @cn_addr: address for entry to delete
+ *
+ * Deletes the entry for @cn_addr from the Binding Update List.
+ * Returns zero if entry was deleted succesfully, otherwise returns
+ * negative.  Caller may not hold @bul_lock.
+ **/
+int mipv6_bul_delete(struct in6_addr *cn_addr, struct in6_addr *home_addr)
+{
+	struct mipv6_bul_entry *entry;
+	struct in6_addr_pair hashkey;
+
+	DEBUG_FUNC();
+
+	hashkey.a1 = cn_addr;
+	hashkey.a2 = home_addr;
+
+	write_lock(&bul_lock);
+
+	if (unlikely(bul.entries == NULL) ||  
+	    (entry = (struct mipv6_bul_entry *)
+	     hashlist_get(bul.entries, &hashkey)) == NULL) {
+		write_unlock(&bul_lock);
+		DEBUG(DBG_INFO, "No such entry");
+		return -ENOENT;
+	}
+
+	hashlist_delete(bul.entries, (void *)entry);
+
+	del_bul_entry_tnl(entry);
+
+	mipv6_bul_entry_free(entry);
+	set_timer();
+	write_unlock(&bul_lock);
+
+	DEBUG(DBG_INFO, "Binding update list entry deleted");
+
+	return 0;
+}
+
+/**********************************************************************
+ *
+ * Proc interface functions
+ *
+ **********************************************************************/
+
+#define BUL_INFO_LEN 187
+
+struct procinfo_iterator_args {
+	char *buffer;
+	int offset;
+	int length;
+	int skip;
+	int len;
+};
+
+static int procinfo_iterator(void *data, void *args,
+			     unsigned long *sortkey)
+{
+	struct procinfo_iterator_args *arg =
+		(struct procinfo_iterator_args *)args;
+	struct mipv6_bul_entry *entry =
+		(struct mipv6_bul_entry *)data;
+	unsigned long callback_seconds;
+
+	DEBUG_FUNC();
+
+	if (entry == NULL) return ITERATOR_ERR;
+
+	if (time_after(jiffies, entry->callback_time))
+		callback_seconds = 0;
+	else
+		callback_seconds = (entry->callback_time - jiffies) / HZ;
+
+	if (arg->skip < arg->offset / BUL_INFO_LEN) {
+		arg->skip++;
+		return ITERATOR_CONT;
+	}
+
+	if (arg->len >= arg->length)
+		return ITERATOR_CONT;
+
+	arg->len += sprintf(arg->buffer + arg->len,
+			"cna=%04x%04x%04x%04x%04x%04x%04x%04x "
+			"ha=%04x%04x%04x%04x%04x%04x%04x%04x "
+			"coa=%04x%04x%04x%04x%04x%04x%04x%04x\n"
+			"exp=%010lu seq=%05d sta=%02d del=%010d mdl=%010d cbs=%010lu\n",
+			NIPV6ADDR(&entry->cn_addr), 
+			NIPV6ADDR(&entry->home_addr), 
+			NIPV6ADDR(&entry->coa), 
+			(entry->expire - jiffies) / HZ,
+			entry->seq, entry->state, entry->delay, 
+			entry->maxdelay, callback_seconds);
+
+	return ITERATOR_CONT;
+}
+
+
+/*
+ * Callback function for proc filesystem.
+ */
+static int bul_proc_info(char *buffer, char **start, off_t offset,
+                            int length)
+{
+	struct procinfo_iterator_args args;
+
+	DEBUG_FUNC();
+
+	args.buffer = buffer;
+	args.offset = offset;
+	args.length = length;
+	args.skip = 0;
+	args.len = 0;
+
+	read_lock_bh(&bul_lock);
+	hashlist_iterate(bul.entries, &args, procinfo_iterator);
+	read_unlock_bh(&bul_lock);
+
+	*start = buffer;
+	if (offset)
+		*start += offset % BUL_INFO_LEN;
+
+	args.len -= offset % BUL_INFO_LEN;
+
+	if (args.len > length)
+		args.len = length;
+	if (args.len < 0)
+		args.len = 0;
+	
+	return args.len;
+}
+
+/**********************************************************************
+ *
+ * Code module init/fini functions
+ *
+ **********************************************************************/
+
+int __init mipv6_bul_init(__u32 size)
+{
+	DEBUG_FUNC();
+
+	if (size < 1) {
+		DEBUG(DBG_CRITICAL, 
+		      "Binding update list size must be at least 1");
+		return -EINVAL;
+	}
+	bul.entries = hashlist_create(MIPV6_BUL_HASHSIZE, size, 
+				       sizeof(struct mipv6_bul_entry),
+				       "mip6_bul", NULL, NULL,
+				       bul_compare, 
+				       bul_hash, bul_hashkey);
+
+	if (bul.entries == NULL) {
+		DEBUG(DBG_CRITICAL, "Couldn't allocate memory for "
+		      "hashlist when creating a binding update list");
+		return -ENOMEM;
+	}
+	init_timer(&bul.callback_timer);
+	bul.callback_timer.data = 0;
+	bul.callback_timer.function = timer_handler;
+	proc_net_create("mip6_bul", 0, bul_proc_info);
+	DEBUG(DBG_INFO, "Binding update list initialized");
+	return 0;
+}
+
+void __exit mipv6_bul_exit()
+{
+	struct mipv6_bul_entry *entry;
+	struct hashlist *entries;
+
+	DEBUG_FUNC();
+
+	proc_net_remove("mip6_bul");
+
+	write_lock_bh(&bul_lock);
+
+	DEBUG(DBG_INFO, "Stopping the bul timer");
+	del_timer(&bul.callback_timer);
+
+	while ((entry = (struct mipv6_bul_entry *) 
+		hashlist_get_first(bul.entries)) != NULL) {
+		hashlist_delete(bul.entries, (void *)entry);
+		
+		del_bul_entry_tnl(entry);
+		
+		mipv6_bul_entry_free(entry);
+	}
+	entries = bul.entries;
+	bul.entries = NULL;
+	write_unlock_bh(&bul_lock); 
+
+	hashlist_destroy(entries);
+
+	DEBUG(DBG_INFO, "binding update list destroyed");
+}
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/bul.h linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/bul.h
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/bul.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/bul.h	2003-05-18 11:33:53.000000000 +0200
@@ -0,0 +1,115 @@
+/*
+ *      Binding Update List header file
+ *
+ *      Authors:
+ *      Juha Mynttinen            <jmynttin@cc.hut.fi>
+ *
+ *      $Id: s.bul.h 1.21 02/11/25 11:18:16+02:00 vnuorval@amber.hut.mediapoli.com $
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef _BUL_H
+#define _BUL_H
+
+#include "hashlist.h"
+
+#define ACK_OK          0x01
+#define RESEND_EXP      0x02
+#define ACK_ERROR       0x04
+
+#define HOME_RESEND_EXPIRE 3600
+#define MIPV6_COOKIE_LEN 8
+struct mipv6_rr_info {
+	/* RR information */
+	u16 rr_state;                /* State of the RR */
+	u16 rr_flags;                /* Flags for the RR */
+	u8 hot_cookie[MIPV6_COOKIE_LEN];    /* HoT Cookie */
+	u8 cot_cookie[MIPV6_COOKIE_LEN];    /* CoT Cookie */
+	u8 home_cookie[MIPV6_COOKIE_LEN];   /* Home Cookie */
+	u8 careof_cookie[MIPV6_COOKIE_LEN]; /* Careof Cookie */
+	u32 lastsend_hoti;	      /* When HoTI was last sent (jiffies) */
+	u32 lastsend_coti;            /* When CoTI was last sent (jiffies) */
+	u32 home_time;	              /* when Care-of cookie was received */
+	u32 careof_time;	      /* when Home cookie was received */
+	int home_nonce_index;         /* Home cookie nonce index */
+	int careof_nonce_index;       /* Care-of cookie nonce index */
+	u8 *kbu;                      /* Binding authentication key */
+};
+struct mipv6_bul_entry {
+	struct hashlist_entry e;
+	struct in6_addr cn_addr;      /* CN to which BU was sent */
+	struct in6_addr home_addr;    /* home address of this binding */
+	struct in6_addr coa;          /* care-of address of the sent BU */
+
+	unsigned long expire;         /* expiration time of this entry (jiffies) */ 
+	__u32 lifetime;               /* lifetime sent in this BU */
+	__u32 lastsend;               /* last time when BU was sent (jiffies) */
+	__u32 consecutive_sends;      /* Number of consecutive BU's sent */
+	__u8 flags;		      /* BU send flags */
+	__u8 seq;                     /* sequence number of the latest BU */
+	__u8 prefix;                  /* Prefix length */
+	
+	    /* Session key */
+	struct mipv6_mh_opt *ops;     /* saved option values */
+	
+  	/* retransmission info */
+	__u8 state;
+	__u32 initdelay;
+	__u32 delay;
+	__u32 maxdelay;
+	struct mipv6_rr_info *rr;
+	unsigned long callback_time;
+	int (*callback)(struct mipv6_bul_entry *entry);
+};
+
+extern rwlock_t bul_lock;
+/* Values for rr_state */
+
+#define IDLE		0x00
+#define RR_REDO		0x02
+#define RR_DEL		0x04
+#define RR_WAITA	0x08
+#define RR_WAITAR	0x10
+#define RR_WAITD	0x20
+#define BOUND		0x40
+
+#define RR_START	0x80
+
+int mipv6_bul_init(__u32 size);
+
+void mipv6_bul_exit(void);
+
+struct mipv6_bul_entry *mipv6_bul_add(
+	struct in6_addr *cn_addr,
+	struct in6_addr *home_addr,
+	struct in6_addr *coa,
+	__u32 lifetime,
+	__u8 seq,
+	__u8 prefix,
+	__u8 flags,
+	int (*callback)(struct mipv6_bul_entry *entry),
+	__u32 callback_time,
+	__u8 state,
+	__u32 delay,
+	__u32 maxdelay,
+	struct mipv6_mh_opt *ops,
+	struct mipv6_rr_info *rr);
+
+int mipv6_bul_delete(struct in6_addr *cn_addr, 
+		     struct in6_addr *home_addr);
+
+int mipv6_bul_exists(struct in6_addr *cnaddr, struct in6_addr *home_addr);
+
+struct mipv6_bul_entry *mipv6_bul_get(struct in6_addr *cnaddr,
+				      struct in6_addr *home_addr);
+
+void mipv6_bul_reschedule(struct mipv6_bul_entry *entry);
+
+int bul_iterate(int (*func)(void *, void *, unsigned long *), void *args);
+
+#endif /* BUL_H */
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/config.h linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/config.h
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/config.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/config.h	2003-05-18 11:33:53.000000000 +0200
@@ -0,0 +1,14 @@
+/*
+ * Configuration parameters
+ *
+ * $Id$
+ */
+
+#define MIPV6VERSION "D19"
+#define MIPLVERSION "v0.9.5.1"
+
+#define CAP_CN	0x01
+#define CAP_HA	0x02
+#define CAP_MN	0x04
+
+extern int mipv6_cap;
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/dad.c linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/dad.c
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/dad.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/dad.c	2003-05-18 11:33:53.000000000 +0200
@@ -0,0 +1,588 @@
+/*
+ *	Mobile IPv6 Duplicate Address Detection Functions
+ *
+ *	Authors:
+ *	Krishna Kumar <krkumar@us.ibm.com>
+ *
+ *      $Id$
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/autoconf.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/skbuff.h>
+#include <linux/in6.h>
+#include <net/ipv6.h>
+#include <net/addrconf.h>
+#include <net/mipv6.h>
+
+#include "debug.h"
+#include "bcache.h"
+#include "ha.h" /* mipv6_generate_ll_addr */
+
+extern void mipv6_bu_finish(
+	struct inet6_ifaddr *ifp, __u8 ba_status,
+	__u32 ba_lifetime, __u32 ba_refresh,
+	__u32 maxdelay, int plength, __u16 sequence,
+	struct in6_addr *saddr, struct in6_addr *daddr,
+	struct in6_addr *haddr, struct in6_addr *coa,
+	int ifindex, int single, __u8 *k_bu);
+
+/*
+ * Binding Updates from MN are cached in this structure till DAD is performed.
+ * This structure is used to retrieve a pending Binding Update for the HA to
+ * reply to after performing DAD. The first cell is different from the rest as
+ * follows :
+ * 	1. The first cell is used to chain the remaining cells. 
+ *	2. The timeout of the first cell is used to delete expired entries
+ *	   in the list of cells, while the timeout of the other cells are
+ *	   used for timing out a NS request so as to reply to a BU.
+ *	3. The only elements of the first cell that are used are :
+ *	   next, prev, and callback_timer.
+ *
+ * TODO : Don't we need to do pneigh_lookup on the Link Local address ?
+ */
+struct mipv6_dad_cell {
+	/* Information needed for DAD management */
+	struct mipv6_dad_cell	*next;	/* Next element on the DAD list */
+	struct mipv6_dad_cell	*prev;	/* Prev element on the DAD list */
+	__u16			probes;	/* Number of times to probe for addr */
+	__u16			flags;	/* Entry flags - see below */
+	struct timer_list	callback_timer; /* timeout for entry */
+
+	/* Information needed for performing DAD */
+	struct inet6_ifaddr	*ifp;
+	int			ifindex;
+	struct in6_addr		saddr;
+	struct in6_addr		daddr;
+	struct in6_addr		haddr;		/* home address */
+	struct in6_addr		ll_haddr;	/* Link Local value of haddr */
+	struct in6_addr		coa;
+	__u32			ba_lifetime;
+	int			plength;
+	__u16			sequence;
+	int			single;
+};
+
+/* Values for the 'flags' field in the mipv6_dad_cell */
+#define	DAD_INIT_ENTRY		0
+#define	DAD_DUPLICATE_ADDRESS	1
+#define	DAD_UNIQUE_ADDRESS	2
+
+/* Head of the pending DAD list */
+static struct mipv6_dad_cell dad_cell_head;
+
+/* Lock to access the pending DAD list */
+static rwlock_t dad_lock = RW_LOCK_UNLOCKED;
+
+/* Timer routine which deletes 'expired' entries in the DAD list */
+static void mipv6_dad_delete_old_entries(unsigned long unused)
+{
+	struct mipv6_dad_cell *curr, *next;
+	unsigned long next_time = 0;
+
+	write_lock(&dad_lock);
+	curr = dad_cell_head.next;
+	while (curr != &dad_cell_head) {
+		next = curr->next;
+		if (curr->flags != DAD_INIT_ENTRY) {
+			if (curr->callback_timer.expires <= jiffies) {
+				/* Entry has expired, free it up. */
+				curr->next->prev = curr->prev;
+				curr->prev->next = curr->next;
+				kfree(curr);
+			} else if (next_time <
+				   curr->callback_timer.expires) {
+				next_time = curr->callback_timer.expires;
+			}
+		}
+		curr = next;
+	}
+	write_unlock(&dad_lock);
+	if (next_time) {
+		/*
+		 * Start another timer if more cells need to be removed at
+		 * a later stage.
+		 */
+		dad_cell_head.callback_timer.expires = next_time;
+		add_timer(&dad_cell_head.callback_timer);
+	}
+}
+
+/* 
+ * Queue a timeout routine to clean up 'expired' DAD entries.
+ */
+static void mipv6_start_dad_head_timer(struct mipv6_dad_cell *cell)
+{
+	unsigned long expire = jiffies +
+	    cell->ifp->idev->nd_parms->retrans_time * 10;
+
+	if (!timer_pending(&dad_cell_head.callback_timer) ||
+	    expire < dad_cell_head.callback_timer.expires) {
+		/*
+		 * Add timer if none pending, or mod the timer if new 
+		 * cell needs to be expired before existing timer runs.
+		 *
+		 * We let the cell remain as long as possible, so that
+		 * new BU's as part of retransmissions don't have to go
+		 * through DAD before replying.
+		 */
+		dad_cell_head.callback_timer.expires = expire;
+
+		/*
+		 * Keep the cell around for atleast some time to handle
+		 * retransmissions or BU's due to fast MN movement. This
+		 * is needed otherwise a previous timeout can delete all
+		 * expired entries including this new one.
+		 */
+		cell->callback_timer.expires = jiffies +
+		    cell->ifp->idev->nd_parms->retrans_time * 5;
+		if (!timer_pending(&dad_cell_head.callback_timer)) {
+			add_timer(&dad_cell_head.callback_timer);
+		} else {
+			mod_timer(&dad_cell_head.callback_timer, expire);
+		}
+	}
+}
+
+
+/* Join solicited node MC address */
+static inline void mipv6_join_sol_mc_addr(struct in6_addr *addr,
+					  struct net_device *dev)
+{
+	struct in6_addr maddr;
+
+	/* Join solicited node MC address */
+	addrconf_addr_solict_mult(addr, &maddr);
+	ipv6_dev_mc_inc(dev, &maddr);
+}
+
+/* Leave solicited node MC address */
+static inline void mipv6_leave_sol_mc_addr(struct in6_addr *addr,
+					   struct net_device *dev)
+{
+	struct in6_addr maddr;
+
+	addrconf_addr_solict_mult(addr, &maddr);
+	ipv6_dev_mc_dec(dev, &maddr);
+}
+
+/* Send a NS */
+static inline void mipv6_dad_send_ns(struct inet6_ifaddr *ifp,
+				     struct in6_addr *haddr)
+{
+	struct in6_addr unspec;
+	struct in6_addr mcaddr;
+
+	ipv6_addr_set(&unspec, 0, 0, 0, 0);
+	addrconf_addr_solict_mult(haddr, &mcaddr);
+
+	/* addr is 'unspec' since we treat this address as transient */
+	ndisc_send_ns(ifp->idev->dev, NULL, haddr, &mcaddr, &unspec);
+}
+
+/*
+ * Search for a home address in the list of pending DAD's. Called from
+ * Neighbor Advertisement
+ * Return values :
+ * 	-1 : No DAD entry found for this advertisement, or entry already
+ *	     finished processing.
+ *	0  : Entry found waiting for DAD to finish.
+ */
+static int dad_search_haddr(struct in6_addr *ll_haddr,
+			    struct in6_addr *saddr, struct in6_addr *daddr,
+			    struct in6_addr *haddr, struct in6_addr *coa,
+			    __u16 * seq, struct inet6_ifaddr *ifp)
+{
+	struct mipv6_dad_cell *cell;
+
+	read_lock(&dad_lock);
+	cell = dad_cell_head.next;
+	while (cell != &dad_cell_head &&
+	       ipv6_addr_cmp(&cell->ll_haddr, ll_haddr)) {
+		cell = cell->next;
+	}
+	if (cell == &dad_cell_head || cell->flags != DAD_INIT_ENTRY) {
+		/* Not found element, or element already finished processing */
+		if (cell != &dad_cell_head) {
+			/*
+			 * Set the state to DUPLICATE, even if it was UNIQUE
+			 * earlier. It is not needed to setup timer via 
+			 * mipv6_start_dad_head_timer since this must have
+			 * already been done.
+			 */
+			cell->flags = DAD_DUPLICATE_ADDRESS;
+		}
+		read_unlock(&dad_lock);
+		return -1;
+	}
+
+	/*
+	 * The NA found an unprocessed entry in the DAD list. Expire this
+	 * entry since another node advertised this address. Caller should
+	 * reject BU (DAD failed).
+	 */
+	ipv6_addr_copy(saddr, &cell->saddr);
+	ipv6_addr_copy(daddr, &cell->daddr);
+	ipv6_addr_copy(haddr, &cell->haddr);
+	ipv6_addr_copy(coa, &cell->coa);
+	*seq = cell->sequence;
+	*ifp = *cell->ifp;
+
+	if (del_timer(&cell->callback_timer) == 0) {
+		/* Timer already deleted, race with Timeout Handler */
+		/* No action needed */
+	}
+
+	cell->flags = DAD_DUPLICATE_ADDRESS;
+
+	/* Now leave this address to avoid future processing of NA's */
+	mipv6_leave_sol_mc_addr(&cell->ll_haddr, cell->ifp->idev->dev);
+
+	/* Start dad_head timer to remove this entry */
+	mipv6_start_dad_head_timer(cell);
+
+	read_unlock(&dad_lock);
+
+	return 0;
+}
+
+/* ENTRY routine called via Neighbor Advertisement */
+void mipv6_check_dad(struct in6_addr *ll_haddr)
+{
+	struct in6_addr saddr, daddr, haddr, coa;
+	struct inet6_ifaddr ifp;
+	__u16 seq;
+
+	if (dad_search_haddr(ll_haddr, &saddr, &daddr, &haddr, &coa, &seq,
+			     &ifp) < 0) {
+		/* 
+		 * Didn't find entry, or no action needed (the action has
+		 * already been performed).
+		 */
+		return;
+	}
+
+	/*
+	 * A DAD cell was present, meaning that there is a pending BU
+	 * request for 'haddr' - reject the BU.
+	 */
+	mipv6_bu_finish(&ifp, DUPLICATE_ADDR_DETECT_FAIL, 0, 0, 0, 0, seq,
+			&saddr, &daddr, &haddr, &coa, 0, 0, NULL);
+	return;
+}
+
+/*
+ * Check if the passed 'cell' is in the list of pending DAD's. Called from
+ * the Timeout Handler.
+ *
+ * Assumes that the caller is holding the dad_lock in reader mode.
+ */
+static int dad_search_cell(struct mipv6_dad_cell *cell)
+{
+	struct mipv6_dad_cell *tmp;
+
+	tmp = dad_cell_head.next;
+	while (tmp != &dad_cell_head && tmp != cell) {
+		tmp = tmp->next;
+	}
+	if (tmp == cell) {
+		if (cell->flags == DAD_INIT_ENTRY) {
+			/* Found valid entry */
+			if (--cell->probes == 0) {
+				/*
+				 * Retransmission's are over - return success.
+				 */
+				cell->flags = DAD_UNIQUE_ADDRESS;
+
+				/* 
+				 * Leave this address to avoid future 
+				 * processing of NA's.
+				 */
+				mipv6_leave_sol_mc_addr(&cell->ll_haddr,
+							cell->ifp->idev->
+							dev);
+
+				/* start timeout to delete this cell. */
+				mipv6_start_dad_head_timer(cell);
+				return 0;
+			}
+			/*
+			 * Retransmission not finished, send another NS and
+			 * return failure.
+			 */
+			mipv6_dad_send_ns(cell->ifp, &cell->ll_haddr);
+			cell->callback_timer.expires = jiffies +
+			    cell->ifp->idev->nd_parms->retrans_time;
+			add_timer(&cell->callback_timer);
+		} else {
+			/*
+			 * This means that an NA was received before the
+			 * timeout and when the state changed from
+			 * DAD_INIT_ENTRY, the BU got failed as a result.
+			 * There is nothing to be done.
+			 */
+		}
+	}
+	return -1;
+}
+
+/* ENTRY routine called via Timeout */
+static void mipv6_dad_timeout(unsigned long arg)
+{
+	__u8 ba_status = SUCCESS;
+	__u32 ba_refresh = 0;
+	__u32 maxdelay = 0;
+	struct in6_addr saddr;
+	struct in6_addr daddr;
+	struct in6_addr haddr;
+	struct in6_addr coa;
+	struct inet6_ifaddr *ifp;
+	int ifindex;
+	__u32 ba_lifetime;
+	int plength;
+	__u16 sequence;
+	int single;
+	struct mipv6_dad_cell *cell = (struct mipv6_dad_cell *) arg;
+
+	/*
+	 * If entry is not in the list, we have already sent BU Failure
+	 * after getting a NA.
+	 */
+	read_lock(&dad_lock);
+	if (dad_search_cell(cell) < 0) {
+		/*
+		 * 'cell' is no longer valid (may not be in the list or
+		 * is already processed, due to NA processing), or NS
+		 * retransmissions are not yet over.
+		 */
+		read_unlock(&dad_lock);
+		return;
+	}
+
+	/* This is the final Timeout. Send Bind Ack Success */
+
+	ifp = cell->ifp;
+	ifindex = cell->ifindex;
+	ba_lifetime = cell->ba_lifetime;
+	plength = cell->plength;
+	sequence = cell->sequence;
+	single = cell->single;
+
+	ipv6_addr_copy(&saddr, &cell->saddr);
+	ipv6_addr_copy(&daddr, &cell->daddr);
+	ipv6_addr_copy(&haddr, &cell->haddr);
+	ipv6_addr_copy(&coa, &cell->coa);
+	read_unlock(&dad_lock);
+
+	/* Send BU Acknowledgement Success */
+	mipv6_bu_finish(ifp, ba_status, ba_lifetime, ba_refresh,
+			maxdelay, plength, sequence, &saddr, &daddr,
+			&haddr, &coa, ifindex, single, NULL);
+	return;
+}
+
+/*
+ * Check if original home address exists in our DAD pending list, if so return
+ * the cell.
+ *
+ * Assumes that the caller is holding the dad_lock in writer mode.
+ */
+static struct mipv6_dad_cell *mipv6_dad_get_cell(struct in6_addr *haddr)
+{
+	struct mipv6_dad_cell *cell;
+
+	cell = dad_cell_head.next;
+	while (cell != &dad_cell_head
+	       && ipv6_addr_cmp(&cell->haddr, haddr)) {
+		cell = cell->next;
+	}
+	if (cell == &dad_cell_head) {
+		/* Not found element */
+		return NULL;
+	}
+	return cell;
+}
+
+/*
+ * Save all parameters needed for doing a Bind Ack in the mipv6_dad_cell 
+ * structure.
+ */
+static void mipv6_dad_save_cell(struct mipv6_dad_cell *cell,
+				struct inet6_ifaddr *ifp, int ifindex,
+				struct in6_addr *saddr,
+				struct in6_addr *daddr,
+				struct in6_addr *haddr,
+				struct in6_addr *coa, __u32 ba_lifetime,
+				int plength, __u16 sequence, int single)
+{
+	cell->ifp = ifp;	/* ifp is held, so cache it for future use */
+	cell->ifindex = ifindex;
+
+	ipv6_addr_copy(&cell->saddr, saddr);
+	ipv6_addr_copy(&cell->daddr, daddr);
+	ipv6_addr_copy(&cell->haddr, haddr);
+	ipv6_addr_copy(&cell->coa, coa);
+
+	/* Convert cell->ll_haddr to Link Local address */
+	mipv6_generate_ll_addr(&cell->ll_haddr, haddr);
+
+	cell->ba_lifetime = ba_lifetime;
+	cell->plength = plength;
+	cell->sequence = sequence;
+	cell->single = single;
+}
+
+/*
+ * Top level DAD routine for performing DAD.
+ *
+ * Return values
+ *	0     : Don't need to do DAD.
+ *	1     : Need to do DAD.
+ *	-n    : Error, where 'n' is the reason for the error.
+ *
+ * Assumption : DAD process has been optimized by using cached values upto
+ * some time. However sometimes this can cause problems. Eg. when the first
+ * BU was received, DAD might have failed. Before the second BU arrived,
+ * the node using MN's home address might have stopped using it, but still
+ * we will return DAD_DUPLICATE_ADDRESS based on the first DAD's result. Or 
+ * this can go the other way around. However, it is a very small possibility
+ * and thus optimization is turned on by default. It is possible to change
+ * this feature (needs a little code-rewriting in this routine), but 
+ * currently DAD result is being cached for performance reasons.
+ */
+int mipv6_dad_start(struct inet6_ifaddr *ifp, int ifindex,
+		    struct in6_addr *saddr, struct in6_addr *daddr,
+		    struct in6_addr *haddr, struct in6_addr *coa,
+		    __u32 ba_lifetime, int plength, __u16 sequence,
+		    int single)
+{
+	int found;
+	struct mipv6_dad_cell *cell;
+	struct mipv6_bcache_entry bc_entry;
+
+	if (ifp->idev->cnf.dad_transmits == 0) {
+		/* DAD is not configured on the HA, return SUCCESS */
+		return 0;
+	}
+
+	if (mipv6_bcache_get(haddr, daddr, &bc_entry) == 0) {
+		/*
+		 * We already have an entry in our cache - don't need to 
+		 * do DAD as we are already defending this home address.
+		 */
+		return 0;
+	}
+
+	write_lock(&dad_lock);
+	if ((cell = mipv6_dad_get_cell(haddr)) != NULL) {
+		/*
+		 * An existing entry for BU was found in our cache due
+		 * to retransmission of the BU or a new COA registration.
+		 */
+		switch (cell->flags) {
+		case DAD_INIT_ENTRY:
+			/* Old entry is waiting for DAD to complete */
+			break;
+		case DAD_UNIQUE_ADDRESS:
+			/* DAD is finished successfully - return success. */
+			write_unlock(&dad_lock);
+			return 0;
+		case DAD_DUPLICATE_ADDRESS:
+			/*
+			 * DAD is finished and we got a NA while doing BU -
+			 * return failure.
+			 */
+			write_unlock(&dad_lock);
+			return -DUPLICATE_ADDR_DETECT_FAIL;
+		default:
+			/* Unknown state - should never happen */
+			DEBUG(DBG_WARNING,
+			      "cell entry in unknown state : %d",
+			      cell->flags);
+			write_unlock(&dad_lock);
+			return -REASON_UNSPECIFIED;
+		}
+		found = 1;
+	} else {
+		if ((cell = (struct mipv6_dad_cell *)
+		     kmalloc(sizeof(struct mipv6_dad_cell), GFP_ATOMIC))
+		    == NULL) {
+			return -INSUFFICIENT_RESOURCES;
+		}
+		found = 0;
+	}
+
+	mipv6_dad_save_cell(cell, ifp, ifindex, saddr, daddr, haddr, coa,
+			    ba_lifetime, plength, sequence, single);
+
+	if (!found) {
+		cell->flags = DAD_INIT_ENTRY;
+		cell->probes = ifp->idev->cnf.dad_transmits;
+
+		/* Insert element on dad_cell_head list */
+		dad_cell_head.prev->next = cell;
+		cell->next = &dad_cell_head;
+		cell->prev = dad_cell_head.prev;
+		dad_cell_head.prev = cell;
+		write_unlock(&dad_lock);
+
+		/* join the solicited node MC of the homeaddr. */
+		mipv6_join_sol_mc_addr(&cell->ll_haddr, ifp->idev->dev);
+
+		/* Send a NS */
+		mipv6_dad_send_ns(ifp, &cell->ll_haddr);
+
+		/* Initialize timer for this cell to timeout the NS. */
+		init_timer(&cell->callback_timer);
+		cell->callback_timer.data = (unsigned long) cell;
+		cell->callback_timer.function = mipv6_dad_timeout;
+		cell->callback_timer.expires = jiffies +
+		    ifp->idev->nd_parms->retrans_time;
+		add_timer(&cell->callback_timer);
+	} else {
+		write_unlock(&dad_lock);
+	}
+	return 1;
+}
+
+void __init mipv6_dad_init(void)
+{
+	dad_cell_head.next = dad_cell_head.prev = &dad_cell_head;
+	init_timer(&dad_cell_head.callback_timer);
+	dad_cell_head.callback_timer.data = 0;
+	dad_cell_head.callback_timer.function =
+	    mipv6_dad_delete_old_entries;
+}
+
+void __exit mipv6_dad_exit(void)
+{
+	struct mipv6_dad_cell *curr, *next;
+
+	write_lock_bh(&dad_lock);
+	del_timer(&dad_cell_head.callback_timer);
+
+	curr = dad_cell_head.next;
+	while (curr != &dad_cell_head) {
+		next = curr->next;
+		del_timer(&curr->callback_timer);
+		if (curr->flags == DAD_INIT_ENTRY) {
+			/*
+			 * We were in DAD_INIT state and listening to the
+			 * solicited node MC address - need to stop that.
+			 */
+			mipv6_leave_sol_mc_addr(&curr->ll_haddr,
+						curr->ifp->idev->dev);
+		}
+		kfree(curr);
+		curr = next;
+	}
+	dad_cell_head.next = dad_cell_head.prev = &dad_cell_head;
+	write_unlock_bh(&dad_lock);
+}
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/debug.h linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/debug.h
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/debug.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/debug.h	2003-05-18 11:33:53.000000000 +0200
@@ -0,0 +1,99 @@
+/*
+ *      MIPv6 Debugging macros and functions
+ *
+ *      Authors:
+ *      Antti Tuominen              <ajtuomin@tml.hut.fi>
+ *      Sami Kivisaari               <skivisaa@cc.hut.fi>
+ *
+ *      $Id: s.debug.h 1.15 02/12/09 07:53:53-02:00 henkku@mart10.hut.mediapoli.com $
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef _DEBUG_H
+#define _DEBUG_H
+
+#include <linux/autoconf.h>
+
+/* priorities for different debug conditions */
+
+#define DBG_CRITICAL   0 /* unrecoverable error                     */
+#define DBG_ERROR      1 /* error (recoverable)                     */
+#define DBG_WARNING    2 /* unusual situation but not a real error  */
+#define DBG_INFO       3 /* generally useful information            */
+#define DBG_EXTRA      4 /* extra information                       */
+#define DBG_FUNC_ENTRY 6 /* use to indicate function entry and exit */
+#define DBG_DATADUMP   7 /* packet dumps, etc. lots of flood        */
+
+#ifdef CONFIG_IPV6_MOBILITY_DEBUG
+extern int mipv6_debug;
+
+/**
+ * debug_print - print debug message
+ * @debug_level: message priority
+ * @fname: calling function's name
+ * @fmt: printf-style formatting string
+ *
+ * Prints a debug message to system log if @debug_level is less or
+ * equal to @mipv6_debug.  Should always be called using DEBUG()
+ * macro, not directly.
+ **/
+static void debug_print(int debug_level, const char *fname, const char* fmt, ...)
+{
+	char s[1024];
+	va_list args;
+ 
+	if (mipv6_debug < debug_level)
+		return;
+ 
+	va_start(args, fmt);
+	vsprintf(s, fmt, args);
+	printk("mip6[%s]: %s\n", fname, s);
+	va_end(args);
+}
+
+/**
+ * debug_print_buffer - print arbitrary buffer to system log
+ * @debug_level: message priority
+ * @data: pointer to buffer
+ * @len: number of bytes to print
+ *
+ * Prints @len bytes from buffer @data to system log.  @debug_level
+ * tells on which debug level message gets printed.  For
+ * debug_print_buffer() priority %DBG_DATADUMP should be used.
+ **/
+#define debug_print_buffer(debug_level,data,len) { \
+	if (mipv6_debug >= debug_level) { \
+	int i; \
+	for (i=0; i<len; i++) { \
+		if (i%16 == 0) printk("\n%04x: ", i); \
+		printk("%02x ", ((unsigned char *)data)[i]); \
+	} \
+	printk("\n\n"); \
+	} \
+}
+
+#define DEBUG(x,y,z...) debug_print(x,__FUNCTION__,y,##z)
+#define DEBUG_FUNC() \
+DEBUG(DBG_FUNC_ENTRY, "%s(%d)/%s: ", __FILE__,__LINE__,__FUNCTION__)
+
+#else
+#define DEBUG(x,y,z...)
+#define DEBUG_FUNC()
+#define debug_print_buffer(x,y,z)
+#endif
+
+#undef ASSERT
+#define ASSERT(expression) { \
+        if (!(expression)) { \
+                (void)printk(KERN_ERR \
+                 "Assertion \"%s\" failed: file \"%s\", function \"%s\", line %d\n", \
+                 #expression, __FILE__, __FUNCTION__, __LINE__); \
+        } \
+}
+
+#endif /* _DEBUG_H */
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/exthdrs.c linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/exthdrs.c
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/exthdrs.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/exthdrs.c	2003-05-18 11:33:53.000000000 +0200
@@ -0,0 +1,350 @@
+/*
+ *	Extension Header handling and adding code
+ *
+ *	Authors:
+ *	Sami Kivisaari		<skivisaa@cc.hut.fi>	
+ *
+ *	$Id: s.exthdrs.c 1.65 02/12/19 13:43:17+02:00 antti@jon.mipl.mediapoli.com $
+ *
+ *	This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/types.h>
+#include <linux/slab.h>
+
+#include <net/ipv6.h>
+#include <net/ip6_route.h>
+#include <net/addrconf.h>
+#include <net/mipv6.h>
+
+#include "debug.h"
+#include "stats.h"
+#include "mobhdr.h"
+#include "bcache.h"
+#include "util.h"
+#include "mn.h"
+
+/**
+ * mipv6_append_home_addr - Add Home Address Option
+ * @opt: buffer for Home Address Option
+ * @offset: offset from beginning of @opt
+ * @addr: address for HAO
+ *
+ * Adds a Home Address Option to a packet.  Option is stored in
+ * @offset from beginning of @opt.  The option is created but the
+ * original source address in IPv6 header is left intact.  The source
+ * address will be changed from home address to CoA after the checksum
+ * has been calculated in getfrag.  Padding is done automatically, and
+ * @opt must have allocated space for both actual option and pad.
+ * Returns offset from @opt to end of options.
+ **/
+int mipv6_append_home_addr(__u8 *opt, int offset, struct in6_addr *addr)
+{
+	int pad;
+	struct mipv6_dstopt_homeaddr *ho;
+
+	DEBUG(DBG_INFO, "HAO: %x:%x:%x:%x:%x:%x:%x:%x",
+	      NIPV6ADDR(addr));
+
+	pad = (6 - offset) & 7;
+	mipv6_add_pad(opt + offset, pad);
+
+	ho = (struct mipv6_dstopt_homeaddr *)(opt + offset + pad);
+	ho->type = MIPV6_TLV_HOMEADDR;
+	ho->length = sizeof(*ho) - 2;
+	ipv6_addr_copy(&ho->addr, addr); 
+
+	return offset + pad + sizeof(*ho);
+}
+
+/**
+ * mipv6_handle_homeaddr - Home Address Destination Option handler
+ * @skb: packet buffer
+ * @optoff: offset to where option begins
+ *
+ * Handles Home Address Option in IPv6 Destination Option header.
+ * Packet and offset to option are passed.  If HAO is used without
+ * binding, sends a Binding Error code 1.  When sending BE, notify bit
+ * is cleared to prevent IPv6 error handling from sending ICMP
+ * Parameter Problem.  Returns 1 on success, otherwise zero.
+ **/
+int mipv6_handle_homeaddr(struct sk_buff *skb, int optoff)
+{
+	struct in6_addr *saddr = &(skb->nh.ipv6h->saddr);
+	struct in6_addr coaddr;
+	struct inet6_skb_parm *opt = (struct inet6_skb_parm *) skb->cb;
+	struct mipv6_dstopt_homeaddr *haopt =
+	    (struct mipv6_dstopt_homeaddr *) &skb->nh.raw[optoff];
+	struct mipv6_bcache_entry bc_entry;
+	u8 *dst1;
+
+	DEBUG_FUNC();
+
+	if (haopt->length != sizeof(*haopt) - 2) {
+		DEBUG(DBG_WARNING, "HAO has invalid length");
+		MIPV6_INC_STATS(n_ha_drop.invalid);
+		return 0;
+	}
+	ipv6_addr_copy(&coaddr, saddr);
+	ipv6_addr_copy(saddr, &haopt->addr);
+	ipv6_addr_copy(&haopt->addr, &coaddr);
+	dst1 = (u8 *)skb->h.raw;
+	if (dst1[0] != IPPROTO_MOBILITY && 
+	    mipv6_bcache_get(saddr, &skb->nh.ipv6h->daddr, &bc_entry) != 0) {
+		DEBUG(DBG_INFO, "HAO without binding, sending BE code 1: "
+		      "home address %x:%x:%x:%x:%x:%x:%x:%x",
+		      NIPV6ADDR(saddr));
+		haopt->type &= ~(0x80); /* clear notify bit */
+		mipv6_send_be(&skb->nh.ipv6h->daddr, &coaddr, saddr,
+			      MIPV6_BE_HAO_WO_BINDING);
+		MIPV6_INC_STATS(n_ha_drop.misc);
+		return 0;
+	}
+	opt->hao = optoff + 2;
+	mipv6_check_tunneled_packet(skb);
+
+	MIPV6_INC_STATS(n_ha_rcvd);
+	return 1;
+}
+
+/**
+ * mipv6_icmp_handle_homeaddr - Switch HAO and source for ICMP errors
+ * @skb: packet buffer
+ *
+ * Reset the source address and the Home Address option in skb before
+ * appending it to an ICMP error message, so original packet appears
+ * in the error message rather than mangled.
+ **/
+void mipv6_icmp_handle_homeaddr(struct sk_buff *skb)
+{
+	struct inet6_skb_parm *opt = (struct inet6_skb_parm *)skb->cb;
+
+	DEBUG_FUNC();
+
+	if (opt->hao) {
+		struct in6_addr tmp;
+		struct in6_addr *ha = 
+			(struct in6_addr *)(skb->nh.raw + opt->hao);
+
+		ipv6_addr_copy(&tmp, ha);
+		ipv6_addr_copy(ha, &skb->nh.ipv6h->saddr);
+		ipv6_addr_copy(&skb->nh.ipv6h->saddr, &tmp);
+	}
+}
+
+/**
+ * mipv6_append_rt2hdr - Add Type 2 Routing Header
+ * @rt: buffer for new routing header
+ * @addr: intermediate hop address
+ *
+ * Adds a Routing Header Type 2 in a packet.  Stores newly created
+ * routing header in buffer @rt.  Type 2 RT only carries one address,
+ * so there is no need to process old routing header.  @rt must have
+ * allocated space for 24 bytes.
+ **/
+void mipv6_append_rt2hdr(struct ipv6_rt_hdr *rt, struct in6_addr *addr)
+{
+	struct rt2_hdr *rt2 = (struct rt2_hdr *)rt;
+
+        DEBUG(DBG_INFO, "RT2: %x:%x:%x:%x:%x:%x:%x:%x",
+	      NIPV6ADDR(addr));
+
+	if (ipv6_addr_type(addr) == IPV6_ADDR_MULTICAST) {
+		DEBUG(DBG_ERROR, "destination address not unicast");
+		return;
+	}
+
+	memset(rt2, 0, sizeof(*rt2));
+	rt2->rt_hdr.type = 2;
+	rt2->rt_hdr.hdrlen = 2;
+	rt2->rt_hdr.segments_left = 1;
+	ipv6_addr_copy(&rt2->addr, addr);
+}
+
+/**
+ * mipv6_append_dst1opts - Add Destination Option (1) Headers
+ * @dst1opt: buffer for new destination options
+ * @saddr: address for Home Address Option
+ * @old_dst1opt: old destination options
+ * @len: length of options
+ *
+ * Adds Destination Option (1) Header to a packet.  New options are
+ * stored in @dst1opt.  If old destination options exist, they are
+ * copied from @old_dst1opt.  Only Home Address Option is destination
+ * option.  @dstopt must have allocated space for @len bytes.  @len
+ * includes Destination Option Header (2 bytes), Home Address Option
+ * (18 bytes) and possible HAO pad (8n+6).
+ **/
+/*
+ * ISSUE: Home Address Destination Option should really be added to a
+ * new destination option header specified in Mobile IPv6 spec which
+ * should be placed after routing header(s), but before fragmentation
+ * header.  Putting HAO in DO1 works for now, but support for the new
+ * placement should be added to the IPv6 stack.
+ */
+void 
+mipv6_append_dst1opts(struct ipv6_opt_hdr *dst1opt, struct in6_addr *saddr,
+		      struct ipv6_opt_hdr *old_dst1opt, int len)
+{
+	int offset;
+
+	if (old_dst1opt) {
+		memcpy(dst1opt, old_dst1opt, ipv6_optlen(old_dst1opt));
+		offset = ipv6_optlen(old_dst1opt);
+	} else {
+		offset = sizeof (*dst1opt);
+	}
+	dst1opt->hdrlen = (len >> 3) - 1;
+	mipv6_append_home_addr((__u8 *) dst1opt, offset, saddr);
+}
+
+/**
+ * mipv6_modify_txoptions - Modify outgoing packets
+ * @sk: socket
+ * @skb: packet buffer for outgoing packet
+ * @old_opt: transmit options
+ * @fl: packet flow structure
+ * @dst: pointer to destination cache entry
+ *
+ * Adds Home Address Option (for MN packets, when not at home) and
+ * Routing Header Type 2 (for CN packets when sending to an MN) to
+ * data packets.  Old extension headers are copied from @old_opt (if
+ * any).  Extension headers are _explicitly_ added for packets with
+ * Mobility Header.  Returns the new header structure, or old if no
+ * changes.
+ **/
+struct ipv6_txoptions *
+mipv6_modify_txoptions(struct sock *sk, struct sk_buff *skb, 
+		       struct ipv6_txoptions *old_opt, struct flowi *fl, 
+		       struct dst_entry **dst)
+{	
+	struct ipv6_opt_hdr *old_hopopt = NULL;
+	struct ipv6_opt_hdr *old_dst1opt = NULL;
+	struct ipv6_rt_hdr *old_srcrt = NULL;
+
+	int srcrtlen = 0, dst1len = 0;
+	int tot_len;
+	struct ipv6_txoptions *opt;
+	struct mipv6_bcache_entry bc_entry;
+	struct in6_addr tmpaddr, *saddr, *daddr, coaddr;
+	__u8 *opt_ptr;
+
+	DEBUG_FUNC();
+
+	if (fl->proto == IPPROTO_MOBILITY) return old_opt;
+	/*
+	 * we have to be prepared to the fact that saddr might not be present,
+	 * if that is the case, we acquire saddr just as kernel does.
+	 */
+	saddr = fl ? fl->fl6_src : NULL;
+	daddr = fl ? fl->fl6_dst : NULL;
+
+	if (daddr == NULL)
+		return old_opt;
+	if (saddr == NULL) {
+		int err = ipv6_get_saddr(NULL, daddr, &tmpaddr);
+		if (err)
+			return old_opt;
+		else
+			saddr = &tmpaddr;
+	}
+
+	DEBUG(DBG_DATADUMP,
+	      "dest. address of packet: %x:%x:%x:%x:%x:%x:%x:%x",
+	      NIPV6ADDR(daddr));
+ 	DEBUG(DBG_DATADUMP, " and src. address: %x:%x:%x:%x:%x:%x:%x:%x", 
+	      NIPV6ADDR(saddr));
+
+	if (old_opt) {
+		old_hopopt = old_opt->hopopt;
+		old_dst1opt = old_opt->dst1opt;
+		old_srcrt = old_opt->srcrt;
+	} 
+
+	if (mipv6_mn_use_hao(daddr, saddr)) {
+		if (old_dst1opt)
+			dst1len = ipv6_optlen(old_dst1opt);
+		dst1len += sizeof(struct mipv6_dstopt_homeaddr) +
+			((6 - dst1len) & 7); /* padding */
+	}
+
+	if (mipv6_bcache_get(daddr, saddr, &bc_entry) == 0)
+		srcrtlen = sizeof(struct rt2_hdr);
+
+	if ((tot_len = srcrtlen + dst1len) == 0) { 
+		return old_opt;
+	}
+
+	tot_len += sizeof(*opt);
+
+	if (!(opt = kmalloc(tot_len, GFP_ATOMIC))) {
+		return NULL;
+	}
+	memset(opt, 0, tot_len);
+	opt->tot_len = tot_len;
+	opt_ptr = (__u8 *) (opt + 1);
+	
+	if (old_srcrt) {
+		opt->srcrt = old_srcrt;
+		opt->opt_nflen += ipv6_optlen(old_srcrt);
+	}
+
+	if (srcrtlen) {
+		DEBUG(DBG_INFO, "Binding exists. Adding routing header");
+
+		opt->srcrt2 = (struct ipv6_rt_hdr *) opt_ptr;
+		opt->opt_nflen += srcrtlen;
+		opt_ptr += srcrtlen;
+		
+		/*
+		 * Append care-of-address to routing header (original
+		 * destination address is home address, the first
+		 * source route segment gets put to the destination
+		 * address and the home address gets to the last
+		 * segment of source route (just as it should)) 
+		 */
+
+		ipv6_addr_copy(&coaddr, &bc_entry.coa);
+
+		mipv6_append_rt2hdr(opt->srcrt2, &coaddr);
+
+		/*
+		 * reroute output (we have to do this in case of TCP
+                 * segment) 
+		 */
+		if (dst) {
+			struct in6_addr *tmp = fl->fl6_dst;
+			fl->fl6_dst = &coaddr;
+
+			dst_release(*dst);
+			*dst = ip6_route_output(sk, fl);
+			if (skb)
+				skb->dst = *dst;
+			fl->fl6_dst = tmp;
+
+			DEBUG(DBG_INFO, "Rerouted outgoing packet");
+		}
+	}
+
+	/* Only home address option is inserted to first dst opt header */
+	if (dst1len) {
+		opt->dst1opt = (struct ipv6_opt_hdr *) opt_ptr;
+		opt->opt_flen += dst1len;
+		opt_ptr += dst1len;
+		mipv6_append_dst1opts(opt->dst1opt, saddr, 
+				      old_dst1opt, dst1len);
+		opt->mipv6_flags = MIPV6_SND_HAO;
+	} else if (old_dst1opt) {
+		opt->dst1opt = old_dst1opt;
+		opt->opt_flen += ipv6_optlen(old_dst1opt);
+	}
+	if (old_hopopt) {
+		opt->hopopt = old_hopopt;
+		opt->opt_nflen += ipv6_optlen(old_hopopt);
+	}	
+	
+	return opt;
+}
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/exthdrs.h linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/exthdrs.h
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/exthdrs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/exthdrs.h	2003-05-18 11:33:53.000000000 +0200
@@ -0,0 +1,56 @@
+/*
+ *	MIPv6 Extension Headers header file
+ *
+ *	Authors:
+ *	Sami Kivisaari		<skivisaa@cc.hut.fi>	
+ *
+ *	$Id: s.exthdrs.h 1.25 02/12/19 03:16:11+02:00 vnuorval@dsl-hkigw1d8c.dial.inet.fi $
+ *
+ *	This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ */
+
+#ifndef _MIPV6_EXTHDRS_H
+#define _MIPV6_EXTHDRS_H
+
+/* standard parameters for creation functions
+ *
+ * opt    = pointer to start of buffer, normally start of destination options
+ *          header
+ * offset = offset of next free location in the buffer where we can begin
+ *          to write option data (2 if we are writing the 
+ *          first option within header).
+ * ch     = pointer to pointer that will contain the address of option length
+ *          field. used to add suboptions to the option. (not necessarily
+ *          &buf[offset+1] due to padding)
+ */
+
+
+/*
+ * Home Address Destination Option function prototypes
+ */
+int mipv6_append_home_addr(__u8 *opt, int offset, struct in6_addr *addr);
+
+int mipv6_handle_homeaddr(struct sk_buff *skb, int optoff);
+
+void mipv6_icmp_handle_homeaddr(struct sk_buff *skb);
+
+/*
+ * Creates a routing header of type 2.
+ */
+void mipv6_append_rt2hdr(struct ipv6_rt_hdr *srcrt, struct in6_addr *addr);
+
+/* Function to add the first destination option header, which may
+ * include a home address option.  
+ */
+void mipv6_append_dst1opts(struct ipv6_opt_hdr *dst1opt, struct in6_addr *saddr,
+			   struct ipv6_opt_hdr *old_dst1opt, int len);
+
+struct ipv6_txoptions *mipv6_modify_txoptions(
+	struct sock *sk, struct sk_buff *skb,
+	struct ipv6_txoptions *old_opt, struct flowi *fl,
+	struct dst_entry **dst);
+
+#endif /* _MIPV6_EXTHDRS_H */
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/ha.c linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/ha.c
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/ha.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/ha.c	2003-05-18 11:33:53.000000000 +0200
@@ -0,0 +1,529 @@
+/*
+ *      Home-agent functionality
+ *
+ *      Authors:
+ *      Sami Kivisaari           <skivisaa@cc.hut.fi>
+ *      Henrik Petander          <lpetande@cc.hut.fi>
+ *
+ *      $Id: s.ha.c 1.62 02/12/19 13:57:09+02:00 vnuorval@dsl-hkigw1d8c.dial.inet.fi $
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ *   
+ *      Changes: Venkata Jagana,
+ *               Krishna Kumar     : Statistics fix
+ *     
+ */
+
+#include <linux/autoconf.h>
+#include <linux/net.h>
+#include <linux/skbuff.h>
+#include <linux/if_ether.h>
+#include <linux/netdevice.h>
+#include <linux/in6.h>
+#include <linux/init.h>
+#include <linux/netfilter.h>
+#include <linux/netfilter_ipv6.h>
+#ifdef CONFIG_SYSCTL
+#include <linux/sysctl.h>
+#endif
+
+#include <net/neighbour.h>
+#include <net/ipv6.h>
+#include <net/ip6_fib.h>
+#include <net/ip6_route.h>
+#include <net/ndisc.h>
+#include <net/addrconf.h>
+#include <net/neighbour.h>
+#include <net/ipv6_tunnel.h>
+
+#include "bcache.h"
+#include "tunnel.h"
+#include "stats.h"
+#include "debug.h"
+#include "util.h"
+#include "ha.h"
+
+static int mipv6_ha_tunnel_sitelocal = 1;
+
+#ifdef CONFIG_SYSCTL
+
+static struct ctl_table_header *mipv6_ha_sysctl_header;
+
+static struct mipv6_ha_sysctl_table
+{
+	struct ctl_table_header *sysctl_header;
+	ctl_table mipv6_vars[3];
+	ctl_table mipv6_mobility_table[2];
+	ctl_table mipv6_proto_table[2];
+	ctl_table mipv6_root_table[2];
+} mipv6_ha_sysctl = {
+	NULL,
+
+        {{NET_IPV6_MOBILITY_TUNNEL_SITELOCAL, "tunnel_sitelocal",
+	  &mipv6_ha_tunnel_sitelocal, sizeof(int), 0644, NULL, 
+	  &proc_dointvec},
+	 {0}},
+
+	{{NET_IPV6_MOBILITY, "mobility", NULL, 0, 0555, 
+	  mipv6_ha_sysctl.mipv6_vars}, {0}},
+	{{NET_IPV6, "ipv6", NULL, 0, 0555, 
+	  mipv6_ha_sysctl.mipv6_mobility_table}, {0}},
+	{{CTL_NET, "net", NULL, 0, 0555, 
+	  mipv6_ha_sysctl.mipv6_proto_table}, {0}}
+};
+
+#endif /* CONFIG_SYSCTL */
+
+/*  this should be in some header file but it isn't  */
+extern void ndisc_send_na(
+	struct net_device *dev, struct neighbour *neigh,
+	struct in6_addr *daddr, struct in6_addr *solicited_addr,
+	int router, int solicited, int override, int inc_opt);
+
+/*  this is defined in kernel IPv6 module (sockglue.c)  */
+extern struct packet_type ipv6_packet_type;
+
+/**
+ * mipv6_ha_set_anycast_addr - Assign Home Agent Anycast Address to a interface
+ * @ifindex: index of interface to which anycast address is assigned
+ * @pfix: prefix for anycast address
+ * @plen: length of prefix in bits
+ *
+ * Node must assign Mobile IPv6 Home Agents anycast address to all
+ * interfaces it serves as a Home Agent.
+ */
+int mipv6_ha_set_anycast_addr(int ifindex, struct in6_addr *pfix, int plen)
+{
+	struct in6_ifreq ifreq;
+	
+	ipv6_addr_copy(&ifreq.ifr6_addr, pfix);
+
+	if (homeagent_anycast(&ifreq.ifr6_addr, plen) < 0)
+		return -EINVAL;
+
+	ifreq.ifr6_prefixlen = plen;
+	ifreq.ifr6_ifindex = ifindex;
+
+	return addrconf_add_ifaddr(&ifreq);
+}
+
+/**
+ * mipv6_proxy_nd_rem - stop acting as a proxy for @home_address
+ * @home_addr: address to remove
+ * @ha_addr: home agent's address on home link
+ * @prefix_length: prefix length in bits
+ * @single: single bit
+ *
+ * When Home Agent acts as a proxy for an address it must leave the
+ * solicited node multicast group for that address and stop responding 
+ * to neighbour solicitations.  
+ **/
+int mipv6_proxy_nd_rem(
+	struct in6_addr *home_addr,
+	int ifindex,
+	int prefix_length,
+	int single)
+{
+        /* When MN returns home HA leaves the solicited mcast groups
+         * for MNs home addresses 
+	 */
+	int err;
+	struct net_device *dev;
+	
+	DEBUG_FUNC();
+	
+        if ((dev = dev_get_by_index(ifindex)) == NULL) {
+		DEBUG(DBG_ERROR, "couldn't get dev");
+		return -ENODEV;
+	}
+#if 0	
+	/* Remove link-local entry */
+	if (!single) {
+		struct in6_addr ll_addr;
+		mipv6_generate_ll_addr(&ll_addr, home_addr);
+		if ((err = pneigh_delete(&nd_tbl, &ll_addr, dev)) < 0) {
+			DEBUG(DBG_INFO,
+			      "peigh_delete failed for "
+			      "%x:%x:%x:%x:%x:%x:%x:%x",
+			      NIPV6ADDR(&ll_addr));	
+		}
+	}
+#endif
+	/* Remove global (or site-local) entry */
+	if ((err = pneigh_delete(&nd_tbl, home_addr, dev)) < 0) {
+		DEBUG(DBG_INFO,
+		      "peigh_delete failed for " 
+		      "%x:%x:%x:%x:%x:%x:%x:%x",
+		      NIPV6ADDR(home_addr));
+	}
+	dev_put(dev);
+	return err;
+}
+
+/**
+ * mipv6_proxy_nd - join multicast group for this address
+ * @home_addr: address to defend
+ * @ha_addr: home agent's address on home link
+ * @prefix_length: prefix length in bits
+ * @single: single bit
+ *
+ * While Mobile Node is away from home, Home Agent acts as a proxy for
+ * @home_address. HA responds to neighbour solicitations for  @home_address 
+ * thus getting all packets destined to home address of MN. 
+ **/
+int mipv6_proxy_nd(struct in6_addr *home_addr, 
+		   int ifindex,
+		   int prefix_length,
+		   int single)
+{  
+	/* The HA sends a proxy ndisc_na message to all hosts on MN's
+	 * home subnet by sending a neighbor advertisement with the
+	 * home address or all addresses of the mobile node if the
+	 * prefix is not 0. The addresses are formed by combining the
+	 * suffix or the host part of the address with each subnet
+	 * prefix that exists in the home subnet 
+	 */
+	
+        /* Since no previous entry for MN exists a proxy_nd advertisement
+	 * is sent to all nodes link local multicast address
+	 */	
+	int err = -1;
+
+	struct net_device *dev;
+//	struct in6_addr ll_addr;
+//	struct pneigh_entry *ll_pneigh;
+	struct in6_addr mcdest;
+//	int send_ll_na = 0;
+	int inc_opt = 1;
+	int solicited = 0;
+	int override = 1;
+	
+	DEBUG_FUNC();
+	
+	if ((dev = dev_get_by_index(ifindex)) == NULL) {
+		DEBUG(DBG_ERROR, "couldn't get dev");
+		return -ENODEV;
+	}
+	
+	if (!pneigh_lookup(&nd_tbl, home_addr, dev, 1)) {
+		DEBUG(DBG_INFO,
+		      "peigh_lookup failed for "
+		      "%x:%x:%x:%x:%x:%x:%x:%x",
+		      NIPV6ADDR(home_addr));
+		goto free_dev;
+	}
+#if 0
+	if (!single) {
+		mipv6_generate_ll_addr(&ll_addr, home_addr);
+		
+		if ((ll_pneigh = pneigh_lookup(&nd_tbl, &ll_addr, dev, 
+					       0)) != NULL) {
+			ll_pneigh = pneigh_clone(ll_pneigh);
+		} else if ((ll_pneigh = pneigh_lookup(&nd_tbl, &ll_addr, 
+						      dev, 1)) == NULL) {
+			DEBUG(DBG_INFO,
+			      "peigh_lookup failed for "
+			      "%x:%x:%x:%x:%x:%x:%x:%x",
+			      NIPV6ADDR(&ll_addr));
+			pneigh_delete(&nd_tbl, home_addr, dev);
+			goto free_dev;
+		} else {
+			send_ll_na = 1;
+		}
+	} else {
+		ll_pneigh = NULL;
+	}
+#endif	
+	/* Proxy neighbor advertisement of MN's home address 
+	 * to all nodes solicited multicast address 
+	 */
+	
+	ipv6_addr_all_nodes(&mcdest); 
+	ndisc_send_na(dev, NULL, &mcdest, home_addr, 0, 
+		      solicited, override, inc_opt);
+#if 0
+	if (send_ll_na) {
+		ndisc_send_na(dev, NULL, &mcdest, &ll_addr, 0, 
+			      solicited, override, inc_opt);
+	}
+#endif
+	err = 0;
+free_dev:
+	dev_put(dev);
+	return err;
+	
+}
+
+struct inet6_ifaddr *is_on_link_ipv6_address(struct in6_addr *mn_haddr,
+					     struct in6_addr *ha_addr)
+{
+	struct inet6_ifaddr *ifp;
+	struct inet6_dev *in6_dev;
+	struct inet6_ifaddr *oifp = NULL;
+
+	if ((ifp = ipv6_get_ifaddr(ha_addr, 0)) == NULL)
+		return NULL;
+
+	if ((in6_dev = ifp->idev) != NULL) {
+		in6_dev_hold(in6_dev);
+		oifp = in6_dev->addr_list;
+		while (oifp != NULL) {
+			spin_lock(&oifp->lock);
+			if (mipv6_prefix_compare(&oifp->addr, mn_haddr,
+						 oifp->prefix_len) &&
+			    !(oifp->flags & IFA_F_TENTATIVE)) {
+				spin_unlock(&oifp->lock);
+				DEBUG(DBG_INFO, "Home Addr Opt: on-link");
+				in6_ifa_hold(oifp);
+				break;
+			}
+			spin_unlock(&oifp->lock);
+			oifp = oifp->if_next;
+		}
+		in6_dev_put(in6_dev);
+	}
+	in6_ifa_put(ifp);
+/*      DEBUG(DBG_WARNING, "Home Addr Opt NOT on-link"); */
+	return oifp;
+
+}
+
+extern void mipv6_bu_finish(
+	struct inet6_ifaddr *ifp, __u8 ba_status,
+	__u32 ba_lifetime, __u32 ba_refresh,
+	__u32 maxdelay, int plength, __u16 sequence,
+	struct in6_addr *saddr, struct in6_addr *daddr,
+	struct in6_addr *haddr, struct in6_addr *coa,
+	int ifindex, int single, __u8 *k_bu);
+
+void mipv6_bu_add_home(int ifindex, struct in6_addr *saddr,
+		struct in6_addr *daddr, struct in6_addr *haddr,
+		struct in6_addr *coa, __u32 lifetime, int plength,
+		__u16 sequence, int single, int ack, __u32 ba_lifetime,
+		__u32 ba_refresh, int dad, int lladdr,__u8 *k_bu)
+{
+	struct inet6_ifaddr *ifp = NULL;
+	__u8 ba_status = SUCCESS;
+
+	ifp = is_on_link_ipv6_address(haddr, daddr);
+
+	if (ifp == NULL) {
+		ba_status = NOT_HOME_SUBNET;
+#if 0
+	} else if ( test(haddr) ) {
+		/* we currently don't do this */
+		ba_status = ADMINISTRATIVELY_PROHIBITED;
+#endif
+	} else if (lladdr) {
+		/* we currently don't do this */
+		ba_status = ADMINISTRATIVELY_PROHIBITED;
+	} else {
+		ifindex = ifp->idev->dev->ifindex; 
+		if (dad) {
+			int ret;
+
+			if ((ret =
+			     mipv6_dad_start(ifp, ifindex, 
+					     saddr, daddr, haddr, coa,
+					     ba_lifetime, plength,
+					     sequence, single)) < 0) {
+				/* An error occurred */
+				ba_status = -ret;
+			} else if (ret) {
+				/* DAD is needed to be performed. */
+				return;
+			}
+			/* DAD is not needed */
+		}
+	}
+
+	mipv6_bu_finish(ifp, ba_status, ba_lifetime, ba_refresh,
+			0, plength, sequence, saddr, daddr, haddr,
+			coa, ifindex, single, k_bu);
+}
+
+extern int mipv6_ra_rcv_ptr(struct sk_buff *skb, struct icmp6hdr *msg);
+
+/**
+ * mipv6_intercept - Netfilter hook to intercept packets
+ * @hooknum: which hook we came from
+ * @p_skb: pointer to *skb
+ * @in: interface we came in
+ * @out: outgoing interface
+ * @okfn: next handler
+ **/
+
+static unsigned int mipv6_intercept(
+        unsigned int hooknum,
+	struct sk_buff **p_skb,
+	const struct net_device *in,
+	const struct net_device *out,
+	int (*okfn)(struct sk_buff *))
+{
+	struct sk_buff *skb = (p_skb) ? *p_skb : NULL;
+	struct ipv6hdr *ipv6h;
+	struct in6_addr *daddr, *saddr;
+	__u8 nexthdr;
+	int nhoff;	
+
+	if(skb == NULL) return NF_ACCEPT;
+	
+	ipv6h = skb->nh.ipv6h;
+	daddr = &ipv6h->daddr;
+	saddr = &ipv6h->saddr;
+		
+	nexthdr = ipv6h->nexthdr;
+	nhoff = sizeof(*ipv6h);
+	
+	
+	if (ipv6_ext_hdr(nexthdr)) 
+		nhoff = ipv6_skip_exthdr(skb, nhoff, &nexthdr, 
+					 skb->len - sizeof(*ipv6h));
+
+	/*
+	 * Possible ICMP packets are checked to ensure that all neighbor 
+	 * solicitations to MNs home address are handled by the HA.
+	 */
+
+	if (nexthdr == IPPROTO_ICMPV6) {			
+		struct icmp6hdr *icmp6h;
+		int dest_type;
+
+		if (nhoff < 0 || 
+		    !pskb_may_pull(skb, nhoff + sizeof(struct icmp6hdr)))
+			return NF_DROP;
+
+		dest_type = ipv6_addr_type(daddr);
+		icmp6h = (struct icmp6hdr *)&skb->nh.raw[nhoff];
+
+		/* HA has to capture all unicast neighbour solicitations in 
+		   order to check if it is acting as a proxy for the target 
+		   address. */
+		
+		if ((dest_type & IPV6_ADDR_UNICAST) && 
+		    icmp6h->icmp6_type == NDISC_NEIGHBOUR_SOLICITATION) {
+			ip6_input(skb);
+			return NF_STOLEN;
+		} 
+	}
+	return NF_ACCEPT;
+}
+
+/*
+ * Netfilter hook for packet interception
+ */
+
+static struct nf_hook_ops intercept_hook_ops = {
+        {NULL, NULL},     // List head, no predecessor, no successor
+        mipv6_intercept,
+        PF_INET6,
+        NF_IP6_PRE_ROUTING,
+        NF_IP6_PRI_LAST
+};
+
+/**
+ * mipv6_ha_tnl_xmit_drop_local_hook - drop local packets 
+ * @skb: outgoing skb
+ * @flags: flags set by tunnel device driver
+ *
+ *
+ * Return:
+ * %IPV6_TNL_ACCEPT if packet can be sent through tunnel,
+ * %IPV6_TNL_DROP if packet is invalid,
+ **/
+
+static int
+mipv6_ha_tnl_xmit_drop_local_hook(struct ipv6_tnl *t, struct sk_buff *skb)
+{
+	int dest_type;
+
+	DEBUG_FUNC();
+
+       	/* If this isn't a tunnel used for Mobile IPv6 return */
+	if (!is_mipv6_tnl(t))
+		return IPV6_TNL_ACCEPT;
+
+	dest_type = ipv6_addr_type(&skb->nh.ipv6h->daddr);
+
+	if ((dest_type & IPV6_ADDR_LINKLOCAL) ||
+	    ((dest_type & IPV6_ADDR_SITELOCAL) && 
+	     !mipv6_ha_tunnel_sitelocal)) 
+		return IPV6_TNL_DROP;
+	
+	return IPV6_TNL_ACCEPT;
+}
+	
+static struct ipv6_tnl_hook_ops mipv6_ha_tnl_xmit_drop_local_ops = {
+	{NULL, NULL}, 
+	IPV6_TNL_PRE_ENCAP,
+	IPV6_TNL_PRI_FIRST,
+	mipv6_ha_tnl_xmit_drop_local_hook
+};
+
+static int
+mipv6_ha_tnl_xmit_stats_hook(struct ipv6_tnl *t, struct sk_buff *skb)
+{
+	DEBUG_FUNC();
+	if (is_mipv6_tnl(t))
+		MIPV6_INC_STATS(n_encapsulations);
+	return IPV6_TNL_ACCEPT;
+}
+
+static struct ipv6_tnl_hook_ops mipv6_ha_tnl_xmit_stats_ops = {
+	{NULL, NULL},
+	IPV6_TNL_PRE_ENCAP,
+	IPV6_TNL_PRI_LAST,
+	mipv6_ha_tnl_xmit_stats_hook
+};
+
+static int
+mipv6_ha_tnl_rcv_stats_hook(struct ipv6_tnl *t, struct sk_buff *skb)
+{
+	DEBUG_FUNC();
+	if (is_mipv6_tnl(t))
+		MIPV6_INC_STATS(n_decapsulations);
+	return IPV6_TNL_ACCEPT;
+}
+
+static struct ipv6_tnl_hook_ops mipv6_ha_tnl_rcv_stats_ops = {
+	{NULL, NULL},
+	IPV6_TNL_PRE_DECAP,
+	IPV6_TNL_PRI_LAST,
+	mipv6_ha_tnl_rcv_stats_hook
+};
+
+int __init mipv6_ha_init(void)
+{
+	DEBUG_FUNC();
+
+#ifdef CONFIG_SYSCTL
+	if (!(mipv6_ha_sysctl_header = 
+	      register_sysctl_table(mipv6_ha_sysctl.mipv6_root_table, 0)))
+		printk(KERN_ERR "Failed to register sysctl handlers!");
+#endif
+	/*  register packet interception hooks  */
+	nf_register_hook(&intercept_hook_ops);
+	ipv6_ipv6_tnl_register_hook(&mipv6_ha_tnl_xmit_drop_local_ops);
+	ipv6_ipv6_tnl_register_hook(&mipv6_ha_tnl_xmit_stats_ops);
+	ipv6_ipv6_tnl_register_hook(&mipv6_ha_tnl_rcv_stats_ops);
+	return 0;
+}
+
+void __exit mipv6_ha_exit(void)
+{
+	DEBUG_FUNC();
+
+#ifdef CONFIG_SYSCTL
+	unregister_sysctl_table(mipv6_ha_sysctl_header);
+#endif
+
+	/*  remove packet interception hooks  */
+	ipv6_ipv6_tnl_unregister_hook(&mipv6_ha_tnl_rcv_stats_ops);
+	ipv6_ipv6_tnl_unregister_hook(&mipv6_ha_tnl_xmit_stats_ops);
+	ipv6_ipv6_tnl_unregister_hook(&mipv6_ha_tnl_xmit_drop_local_ops);
+	nf_unregister_hook(&intercept_hook_ops);
+}
+
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/ha.h linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/ha.h
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/ha.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/ha.h	2003-05-18 11:33:53.000000000 +0200
@@ -0,0 +1,264 @@
+/*
+ *      Home-agent header file
+ *
+ *      Authors:
+ *      Sami Kivisaari          <skivisaa@cc.hut.fi>
+ *
+ *      $Id: s.ha.h 1.10 02/12/19 13:57:09+02:00 vnuorval@dsl-hkigw1d8c.dial.inet.fi $
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef _HA_H
+#define _HA_H
+
+#include <linux/config.h>
+#include <net/mipv6.h>
+#include "prefix.h"
+#include "bcache.h"
+#include "mobhdr.h"
+
+#ifdef CONFIG_IPV6_MOBILITY_HA
+
+#include "tunnel.h"
+#include "mipv6_icmp.h"
+#include "sortedlist.h"
+#include "debug.h"
+#include "util.h"
+
+int mipv6_ha_init(void);
+void mipv6_ha_exit(void);
+
+int mipv6_dad_start(struct inet6_ifaddr *ifp, int ifindex,
+		    struct in6_addr *saddr, struct in6_addr *daddr,
+		    struct in6_addr *haddr, struct in6_addr *coa,
+		    __u32 ba_lifetime, int plength, __u16 sequence,
+		    int single);
+
+int mipv6_proxy_nd(
+	struct in6_addr *home_addr, 
+	int ifindex,
+	int prefix_length,
+	int router);
+
+int mipv6_proxy_nd_rem(
+	struct in6_addr *home_addr,
+	int ifindex,
+	int prefix_length,
+	int router);
+
+static __inline__ void mipv6_generate_ll_addr(struct in6_addr *ll_addr,
+					      struct in6_addr *addr)
+{
+	ll_addr->s6_addr32[0] = htonl(0xfe800000);
+	ll_addr->s6_addr32[1] = 0;
+	ll_addr->s6_addr32[2] = addr->s6_addr32[2];
+	ll_addr->s6_addr32[3] = addr->s6_addr32[3];
+}
+
+void mipv6_bu_add_home(
+	int ifindex, struct in6_addr *saddr, struct in6_addr *daddr, 
+	struct in6_addr *haddr, struct in6_addr *coa, __u32 lifetime, 
+	int plength, __u16 sequence, int single, int ack, 
+	__u32 ba_lifetime, __u32 ba_refresh, int dad, int lladdr,__u8 *k_bu);
+
+/*
+ * Stop listening to the multicast value of the Home Address of a
+ * MN when it's binding cache entry is being expired or freed up.
+ */
+static inline void bcache_proxy_nd_rem(struct mipv6_bcache_entry *entry)
+{
+	if (entry->type == HOME_REGISTRATION) {
+		if (mipv6_proxy_nd_rem(&entry->home_addr, entry->ifindex,
+				       entry->prefix, entry->single) == 0) {
+			DEBUG(DBG_INFO, "proxy_nd succ");
+		} else {
+			DEBUG(DBG_INFO, "proxy_nd fail");
+		}
+	}
+}
+
+static __inline__ void del_proxy(struct in6_addr *home_addr,
+				 struct mipv6_bcache_entry *entry)
+{
+	bcache_proxy_nd_rem(entry);	
+	mipv6_del_tnl_to_mn(&entry->coa, &entry->our_addr, home_addr);
+}
+
+
+static __inline__ void mipv6_check_entry(struct mipv6_bcache_entry *entry,
+		int create_tunnel, int type, int single, int *ret)
+{
+	if (entry->type == HOME_REGISTRATION) {
+		if (create_tunnel || 
+		    type != HOME_REGISTRATION) {
+			del_proxy(&entry->home_addr, entry);
+		} else if (type == HOME_REGISTRATION && 
+			   entry->single != single) {
+			/* proxy nd for link-local address
+			   should either be added or removed */
+			bcache_proxy_nd_rem(entry);
+			*ret = 1;
+		}
+	}
+}
+
+static __inline__ int mipv6_create_tnl(int type, int single, int create_tunnel,
+		int ifindex, __u8 prefix,
+		struct mipv6_bcache_entry *entry,
+		struct in6_addr *coa, struct in6_addr *our_addr,
+		struct in6_addr *home_addr, int update_pneigh_tbl)
+{
+	int ret;
+
+	if (type == HOME_REGISTRATION) {
+		entry->router = 0;
+		entry->single = single;
+		if (create_tunnel && 
+		    ((ret = mipv6_add_tnl_to_mn(coa, our_addr, home_addr))
+		     <= 0)) {
+			if (ret != -ENOMEDIUM) {
+				DEBUG(DBG_ERROR,
+				      "unable to configure tunnel to MN!");
+			}
+			return 1;
+		}
+		if ((create_tunnel || update_pneigh_tbl) &&
+		    mipv6_proxy_nd(home_addr, ifindex,
+				   prefix, single) != 0) {
+			DEBUG(DBG_ERROR, "mipv6_proxy_nd failed!");
+			return 2;
+		}
+	}
+	return 0;
+}
+
+/**
+ * set_ha_pfx_list - manipulate pfx_list for HA when timer goes off
+ * @entry: pfx_list_entry that is due
+ */
+static __inline__ void set_ha_pfx_list(struct pfx_list_entry *entry)
+{
+	int count;
+	struct prefix_info *plist;
+	__u16 id;
+	extern struct list_head pfx_list;
+
+	id = -1;
+	if ((count = ipv6_get_prefix_entries(&plist, entry->ifindex, 0)) > 0) {
+		mipv6_icmpv6_send(&entry->daddr, &entry->saddr, 
+				  MIPV6_PREFIX_ADV, 0, &id, plist, 
+				  count * sizeof(struct prefix_info));
+		kfree(plist);
+	}
+
+	if (++entry->retries <= PREFIX_ADV_RETRIES)
+		mipv6_slist_push_first(&pfx_list, jiffies +
+				(PREFIX_ADV_TIMEOUT << entry->retries) * HZ);
+	else
+		kfree(mipv6_slist_del_first(&pfx_list));
+}
+
+static __inline__ void mipv6_bcache_delete_wrapper(struct in6_addr *haddr,
+		struct in6_addr *daddr, struct in6_addr *coa, int *ba_lifetime,
+		int *ba_refresh, int *need_ack, __u8 *ba_status, int lifetime,
+		int plength, int sequence, int home)
+{
+	if (home) {
+		/* Primary Care-of Address Deregistration */
+
+		/* ack SHOULD be set (says draft) */
+		*need_ack = 1;
+
+		if (mipv6_bcache_exists(haddr, daddr) == HOME_REGISTRATION) {
+			if (mipv6_bcache_delete(haddr, daddr,
+						HOME_REGISTRATION) != 0)
+				DEBUG(DBG_ERROR, "delete failed.");
+			else
+				DEBUG(DBG_INFO, "delete succ.");
+
+			*ba_lifetime = 0;
+			*ba_refresh = 0;
+
+			DEBUG(DBG_DATADUMP, "home_addr: %x:%x:%x:%x:%x:%x:%x:%x",
+			      NIPV6ADDR(haddr));
+			DEBUG(DBG_DATADUMP, "coa: %x:%x:%x:%x:%x:%x:%x:%x",
+			      NIPV6ADDR(coa));
+			DEBUG(DBG_DATADUMP, "lifet:%d,plen:%d,seq:%d",
+			      lifetime, plength, sequence);
+
+		} else {
+			*ba_status = NOT_HA_FOR_MN;
+		}
+	}
+}
+
+static __inline__ void mipv6_adjust_lifetime(__u32 *lifetime)
+{ return; }
+
+#else	/* CONFIG_IPV6_MOBILITY_HA */
+
+static inline void bcache_proxy_nd_rem(struct mipv6_bcache_entry *entry)
+{
+	DEBUG(DBG_ERROR, "HA function called in non-HA config");
+}
+
+static __inline__ void del_proxy(struct in6_addr *home_addr,
+				 struct mipv6_bcache_entry *entry)
+{
+	DEBUG(DBG_ERROR, "HA function called in non-HA config");
+}
+
+static __inline__ void mipv6_check_entry(struct mipv6_bcache_entry *entry,
+		int create_tunnel, int type, int single, int *ret)
+{ return; }
+
+static __inline__ int mipv6_create_tnl(int type, int single, int create_tunnel,
+		int ifindex, __u8 prefix,
+		struct mipv6_bcache_entry *entry,
+		struct in6_addr *coa, struct in6_addr *our_addr,
+		struct in6_addr *home_addr, int update_pneigh_tbl)
+{
+	return 0;		/* always ok for CN's */
+}
+
+static __inline__ void set_ha_pfx_list(struct pfx_list_entry *entry)
+{ return; }
+
+static __inline__ void mipv6_bcache_delete_wrapper(struct in6_addr *haddr, 
+		struct in6_addr *daddr, struct in6_addr *coa, int *ba_lifetime,
+		int *ba_refresh, int *need_ack, __u8 *ba_status, int lifetime,
+		int plength, int sequence, int home)
+{
+	/* Node is not a Home Agent, but the sender believes
+	 * so.  The draft doesn't tell if, when _deleting_,
+	 * sender should be informed with a code 132 (Home Reg
+	 * not supported).  At this time we return
+	 * REASON_UNSPECIFIED. */
+	if (home)
+		*ba_status = REASON_UNSPECIFIED;
+}
+
+static __inline__ void  mipv6_bu_add_home(
+	int ifindex, struct in6_addr *saddr, struct in6_addr *daddr, 
+	struct in6_addr *haddr, struct in6_addr *coa, __u32 lifetime, 
+	int plength, __u16 sequence, int single, int ack, 
+	__u32 ba_lifetime, __u32 ba_refresh, int dad, int lladdr, __u8 *k_bu)
+{
+	mipv6_send_ba(daddr, haddr, coa, 0, 
+		      HOME_REGISTRATION_NOT_SUPPORTED,
+		      sequence, ba_lifetime, ba_refresh, k_bu);
+}
+
+static __inline__ void mipv6_adjust_lifetime(__u32 *lifetime)
+{
+	if (*lifetime > MAX_RR_BINDING_LIFE)
+		*lifetime = MAX_RR_BINDING_LIFE;
+}
+#endif	/* CONFIG_IPV6_MOBILITY_HA */
+
+#endif
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/halist.c linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/halist.c
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/halist.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/halist.c	2003-05-18 11:33:53.000000000 +0200
@@ -0,0 +1,458 @@
+/*
+ *      Home Agents List
+ *
+ *      Authors:
+ *      Antti Tuominen          <ajtuomin@tml.hut.fi>
+ *
+ *      $Id: s.halist.c 1.29 02/12/17 11:42:21+02:00 antti@jon.mipl.mediapoli.com $
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ *
+ */
+
+#define PREF_BASE 50000
+
+#include <linux/autoconf.h>
+#include <linux/sched.h>
+#include <linux/timer.h>
+#include <linux/proc_fs.h>
+#include <linux/init.h>
+#include <net/ipv6.h>
+#include <net/addrconf.h>
+
+#include "util.h"
+#include "hashlist.h"
+#include "halist.h"
+#include "debug.h"
+
+struct mipv6_halist {
+	struct hashlist *entries;
+	struct timer_list expire_timer;
+};
+
+static rwlock_t home_agents_lock = RW_LOCK_UNLOCKED;
+
+static struct mipv6_halist home_agents;
+
+struct preflist_iterator_args {
+	int count;
+	int requested;
+	int ifindex;
+	struct in6_addr *list;
+};
+
+static int preflist_iterator(void *data, void *args,
+			     unsigned long *pref)
+{
+	struct preflist_iterator_args *state =
+		(struct preflist_iterator_args *)args;
+	struct mipv6_halist_entry *entry =
+		(struct mipv6_halist_entry *)data;
+	struct in6_addr *newaddr =
+		(struct in6_addr *)state->list + state->count;
+
+	if (state->count >= state->requested)
+		return ITERATOR_STOP;
+
+	if (time_after(jiffies, entry->expire))
+		return ITERATOR_DELETE_ENTRY;
+
+	if (state->ifindex != entry->ifindex)
+		return ITERATOR_CONT;
+
+	ipv6_addr_copy(newaddr, &entry->global_addr);
+	state->count++;
+
+	return ITERATOR_CONT;
+}
+
+static int gc_iterator(void *data, void *args,
+		       unsigned long *pref)
+{
+	struct mipv6_halist_entry *entry =
+		(struct mipv6_halist_entry *)data;
+
+	int *type = (int *)args;
+
+	if (*type == 1) {
+		return ITERATOR_DELETE_ENTRY;
+	}
+
+	if (time_after(jiffies, entry->expire)) {
+		return ITERATOR_DELETE_ENTRY;
+	}
+
+	return ITERATOR_CONT;
+}
+
+static int mipv6_halist_gc(int type)
+{
+	DEBUG_FUNC();
+	hashlist_iterate(home_agents.entries, &type, gc_iterator);
+	return 0;
+}
+
+static void mipv6_halist_expire(unsigned long dummy)
+{
+	DEBUG_FUNC();
+
+	write_lock(&home_agents_lock);
+	mipv6_halist_gc(0);
+	write_unlock(&home_agents_lock);
+}
+
+
+static struct mipv6_halist_entry *mipv6_halist_new_entry(void)
+{
+	struct mipv6_halist_entry *entry;
+
+	DEBUG_FUNC();
+
+	entry = hashlist_alloc(home_agents.entries, SLAB_ATOMIC);
+
+	return entry;
+}
+
+/**
+ * mipv6_halist_add - Add new home agent to the Home Agents List
+ * @ifindex: interface identifier
+ * @glob_addr: home agent's global address
+ * @ll_addr: home agent's link-local address
+ * @pref: relative preference for this home agent
+ * @lifetime: lifetime for the entry
+ *
+ * Adds new home agent to the Home Agents List.  The list is interface
+ * specific and @ifindex tells through which interface the home agent
+ * was heard.  Returns zero on success and negative on failure.
+ **/
+
+int mipv6_halist_add(int ifindex, struct in6_addr *glob_addr,
+		     struct in6_addr *ll_addr, int pref, __u32 lifetime)
+{
+	int update = 0, ret = 0;
+	long mpref;
+	struct mipv6_halist_entry *entry = NULL;
+
+	DEBUG_FUNC();
+
+	write_lock(&home_agents_lock);
+
+	if (glob_addr == NULL || lifetime <= 0) {
+		DEBUG(DBG_WARNING, "invalid arguments");
+		ret = -EINVAL;
+		goto out;
+	}
+	mpref = PREF_BASE - pref;
+	if ((entry = (struct mipv6_halist_entry *)
+	     hashlist_get(home_agents.entries, glob_addr)) != NULL) {
+		if (entry->ifindex == ifindex) {
+			DEBUG(DBG_DATADUMP, "updating old entry");
+			update = 1;
+		} else {
+			update = 0;
+		}
+	}
+	if (update) {
+		entry->expire = jiffies + lifetime * HZ;
+		if (entry->preference != mpref) {
+			entry->preference = mpref;
+			ret = hashlist_reposition(home_agents.entries, 
+						  (void *)entry, mpref);
+		}
+	} else {
+		entry = mipv6_halist_new_entry();
+		if (entry == NULL) {
+			DEBUG(DBG_INFO, "list full");
+			ret = -ENOMEM;
+			goto out;
+		}
+		entry->ifindex = ifindex;
+		if (ll_addr)
+			ipv6_addr_copy(&entry->link_local_addr, ll_addr);
+		else
+			ipv6_addr_set(&entry->link_local_addr, 0, 0, 0, 0);
+		ipv6_addr_copy(&entry->global_addr, glob_addr);
+		entry->preference = mpref;
+		entry->expire = jiffies + lifetime * HZ;
+		ret = hashlist_add(home_agents.entries, glob_addr, mpref, 
+				   entry);
+	}
+out:
+	write_unlock(&home_agents_lock);
+	return ret;
+}
+
+/**
+ * mipv6_halist_delete - delete home agent from Home Agents List
+ * @glob_addr: home agent's global address
+ *
+ * Deletes entry for home agent @glob_addr from the Home Agent List.
+ **/
+int mipv6_halist_delete(struct in6_addr *glob_addr)
+{
+	struct hashlist_entry *e;
+
+	DEBUG_FUNC();
+
+	if (glob_addr == NULL) {
+		DEBUG(DBG_WARNING, "invalid glob addr");
+		return -EINVAL;
+	}
+	write_lock(&home_agents_lock);
+	if ((e = hashlist_get(home_agents.entries, glob_addr)) == NULL) {
+		write_unlock(&home_agents_lock);
+		return -ENOENT;
+	}
+	hashlist_delete(home_agents.entries, e);
+	hashlist_free(home_agents.entries, e);
+	write_unlock(&home_agents_lock);
+	return 0;
+}
+
+/**
+ * mipv6_ha_get_pref_list - Get list of preferred home agents
+ * @ifindex: interface identifier
+ * @addrs: pointer to a buffer to store the list
+ * @max: maximum number of home agents to return
+ *
+ * Creates a list of @max preferred (or all known if less than @max)
+ * home agents.  Home Agents List is interface specific so you must
+ * supply @ifindex.  Stores list in addrs and returns number of home
+ * agents stored.  On failure, returns a negative value.
+ **/
+int mipv6_ha_get_pref_list(int ifindex, struct in6_addr **addrs, int max)
+{
+	struct preflist_iterator_args args;
+
+	if (max <= 0) {
+		*addrs = NULL;
+		return 0;
+	}
+
+	args.count = 0;
+	args.requested = max;
+	args.ifindex = ifindex;
+	args.list = kmalloc(max * sizeof(struct in6_addr), GFP_ATOMIC);
+
+	if (args.list == NULL) return -ENOMEM;
+
+	read_lock(&home_agents_lock);
+	hashlist_iterate(home_agents.entries, &args, preflist_iterator);
+	read_unlock(&home_agents_lock);
+
+	if (args.count >= 0) {
+		*addrs = args.list;
+	} else {
+		kfree(args.list);
+		*addrs = NULL;
+	}
+
+	return args.count;
+}
+
+struct getaddr_iterator_args {
+	struct net_device *dev;
+	struct in6_addr *addr;
+};
+
+static int getaddr_iterator(void *data, void *args,
+	     unsigned long *pref)
+{
+	struct mipv6_halist_entry *entry =
+		(struct mipv6_halist_entry *)data;
+	struct getaddr_iterator_args *state =
+		(struct getaddr_iterator_args *)args;
+
+	if (entry->ifindex != state->dev->ifindex)
+		return ITERATOR_CONT;
+
+	if (ipv6_chk_addr(&entry->global_addr, state->dev)) {
+		ipv6_addr_copy(state->addr, &entry->global_addr);
+		return ITERATOR_STOP;
+	}
+	return ITERATOR_CONT;
+}
+
+/*
+ * Get Home Agent Address for an interface
+ */
+int mipv6_ha_get_addr(int ifindex, struct in6_addr *addr)
+{
+	struct getaddr_iterator_args args;
+	struct net_device *dev;
+
+	if (ifindex <= 0)
+		return -EINVAL;
+
+	if ((dev = dev_get_by_index(ifindex)) == NULL)
+		return -ENODEV;
+
+	memset(addr, 0, sizeof(struct in6_addr));
+	args.dev = dev;
+	args.addr = addr;
+	read_lock(&home_agents_lock);
+	hashlist_iterate(home_agents.entries, &args, getaddr_iterator);
+	read_unlock(&home_agents_lock);
+	dev_put(dev);
+
+	if (ipv6_addr_any(addr))
+		return -ENOENT;
+	
+	return 0;
+}
+
+#define HALIST_INFO_LEN 81
+
+struct procinfo_iterator_args {
+	char *buffer;
+	int offset;
+	int length;
+	int skip;
+	int len;
+};
+
+static int procinfo_iterator(void *data, void *args,
+			     unsigned long *pref)
+{
+	struct procinfo_iterator_args *arg =
+		(struct procinfo_iterator_args *)args;
+	struct mipv6_halist_entry *entry =
+		(struct mipv6_halist_entry *)data;
+	unsigned long int expire;
+
+	DEBUG_FUNC();
+
+	if (entry == NULL) return ITERATOR_ERR;
+
+	if (time_after(jiffies, entry->expire))
+		return ITERATOR_DELETE_ENTRY;
+
+	if (arg->skip < arg->offset / HALIST_INFO_LEN) {
+		arg->skip++;
+		return ITERATOR_CONT;
+	}
+
+	if (arg->len >= arg->length)
+		return ITERATOR_CONT;
+
+	expire = (entry->expire - jiffies) / HZ;
+
+	arg->len += sprintf(arg->buffer + arg->len, 
+			"%02d %04x%04x%04x%04x%04x%04x%04x%04x "
+			"%04x%04x%04x%04x%04x%04x%04x%04x %05ld %05ld\n",
+			entry->ifindex,
+			NIPV6ADDR(&entry->global_addr), 
+			NIPV6ADDR(&entry->link_local_addr), 
+			-(entry->preference - PREF_BASE), expire);
+
+	return ITERATOR_CONT;
+}
+
+static int halist_proc_info(char *buffer, char **start, off_t offset,
+                            int length)
+{
+	struct procinfo_iterator_args args;
+
+	DEBUG_FUNC();
+
+	args.buffer = buffer;
+	args.offset = offset;
+	args.length = length;
+	args.skip = 0;
+	args.len = 0;
+
+	read_lock_bh(&home_agents_lock);
+	hashlist_iterate(home_agents.entries, &args, procinfo_iterator);
+	read_unlock_bh(&home_agents_lock);
+
+	*start = buffer;
+	if (offset)
+		*start += offset % HALIST_INFO_LEN;
+
+	args.len -= offset % HALIST_INFO_LEN;
+
+	if (args.len > length)
+		args.len = length;
+	if (args.len < 0)
+		args.len = 0;
+	
+	return args.len;
+}
+
+static int halist_compare(void *data, void *hashkey)
+{
+	struct mipv6_halist_entry *e = (struct mipv6_halist_entry *)data;
+	struct in6_addr *key = (struct in6_addr *)hashkey;
+
+	return ipv6_addr_cmp(&e->global_addr, key);
+}
+
+static __u32 halist_hash(void *hashkey)
+{
+	struct in6_addr *key = (struct in6_addr *)hashkey;
+	__u32 hash;
+
+	hash = key->s6_addr32[0] ^
+                key->s6_addr32[1] ^
+                key->s6_addr32[2] ^
+                key->s6_addr32[3];
+
+	return hash;
+}
+
+static void *halist_hashkey(void *data)
+{
+	struct mipv6_halist_entry *e = (struct mipv6_halist_entry *)data;
+	struct in6_addr *key;
+
+	key = kmalloc(sizeof(struct in6_addr), GFP_ATOMIC);
+
+	if (key == NULL)
+		return NULL;
+	ipv6_addr_copy(key, &e->global_addr);
+
+	return key;
+}
+
+int __init mipv6_halist_init(__u32 size)
+{
+	DEBUG_FUNC();
+
+	if (size <= 0) {
+		DEBUG(DBG_ERROR, "size must be at least 1");
+		return -EINVAL;
+	}
+	init_timer(&home_agents.expire_timer);
+	home_agents.expire_timer.data = 0;
+	home_agents.expire_timer.function = mipv6_halist_expire;
+	home_agents_lock = RW_LOCK_UNLOCKED;
+
+	home_agents.entries = hashlist_create(16, size, sizeof(struct mipv6_halist_entry),
+					       "mip6_halist", NULL, NULL,
+					       halist_compare,
+					       halist_hash, halist_hashkey);
+
+	if (home_agents.entries == NULL) {
+		DEBUG(DBG_ERROR, "Failed to initialize hashlist");
+		return -ENOMEM;
+	}
+
+	proc_net_create("mip6_home_agents", 0, halist_proc_info);
+	DEBUG(DBG_INFO, "Home Agents List initialized");
+	return 0;
+}
+
+void __exit mipv6_halist_exit(void)
+{
+	DEBUG_FUNC();
+	proc_net_remove("mip6_home_agents");
+	write_lock_bh(&home_agents_lock);
+	DEBUG(DBG_INFO, "Stopping the halist timer");
+	del_timer(&home_agents.expire_timer);
+	mipv6_halist_gc(1);
+	write_unlock_bh(&home_agents_lock);
+	hashlist_destroy(home_agents.entries);
+}
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/halist.h linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/halist.h
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/halist.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/halist.h	2003-05-18 11:33:53.000000000 +0200
@@ -0,0 +1,69 @@
+/*
+ *      Home-agents list header file      
+ *
+ *      Authors:
+ *      Antti Tuominen          <ajtuomin@tml.hut.fi>
+ *      Jani Rnkknen          <ronkkone@lut.fi>
+ *
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef _HALIST_H
+#define _HALIST_H
+
+#include "hashlist.h"
+
+struct mipv6_halist_entry {
+	struct hashlist_entry e;
+	int ifindex;			 /* Link identifier		*/
+	struct in6_addr link_local_addr; /* HA's link-local address	*/
+	struct in6_addr global_addr;	 /* HA's Global address 	*/
+	long preference;		 /* The preference for this HA	*/
+	unsigned long expire;		 /* expiration time (jiffies)	*/
+};
+
+/* 
+ * Initialize Home Agents List.  Size is maximum number of home agents
+ * stored in the list.
+ */
+int mipv6_halist_init(__u32 size);
+
+/*
+ * Free Home Agents List.
+ */
+void mipv6_halist_exit(void);
+
+/* 
+ * Add new home agent to Home Agents List
+ */
+int mipv6_halist_add(
+	int ifindex,
+	struct in6_addr *glob_addr,
+	struct in6_addr *ll_addr,
+	int pref,
+	__u32 lifetime);
+
+/*
+ * Delete home agent from Home Agents List
+ */
+int mipv6_halist_delete(struct in6_addr *glob_addr);
+
+/*
+ * Store min(max, total) number of HA addresses (ordered by
+ * preference, preferred first) in addrs.  Return actual number of
+ * addresses.  Remember to kfree addrs after use.
+ */
+int mipv6_ha_get_pref_list(int ifindex, struct in6_addr **addrs, int max);
+
+/*
+ * Get Home Agent Address for given interface.  If node is not serving
+ * as a HA for this interface returns negative error value.
+ */
+int mipv6_ha_get_addr(int ifindex, struct in6_addr *addr);
+
+#endif /* _HALIST_H */
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/hashlist.c linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/hashlist.c
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/hashlist.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/hashlist.c	2003-05-18 11:33:53.000000000 +0200
@@ -0,0 +1,346 @@
+
+/*
+ *	Generic hashtable with chaining.  Supports secodary sort order
+ *	with doubly linked-list.
+ *
+ *	Authors:
+ *	Sami Kivisaari		<skivisaa@cc.hut.fi>
+ *	Antti Tuominen		<ajtuomin@tml.hut.fi>
+ *
+ *	$Id: s.hashlist.c 1.21 02/10/07 19:31:52+03:00 antti@traci.mipl.mediapoli.com $
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License as
+ *	published by the Free Software Foundation; either version 2 of
+ *	the License, or (at your option) any later version.
+ */
+
+#include <linux/slab.h>
+#include "hashlist.h"
+#include "debug.h"
+
+
+struct hashlist {
+	int count;		/* entry count	*/
+	int maxcount;		/* max entries	*/
+	__u32 bucketnum;	/* hash buckets	*/
+
+	kmem_cache_t *kmem;
+
+	struct list_head *hashtable;
+	struct list_head sortedlist;
+
+	int (*compare)(void *data, void *hashkey);
+	__u32 (*hash_function)(void *hashkey);
+	void *(*get_hashkey)(void *data);
+};
+
+/**
+ * hashlist_create - Create new hashlist
+ * @bucketnum: number of hash buckets
+ * @maxentries: maximum number of entries (0 = no limit)
+ * @size: entry size in bytes
+ * @name: name for kmem_cache_t
+ * @ctor: kmem_cache_t constructor
+ * @dtor: kmem_cache_t destructor
+ * @compare: compare function for key
+ * @hash_function: hash function
+ * @get_hashkey: function to get key from entry
+ *
+ **/
+struct hashlist *hashlist_create(int bucketnum, int max_entries, size_t size,
+				 char *name,
+				 void (*ctor)(void *, kmem_cache_t *, unsigned long),
+				 void (*dtor)(void *, kmem_cache_t *, unsigned long),
+				 int (*compare)(void *data, void *hashkey),
+				 __u32 (*hash_function)(void *hashkey),
+				 void *(*get_hashkey)(void *data))
+{
+	int i;
+	struct hashlist *hl;
+
+	if (!compare || !hash_function || !get_hashkey)
+		goto hlfailed;
+
+	hl = kmalloc(sizeof(struct hashlist), GFP_ATOMIC);
+	if (!hl) goto hlfailed;
+
+	hl->kmem = kmem_cache_create(name, size, 0, 0, ctor, dtor);
+	if (!hl->kmem) goto poolfailed;
+
+	hl->hashtable = kmalloc(
+		sizeof(struct list_head) * bucketnum, GFP_ATOMIC);
+	if (!hl->hashtable) goto hashfailed;
+
+	for (i = 0; i < bucketnum; i++)
+		INIT_LIST_HEAD(&hl->hashtable[i]);
+
+	INIT_LIST_HEAD(&hl->sortedlist);
+
+	hl->maxcount = max_entries;
+	hl->count = 0;
+	hl->bucketnum = bucketnum;
+	hl->compare = compare;
+	hl->hash_function = hash_function;
+	hl->get_hashkey = get_hashkey;
+
+	return hl;
+
+hashfailed:
+	kmem_cache_destroy(hl->kmem);
+	hl->kmem = NULL;
+
+poolfailed:
+	kfree(hl);
+
+hlfailed:
+	DEBUG(DBG_ERROR, "could not create hashlist");
+
+	return NULL;	
+}
+
+/**
+ * hashlist_destroy - Destroy hashlist
+ * @hashlist: hashlist to destroy
+ *
+ * Frees all memory allocated for a hashlist.
+ **/
+void hashlist_destroy(struct hashlist *hashlist)
+{
+	DEBUG_FUNC();
+
+	if (hashlist == NULL) return;
+
+	if (hashlist->hashtable) {
+		kfree(hashlist->hashtable);
+		hashlist->hashtable = NULL;
+	}
+
+	if (hashlist->kmem) {
+		kmem_cache_destroy(hashlist->kmem);
+		hashlist->kmem = NULL;
+	}
+
+	kfree(hashlist);
+
+	return;
+}
+
+/*
+ * insert a chain of entries to hashlist into correct order
+ * the entries are assumed to have valid hashkeys
+ */
+static void sorted_insert(struct list_head *lh, struct hashlist_entry *he)
+{
+	struct list_head *p;
+	struct hashlist_entry *hlp = NULL;
+	unsigned long sortkey = he->sortkey;
+
+	if (list_empty(lh)) {
+		list_add(&he->sorted, lh);
+		return;
+	}
+	
+	list_for_each(p, lh) {
+		hlp = list_entry(p, typeof(*hlp), sorted);
+		if (hlp->sortkey >= sortkey) {
+			list_add(&he->sorted, hlp->sorted.prev);
+			return;
+		}
+	}
+	list_add(&he->sorted, &hlp->sorted);
+}
+
+/**
+ * hashlist_iterate - Apply function for all elements in a hash list
+ * @hashlist: pointer to hashlist
+ * @args: data to pass to the function
+ * @func: pointer to a function
+ *
+ * Apply arbitrary function @func to all elements in a hash list.
+ * @func must be a pointer to a function with the following prototype:
+ * int func(void *entry, void *arg, struct in6_addr *hashkey, unsigned
+ * long *sortkey).  Function must return %ITERATOR_STOP,
+ * %ITERATOR_CONT or %ITERATOR_DELETE_ENTRY.  %ITERATOR_STOP stops
+ * iterator and returns last return value from the function.
+ * %ITERATOR_CONT continues with iteration.  %ITERATOR_DELETE_ENTRY
+ * deletes current entry from the hashlist.  If function changes
+ * hashlist element's sortkey, iterator automatically schedules
+ * element to be reinserted after all elements have been processed.
+ */
+int hashlist_iterate(
+	struct hashlist *hashlist, void *args,
+	hashlist_iterator_t func)
+{
+	int res = ITERATOR_CONT;
+	unsigned long skey;
+	struct list_head *p, *n, repos;
+	struct hashlist_entry *he;
+
+	DEBUG_FUNC();
+	INIT_LIST_HEAD(&repos);
+
+	list_for_each_safe(p, n, &hashlist->sortedlist) {
+		he = list_entry(p, typeof(*he), sorted);
+		if (res == ITERATOR_STOP)
+			break;
+		skey = he->sortkey;
+		res = func(he, args, &he->sortkey);
+		if (res == ITERATOR_DELETE_ENTRY) {
+			hashlist_delete(hashlist, he);
+			hashlist_free(hashlist, he);
+		} else if (skey != he->sortkey) {
+			/* iterator changed the sortkey, schedule for
+			 * repositioning */
+			list_move(&he->sorted, &repos);
+		}
+	}
+	list_for_each_safe(p, n, &repos) {	
+		he = list_entry(p, typeof(*he), sorted);
+		sorted_insert(&hashlist->sortedlist, he);
+	}
+	return res;
+}
+
+/**
+ * hashlist_alloc - Allocate memory for a hashlist entry
+ * @hashlist: hashlist for allocated entry
+ * @size: size of entry in bytes
+ *
+ * Allocates @size bytes memory from @hashlist->kmem.
+ **/
+void *hashlist_alloc(struct hashlist *hashlist, int type)
+{
+	if (hashlist == NULL) return NULL;
+	return kmem_cache_alloc(hashlist->kmem, type);
+}
+
+/**
+ * hashlist_free - Free hashlist entry
+ * @hashlist: hashlist where @he is
+ * @he: entry to free
+ *
+ * Frees an allocated hashlist entry.
+ **/
+void hashlist_free(struct hashlist *hashlist, struct hashlist_entry *he)
+{
+	kmem_cache_free(hashlist->kmem, he);
+}
+
+/**
+ * hashlist_add - Add element to hashlist
+ * @hashlist: pointer to hashlist
+ * @hashkey: hashkey for the element
+ * @sortkey: key for sorting
+ * @data: element data
+ *
+ * Add element to hashlist.  Hashlist is also sorted in a linked list
+ * by @sortkey.
+ */
+int hashlist_add(struct hashlist *hashlist, void *hashkey,
+		 unsigned long sortkey, void *entry)
+{
+	struct hashlist_entry *he = (struct hashlist_entry *)entry;
+	unsigned int hash;
+
+	if (hashlist->count >= hashlist->maxcount)
+		return -1;
+
+	hashlist->count++;
+
+	/*  link the entry to sorted order  */ 
+	he->sortkey = sortkey;
+	sorted_insert(&hashlist->sortedlist, he);
+
+	/*  hash the entry  */
+	hash = hashlist->hash_function(hashkey) % hashlist->bucketnum;
+	list_add(&he->hashlist, &hashlist->hashtable[hash]);
+
+	return 0;
+}
+
+/**
+ * hashlist_get - Get element from hashlist
+ * @hashlist: hashlist
+ * @hashkey: hashkey of the desired entry
+ *
+ * Lookup entry with @hashkey from the hash table.  Returns entry on
+ * success, otherwise %NULL.
+ **/
+struct hashlist_entry *hashlist_get(struct hashlist *hashlist, void *hashkey)
+{
+	struct list_head *p, *bkt;
+	__u32 hash;
+
+	hash = hashlist->hash_function(hashkey) % hashlist->bucketnum;
+	bkt = &hashlist->hashtable[hash];
+
+	/*  scan the entries within the same hashbucket  */
+	list_for_each(p, bkt) {
+		struct hashlist_entry *he = list_entry(p, typeof(*he), 
+						       hashlist);
+		if (hashlist->compare(he, hashkey) == 0)
+			return he;
+	}
+
+	return NULL;
+}
+
+/**
+ * hashlist_reposition - set entry to new position in the list
+ * @hashlist: hashlist
+ * @he: entry to reposition
+ * @sortkey: new sortkey of the entry
+ *
+ * If secondary order sortkey changes, entry must be repositioned in
+ * the sorted list.
+ **/
+int hashlist_reposition(struct hashlist *hashlist, struct hashlist_entry *he,
+			unsigned long sortkey)
+{
+	list_del(&he->sorted);
+	he->sortkey = sortkey;
+	sorted_insert(&hashlist->sortedlist, he);
+
+	return 0;
+}
+
+/*
+ * current implementation is no faster than hashlist_get, if you need
+ * to check if something exists and then possibly use it, then use
+ * hashlist_get function.
+ */
+int hashlist_exists(struct hashlist *hashlist, void *hashkey)
+{
+	return (hashlist_get(hashlist, hashkey) != NULL);
+}
+
+/**
+ * hashlist_delete - Delete entry from hashlist
+ * @hashlist: hashlist where entry is
+ * @he: entry to delete
+ *
+ * Deletes an entry from the hashlist and sorted list.
+ **/
+void hashlist_delete(struct hashlist *hashlist,
+		     struct hashlist_entry *he)
+{
+	list_del_init(&he->hashlist);
+	list_del_init(&he->sorted);
+
+	hashlist->count--;
+}
+
+/**
+ * hashlist_get_first - Get first item from sorted list
+ * @hashlist: pointer to hashlist
+ *
+ * Returns first item in the secondary sort order.
+ **/
+void * hashlist_get_first(struct hashlist *hashlist)
+{
+	if (list_empty(&hashlist->sortedlist))
+		return NULL;
+	
+	return list_entry(hashlist->sortedlist.next, struct hashlist_entry, sorted);
+}
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/hashlist.h linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/hashlist.h
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/hashlist.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/hashlist.h	2003-05-18 11:33:53.000000000 +0200
@@ -0,0 +1,97 @@
+/*
+ *	Header file for sorted list which can be accessed via hashkey
+ *
+ *	Authors:
+ *	Sami Kivisaari		<skivisaa@cc.hut.fi>	
+ *
+ *	$Id: s.hashlist.h 1.8 02/11/25 11:18:16+02:00 vnuorval@amber.hut.mediapoli.com $
+ *
+ *	This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ */
+
+#ifndef _HASHLIST_H
+#define _HASHLIST_H
+
+#define ITERATOR_ERR -1
+#define ITERATOR_CONT 0
+#define ITERATOR_STOP 1
+#define ITERATOR_DELETE_ENTRY 2
+
+struct hashlist_entry {
+	unsigned long sortkey;
+	struct list_head sorted;
+	struct list_head hashlist;
+};
+
+/*
+ * hashlist_create - create new hashlist
+ */
+struct hashlist * hashlist_create(
+	int bucketnum, int max_entries, size_t size, char *name,
+	void (*ctor)(void *, kmem_cache_t *, unsigned long),
+	void (*dtor)(void *, kmem_cache_t *, unsigned long),
+	int (*compare)(void *data, void *hashkey),
+	__u32 (*hash_function)(void *hashkey),
+	void *(*get_hashkey)(void *data));
+
+/*
+ * hashlist_destroy - destroy a hashlist object
+ */
+void hashlist_destroy(struct hashlist *hashlist);
+
+/**
+ * hashlist_get - get element from hashlist
+ **/
+struct hashlist_entry *hashlist_get(struct hashlist *hashlist, void *hashkey);
+
+/*
+ * hashlist_alloc - allocate memory for new entry
+ */
+void *hashlist_alloc(struct hashlist *hashlist, int type);
+
+/*
+ * hashlist_free - free allocated entry
+ */
+void hashlist_free(struct hashlist *hashlist, struct hashlist_entry *he);
+/*
+ * hashlist_exists - check if element exists in hashlist
+ */
+int hashlist_exists(struct hashlist *hashlist, void *hashkey);
+
+/*
+ * hashlist_delete - delete entry from hashlist
+ */
+void hashlist_delete(struct hashlist *hashlist, struct hashlist_entry *he);
+
+/*
+ * hashlist_add - add a new entry to hashlist
+ */
+int hashlist_add(struct hashlist *hashlist, void *hashkey,
+		 unsigned long sortkey, void *data);
+
+/*
+ * iterator function
+ */
+typedef int (*hashlist_iterator_t)(void *, void *, unsigned long *);
+
+/*
+ * hashlist_iterate - apply an iterator function for all items in hashlist
+ */
+int hashlist_iterate(struct hashlist *hashlist, void *args,
+		     hashlist_iterator_t func);
+
+/*
+ * hashlist_get_first - return pointer to first element in structure
+ */
+void * hashlist_get_first(struct hashlist *hashlist);
+
+/*
+ * hashlist_reschedule - set entry to new position in the list
+ */
+int hashlist_reposition(struct hashlist *hashlist, struct hashlist_entry *he,
+			unsigned long sortkey);
+
+#endif
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/hmac.c linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/hmac.c
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/hmac.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/hmac.c	2003-05-18 11:33:53.000000000 +0200
@@ -0,0 +1,658 @@
+/*     Authentication algorithms       
+ *	
+ *      Authors: 
+ *       Alexis Olivereau              <Alexis.Olivereau@crm.mot.com>
+ * 
+ *      $Id: s.hmac.c 1.13 02/11/25 11:18:16+02:00 vnuorval@amber.hut.mediapoli.com $
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ *
+ *      Changes: 
+ *      Henrik Petander     :     Cleaned up unused parts
+ *
+ */
+
+#include <linux/sched.h>
+#include <linux/tty.h>
+#include <linux/types.h>
+#include <linux/slab.h>
+#include <linux/in6.h>
+
+#include "hmac.h"
+#define LROLL(x, s) (((x) << (s)) | ((x) >> (32 - (s))))
+
+/* MD5 */
+#define F(x, y, z) ((z) ^ ((x) & ((y) ^ (z))))
+#define G(x, y, z) ((y) ^ ((z) & ((x) ^ (y))))
+#define H(x, y, z) ((x) ^ (y) ^ (z))
+#define I(x, y, z) ((y) ^ ((x) | ~(z)))
+
+#define FF(a, b, c, d, m, s, t) { \
+ (a) += F ((b), (c), (d)) + (m) + (t); \
+ (a) = LROLL((a), (s)); \
+ (a) += (b); \
+ }
+#define GG(a, b, c, d, m, s, t) { \
+ (a) += G ((b), (c), (d)) + (m) + (t); \
+ (a) = LROLL((a), (s)); \
+ (a) += (b); \
+ }
+#define HH(a, b, c, d, m, s, t) { \
+ (a) += H ((b), (c), (d)) + (m) + (t); \
+ (a) = LROLL((a), (s)); \
+ (a) += (b); \
+ }
+#define II(a, b, c, d, m, s, t) { \
+ (a) += I ((b), (c), (d)) + (m) + (t); \
+ (a) = LROLL((a), (s)); \
+ (a) += (b); \
+ }
+
+#define s11  7
+#define s12 12
+#define s13 17
+#define s14 22
+#define s21  5
+#define s22  9
+#define s23 14
+#define s24 20
+#define s31  4
+#define s32 11
+#define s33 16
+#define s34 23
+#define s41  6
+#define s42 10
+#define s43 15
+#define s44 21
+
+/* SHA-1 */
+#define f(x, y, z) ((z) ^ ((x) & ((y) ^ (z))))
+#define g(x, y, z) (((x) & (y)) | ((x) & (z)) | ((y) & (z)))
+#define h(x, y, z) ((x) ^ (y) ^ (z))
+
+#define K1 0x5a827999
+#define K2 0x6ed9eba1
+#define K3 0x8f1bbcdc
+#define K4 0xca62c1d6
+
+int ah_hmac_md5_init(struct ah_processing *ahp, u_int8_t *key, u_int32_t key_len)
+{
+	int i;
+	int key_up4;
+	uint32_t ipad = 0x36363636;
+	uint8_t extkey[64];
+
+	ahp->key_auth = key;
+	ahp->key_auth_len = key_len;
+	ahp->context = (void *) kmalloc(sizeof(MD5_CTX), GFP_ATOMIC);
+	if (ahp->context == NULL)
+		return -1;
+	md5_init((MD5_CTX *) ahp->context);
+	if ((64 * sizeof(uint8_t)) < ahp->key_auth_len) {
+		printk("buffer overflow!");
+		return -1;
+	}
+	memcpy(extkey, ahp->key_auth, ahp->key_auth_len);
+	if (ahp->key_auth_len % 4) {
+		memset(extkey + ahp->key_auth_len, 0,
+		       4 - (ahp->key_auth_len % 4));
+	}
+	key_up4 = ((ahp->key_auth_len + 0x3) & 0xFFFFFFFC) / 4;
+
+	for (i = 0; i < key_up4; i++)
+		((uint32_t *) extkey)[i] = ((uint32_t *) extkey)[i] ^ ipad;
+	for (i = key_up4; i < 16; i++)
+		((uint32_t *) extkey)[i] = ipad;
+
+	md5_compute((MD5_CTX *) ahp->context, extkey, 64);
+	return 0;
+}
+
+void ah_hmac_md5_loop(struct ah_processing *ahp, void *str, uint32_t len)
+{
+	md5_compute((MD5_CTX *) ahp->context, str, len);
+}
+
+void ah_hmac_md5_result(struct ah_processing *ahp, char *digest)
+{
+	uint8_t inner[HMAC_MD5_HASH_LEN];
+	int i;
+	int key_up4;
+	uint32_t opad = 0x5c5c5c5c;
+	uint8_t extkey[64];
+
+	md5_final((MD5_CTX *) ahp->context, inner);
+	md5_init((MD5_CTX *) ahp->context);
+
+	memcpy(extkey, ahp->key_auth, ahp->key_auth_len);
+	if (ahp->key_auth_len % 4) {
+		memset(extkey + ahp->key_auth_len, 0,
+		       4 - (ahp->key_auth_len % 4));
+	}
+	key_up4 = ((ahp->key_auth_len + 0x3) & 0xFFFFFFFC) / 4;
+
+	for (i = 0; i < key_up4; i++)
+		((uint32_t *) extkey)[i] = ((uint32_t *) extkey)[i] ^ opad;
+	for (i = key_up4; i < 16; i++)
+		((uint32_t *) extkey)[i] = opad;
+
+	md5_compute((MD5_CTX *) ahp->context, extkey, 64);
+	md5_compute((MD5_CTX *) ahp->context, inner, HMAC_MD5_HASH_LEN);
+
+	md5_final((MD5_CTX *) ahp->context, digest);
+
+	kfree(ahp->context);
+}
+
+int ah_hmac_sha1_init(struct ah_processing *ahp, u_int8_t *key, u_int32_t key_len)
+{
+	int i;
+	int key_up4;
+	uint32_t ipad = 0x36363636;
+	uint8_t extkey[64];
+
+	ahp->key_auth = key;
+	ahp->key_auth_len = key_len;
+
+	ahp->context = (void *) kmalloc(sizeof(SHA1_CTX), GFP_ATOMIC);
+	//if (ahp->context == NULL)
+	//	return -1;
+
+	sha1_init((SHA1_CTX *) ahp->context);
+
+	memcpy(extkey, ahp->key_auth, ahp->key_auth_len);
+	if (ahp->key_auth_len % 4) {
+		memset(extkey + ahp->key_auth_len, 0,
+		       4 - (ahp->key_auth_len % 4));
+	}
+	key_up4 = ((ahp->key_auth_len + 0x3) & 0xFFFFFFFC) / 4;
+
+	for (i = 0; i < key_up4; i++)
+		((uint32_t *) extkey)[i] = ((uint32_t *) extkey)[i] ^ ipad;
+	for (i = key_up4; i < 16; i++)
+		((uint32_t *) extkey)[i] = ipad;
+
+	sha1_compute((SHA1_CTX *) ahp->context, extkey, 64);
+	return 0;
+}
+
+void ah_hmac_sha1_loop(struct ah_processing *ahp, void *str, uint32_t len)
+{
+	if (!ahp)
+		return;
+	sha1_compute((SHA1_CTX *) ahp->context, str, len);
+}
+
+void ah_hmac_sha1_result(struct ah_processing *ahp, char *digest)
+{
+	uint8_t inner[HMAC_SHA1_HASH_LEN];
+	int i;
+	int key_up4;
+	uint32_t opad = 0x5c5c5c5c;
+	uint8_t extkey[64];
+
+	if (!ahp)
+		return;
+	sha1_final((SHA1_CTX *) ahp->context, inner);
+	sha1_init((SHA1_CTX *) ahp->context);
+
+	memcpy(extkey, ahp->key_auth, ahp->key_auth_len);
+	if (ahp->key_auth_len % 4) {
+		memset(extkey + ahp->key_auth_len, 0,
+		       4 - (ahp->key_auth_len % 4));
+	}
+	key_up4 = ((ahp->key_auth_len + 0x3) & 0xFFFFFFFC) / 4;
+
+	for (i = 0; i < key_up4; i++)
+		((uint32_t *) extkey)[i] = ((uint32_t *) extkey)[i] ^ opad;
+	for (i = key_up4; i < 16; i++)
+		((uint32_t *) extkey)[i] = opad;
+
+	sha1_compute((SHA1_CTX *) ahp->context, extkey, 64);
+	sha1_compute((SHA1_CTX *) ahp->context, inner,
+		     HMAC_SHA1_HASH_LEN);
+
+	sha1_final((SHA1_CTX *) ahp->context, digest);
+
+	kfree(ahp->context);
+}
+
+void md5_init(MD5_CTX * ctx)
+{
+	ctx->A = 0x67452301;
+	ctx->B = 0xefcdab89;
+	ctx->C = 0x98badcfe;
+	ctx->D = 0x10325476;
+	ctx->buf_cur = ctx->buf;
+	ctx->bitlen[0] = ctx->bitlen[1] = 0;
+	memset(ctx->buf, 0, 64);
+}
+
+void md5_over_block(MD5_CTX * ctx, uint8_t * data)
+{
+	uint32_t M[16];
+	uint32_t a = ctx->A;
+	uint32_t b = ctx->B;
+	uint32_t c = ctx->C;
+	uint32_t d = ctx->D;
+
+	create_M_blocks(M, data);
+
+	/* Round 1 */
+	FF(a, b, c, d, M[0], s11, 0xd76aa478);	/*  1 */
+	FF(d, a, b, c, M[1], s12, 0xe8c7b756);	/*  2 */
+	FF(c, d, a, b, M[2], s13, 0x242070db);	/*  3 */
+	FF(b, c, d, a, M[3], s14, 0xc1bdceee);	/*  4 */
+	FF(a, b, c, d, M[4], s11, 0xf57c0faf);	/*  5 */
+	FF(d, a, b, c, M[5], s12, 0x4787c62a);	/*  6 */
+	FF(c, d, a, b, M[6], s13, 0xa8304613);	/*  7 */
+	FF(b, c, d, a, M[7], s14, 0xfd469501);	/*  8 */
+	FF(a, b, c, d, M[8], s11, 0x698098d8);	/*  9 */
+	FF(d, a, b, c, M[9], s12, 0x8b44f7af);	/* 10 */
+	FF(c, d, a, b, M[10], s13, 0xffff5bb1);	/* 11 */
+	FF(b, c, d, a, M[11], s14, 0x895cd7be);	/* 12 */
+	FF(a, b, c, d, M[12], s11, 0x6b901122);	/* 13 */
+	FF(d, a, b, c, M[13], s12, 0xfd987193);	/* 14 */
+	FF(c, d, a, b, M[14], s13, 0xa679438e);	/* 15 */
+	FF(b, c, d, a, M[15], s14, 0x49b40821);	/* 16 */
+
+	/* Round 2 */
+	GG(a, b, c, d, M[1], s21, 0xf61e2562);	/* 17 */
+	GG(d, a, b, c, M[6], s22, 0xc040b340);	/* 18 */
+	GG(c, d, a, b, M[11], s23, 0x265e5a51);	/* 19 */
+	GG(b, c, d, a, M[0], s24, 0xe9b6c7aa);	/* 20 */
+	GG(a, b, c, d, M[5], s21, 0xd62f105d);	/* 21 */
+	GG(d, a, b, c, M[10], s22, 0x02441453);	/* 22 */
+	GG(c, d, a, b, M[15], s23, 0xd8a1e681);	/* 23 */
+	GG(b, c, d, a, M[4], s24, 0xe7d3fbc8);	/* 24 */
+	GG(a, b, c, d, M[9], s21, 0x21e1cde6);	/* 25 */
+	GG(d, a, b, c, M[14], s22, 0xc33707d6);	/* 26 */
+	GG(c, d, a, b, M[3], s23, 0xf4d50d87);	/* 27 */
+	GG(b, c, d, a, M[8], s24, 0x455a14ed);	/* 28 */
+	GG(a, b, c, d, M[13], s21, 0xa9e3e905);	/* 29 */
+	GG(d, a, b, c, M[2], s22, 0xfcefa3f8);	/* 30 */
+	GG(c, d, a, b, M[7], s23, 0x676f02d9);	/* 31 */
+	GG(b, c, d, a, M[12], s24, 0x8d2a4c8a);	/* 32 */
+
+	/* Round 3 */
+	HH(a, b, c, d, M[5], s31, 0xfffa3942);	/* 33 */
+	HH(d, a, b, c, M[8], s32, 0x8771f681);	/* 34 */
+	HH(c, d, a, b, M[11], s33, 0x6d9d6122);	/* 35 */
+	HH(b, c, d, a, M[14], s34, 0xfde5380c);	/* 36 */
+	HH(a, b, c, d, M[1], s31, 0xa4beea44);	/* 37 */
+	HH(d, a, b, c, M[4], s32, 0x4bdecfa9);	/* 38 */
+	HH(c, d, a, b, M[7], s33, 0xf6bb4b60);	/* 39 */
+	HH(b, c, d, a, M[10], s34, 0xbebfbc70);	/* 40 */
+	HH(a, b, c, d, M[13], s31, 0x289b7ec6);	/* 41 */
+	HH(d, a, b, c, M[0], s32, 0xeaa127fa);	/* 42 */
+	HH(c, d, a, b, M[3], s33, 0xd4ef3085);	/* 43 */
+	HH(b, c, d, a, M[6], s34, 0x4881d05);	/* 44 */
+	HH(a, b, c, d, M[9], s31, 0xd9d4d039);	/* 45 */
+	HH(d, a, b, c, M[12], s32, 0xe6db99e5);	/* 46 */
+	HH(c, d, a, b, M[15], s33, 0x1fa27cf8);	/* 47 */
+	HH(b, c, d, a, M[2], s34, 0xc4ac5665);	/* 48 */
+
+	/* Round 4 */
+	II(a, b, c, d, M[0], s41, 0xf4292244);	/* 49 */
+	II(d, a, b, c, M[7], s42, 0x432aff97);	/* 50 */
+	II(c, d, a, b, M[14], s43, 0xab9423a7);	/* 51 */
+	II(b, c, d, a, M[5], s44, 0xfc93a039);	/* 52 */
+	II(a, b, c, d, M[12], s41, 0x655b59c3);	/* 53 */
+	II(d, a, b, c, M[3], s42, 0x8f0ccc92);	/* 54 */
+	II(c, d, a, b, M[10], s43, 0xffeff47d);	/* 55 */
+	II(b, c, d, a, M[1], s44, 0x85845dd1);	/* 56 */
+	II(a, b, c, d, M[8], s41, 0x6fa87e4f);	/* 57 */
+	II(d, a, b, c, M[15], s42, 0xfe2ce6e0);	/* 58 */
+	II(c, d, a, b, M[6], s43, 0xa3014314);	/* 59 */
+	II(b, c, d, a, M[13], s44, 0x4e0811a1);	/* 60 */
+	II(a, b, c, d, M[4], s41, 0xf7537e82);	/* 61 */
+	II(d, a, b, c, M[11], s42, 0xbd3af235);	/* 62 */
+	II(c, d, a, b, M[2], s43, 0x2ad7d2bb);	/* 63 */
+	II(b, c, d, a, M[9], s44, 0xeb86d391);	/* 64 */
+
+	ctx->A += a;
+	ctx->B += b;
+	ctx->C += c;
+	ctx->D += d;
+}
+
+void create_M_blocks(uint32_t * M, uint8_t * data)
+{
+#ifdef HAVE_LITTLE_ENDIAN
+	memcpy((uint8_t *) M, data, 64);
+#endif				/* HAVE_LITTLE_ENDIAN */
+
+#ifdef HAVE_BIG_ENDIAN
+	int i;
+	for (i = 0; i < 16; i++, data += 4) {
+		((uint8_t *) (&M[i]))[0] = data[3];
+		((uint8_t *) (&M[i]))[1] = data[2];
+		((uint8_t *) (&M[i]))[2] = data[1];
+		((uint8_t *) (&M[i]))[3] = data[0];
+	}
+#endif				/* HAVE_BIG_ENDIAN */
+}
+
+void md5_compute(MD5_CTX * ctx, uint8_t * data, uint32_t len)
+{
+	uint8_t pos = ((ctx->bitlen[0] >> 3) & 0x3f);
+
+	/* First we update the bit length */
+	if ((ctx->bitlen[0] += (len << 3)) < (len << 3))
+		ctx->bitlen[1]++;
+	ctx->bitlen[1] += (len >> 29);	/* len is expressed in bytes */
+
+	if (pos) {
+		/* Buffer is not empty */
+		if (64 - pos >= len) {
+			memcpy(ctx->buf_cur, data, len);
+			ctx->buf_cur += len;
+			pos += len;
+			if (pos == 64) {
+				/* The current block is over */
+				md5_over_block(ctx, ctx->buf);
+				ctx->buf_cur = ctx->buf;
+			}
+			return;
+		} else {
+			memcpy(ctx->buf_cur, data, 64 - pos);
+			md5_over_block(ctx, ctx->buf);
+			len -= (64 - pos);
+			data += (64 - pos);
+			ctx->buf_cur = ctx->buf;
+		}
+	}
+	while (len >= 64) {
+		md5_over_block(ctx, data);
+		len -= 64;
+		data += 64;
+	}
+	if (len) {
+		memcpy(ctx->buf_cur, data, len);
+		ctx->buf_cur += len;
+	}
+}
+
+void md5_final(MD5_CTX * ctx, uint8_t * digest)
+{
+	uint32_t rem_size;
+	uint8_t *buf_cur = ctx->buf_cur;
+	int i;
+
+	rem_size = 64 - ((ctx->bitlen[0] >> 3) & 0x3f);
+	*(buf_cur++) = 0x80;
+
+	if (rem_size > 8 + 1) {
+		/* We have enough room in the current block */
+		for (i = 0; i < rem_size - 8 - 1; i++) {
+			*(buf_cur++) = 0;
+		}
+	} else {
+		/* We do not have enough room and need therefore to add a new
+		   64-byte block */
+		for (i = 0; i < rem_size - 1; i++) {
+			*(buf_cur++) = 0;
+		}
+		md5_over_block(ctx, ctx->buf);
+
+		buf_cur = ctx->buf;
+		for (i = 0; i < 64 - 8; i++) {
+			*(buf_cur++) = 0;
+		}
+	}
+#ifdef HAVE_LITTLE_ENDIAN
+	memcpy(buf_cur, (uint8_t *) ctx->bitlen, 8);
+#endif				/* HAVE_LITTLE_ENDIAN */
+
+#ifdef HAVE_BIG_ENDIAN
+	*(buf_cur++) = (ctx->bitlen[0] >> 24) & 0xff;
+	*(buf_cur++) = (ctx->bitlen[0] >> 16) & 0xff;
+	*(buf_cur++) = (ctx->bitlen[0] >> 8) & 0xff;
+	*(buf_cur++) = (ctx->bitlen[0] >> 0) & 0xff;
+	*(buf_cur++) = (ctx->bitlen[1] >> 24) & 0xff;
+	*(buf_cur++) = (ctx->bitlen[1] >> 16) & 0xff;
+	*(buf_cur++) = (ctx->bitlen[1] >> 8) & 0xff;
+	*(buf_cur++) = (ctx->bitlen[1] >> 0) & 0xff;
+#endif				/* HAVE_BIG_ENDIAN */
+
+	md5_over_block(ctx, ctx->buf);
+
+#ifdef HAVE_LITTLE_ENDIAN
+	memcpy(digest + 0, (uint8_t *) (&(ctx->A)), sizeof(uint32_t));
+	memcpy(digest + 4, (uint8_t *) (&(ctx->B)), sizeof(uint32_t));
+	memcpy(digest + 8, (uint8_t *) (&(ctx->C)), sizeof(uint32_t));
+	memcpy(digest + 12, (uint8_t *) (&(ctx->D)), sizeof(uint32_t));
+#endif				/* HAVE_LITTLE_ENDIAN */
+
+#ifdef HAVE_BIG_ENDIAN
+	digest[0] = ((ctx->A) >> 24) & 0xff;
+	digest[1] = ((ctx->A) >> 16) & 0xff;
+	digest[2] = ((ctx->A) >> 8) & 0xff;
+	digest[3] = ((ctx->A) >> 0) & 0xff;
+	digest[4] = ((ctx->B) >> 24) & 0xff;
+	digest[5] = ((ctx->B) >> 16) & 0xff;
+	digest[6] = ((ctx->B) >> 8) & 0xff;
+	digest[7] = ((ctx->B) >> 0) & 0xff;
+	digest[8] = ((ctx->C) >> 24) & 0xff;
+	digest[9] = ((ctx->C) >> 16) & 0xff;
+	digest[10] = ((ctx->C) >> 8) & 0xff;
+	digest[11] = ((ctx->C) >> 0) & 0xff;
+	digest[12] = ((ctx->D) >> 24) & 0xff;
+	digest[13] = ((ctx->D) >> 16) & 0xff;
+	digest[14] = ((ctx->D) >> 8) & 0xff;
+	digest[15] = ((ctx->D) >> 0) & 0xff;
+#endif				/* HAVE_BIG_ENDIAN */
+}
+
+void sha1_init(SHA1_CTX * ctx)
+{
+	ctx->A = 0x67452301;
+	ctx->B = 0xefcdab89;
+	ctx->C = 0x98badcfe;
+	ctx->D = 0x10325476;
+	ctx->E = 0xc3d2e1f0;
+	ctx->buf_cur = ctx->buf;
+	ctx->bitlen[0] = ctx->bitlen[1] = 0;
+	memset(ctx->buf, 0, 64);
+}
+
+void sha1_over_block(SHA1_CTX * ctx, uint8_t * data)
+{
+	int i;
+	uint32_t W[80];
+	uint32_t a = ctx->A;
+	uint32_t b = ctx->B;
+	uint32_t c = ctx->C;
+	uint32_t d = ctx->D;
+	uint32_t e = ctx->E;
+	uint32_t temp;
+
+	create_W_blocks(W, data);
+
+	/* Round 1 */
+	for (i = 0; i < 20; i++) {
+		temp = LROLL(a, 5) + f(b, c, d) + e + W[i] + K1;
+		e = d;
+		d = c;
+		c = LROLL(b, 30);
+		b = a;
+		a = temp;
+	}
+
+	/* Round 2 */
+	for (i = 20; i < 40; i++) {
+		temp = LROLL(a, 5) + h(b, c, d) + e + W[i] + K2;
+		e = d;
+		d = c;
+		c = LROLL(b, 30);
+		b = a;
+		a = temp;
+	}
+
+	/* Round 3 */
+	for (i = 40; i < 60; i++) {
+		temp = LROLL(a, 5) + g(b, c, d) + e + W[i] + K3;
+		e = d;
+		d = c;
+		c = LROLL(b, 30);
+		b = a;
+		a = temp;
+	}
+
+	/* Round 4 */
+	for (i = 60; i < 80; i++) {
+		temp = LROLL(a, 5) + h(b, c, d) + e + W[i] + K4;
+		e = d;
+		d = c;
+		c = LROLL(b, 30);
+		b = a;
+		a = temp;
+	}
+
+	ctx->A += a;
+	ctx->B += b;
+	ctx->C += c;
+	ctx->D += d;
+	ctx->E += e;
+}
+
+void create_W_blocks(uint32_t * W, uint8_t * data)
+{
+	int i;
+
+#ifdef HAVE_BIG_ENDIAN
+	memcpy((uint8_t *) W, data, 64);
+#endif				/* HAVE_BIG_ENDIAN */
+
+#ifdef HAVE_LITTLE_ENDIAN
+	for (i = 0; i < 16; i++, data += 4) {
+		((uint8_t *) (&W[i]))[0] = data[3];
+		((uint8_t *) (&W[i]))[1] = data[2];
+		((uint8_t *) (&W[i]))[2] = data[1];
+		((uint8_t *) (&W[i]))[3] = data[0];
+	}
+#endif				/* HAVE_LITTLE_ENDIAN */
+	for (i = 16; i < 80; i++) {
+		W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
+		W[i] = LROLL(W[i], 1);
+	}
+}
+
+void sha1_compute(SHA1_CTX * ctx, uint8_t * data, uint32_t len)
+{
+	uint8_t pos = ((ctx->bitlen[0] >> 3) & 0x3f);
+
+	/* First we update the bit length */
+	if ((ctx->bitlen[0] += (len << 3)) < (len << 3))
+		ctx->bitlen[1]++;
+	ctx->bitlen[1] += (len >> 29);	/* len is expressed in bytes */
+
+	if (pos) {
+		/* Buffer is not empty */
+		if (64 - pos >= len) {
+			memcpy(ctx->buf_cur, data, len);
+			ctx->buf_cur += len;
+			pos += len;
+			if (pos == 64) {
+				/* The current block is over */
+				sha1_over_block(ctx, ctx->buf);
+				ctx->buf_cur = ctx->buf;
+			}
+			return;
+		} else {
+			memcpy(ctx->buf_cur, data, 64 - pos);
+			sha1_over_block(ctx, ctx->buf);
+			len -= (64 - pos);
+			data += (64 - pos);
+			ctx->buf_cur = ctx->buf;
+		}
+	}
+	while (len >= 64) {
+		sha1_over_block(ctx, data);
+		len -= 64;
+		data += 64;
+	}
+	if (len) {
+		memcpy(ctx->buf_cur, data, len);
+		ctx->buf_cur += len;
+	}
+}
+
+void sha1_final(SHA1_CTX * ctx, uint8_t * digest)
+{
+	uint32_t rem_size;
+	uint8_t *buf_cur = ctx->buf_cur;
+	int i;
+
+	rem_size = 64 - ((ctx->bitlen[0] >> 3) & 0x3f);
+	*(buf_cur++) = 0x80;
+
+	if (rem_size > 8 + 1) {
+		/* We have enough room in the current block */
+		for (i = 0; i < rem_size - 8 - 1; i++) {
+			*(buf_cur++) = 0;
+		}
+	} else {
+		/* We do not have enough room and need therefore to add a new
+		   64-byte block */
+		for (i = 0; i < rem_size - 1; i++) {
+			*(buf_cur++) = 0;
+		}
+		sha1_over_block(ctx, ctx->buf);
+
+		buf_cur = ctx->buf;
+		for (i = 0; i < 64 - 8; i++) {
+			*(buf_cur++) = 0;
+		}
+	}
+#ifdef HAVE_BIG_ENDIAN
+	memcpy(buf_cur, (uint8_t *) ctx->bitlen, 8);
+#endif				/* HAVE_BIG_ENDIAN */
+
+#ifdef HAVE_LITTLE_ENDIAN
+	*(buf_cur++) = (ctx->bitlen[1] >> 24) & 0xff;
+	*(buf_cur++) = (ctx->bitlen[1] >> 16) & 0xff;
+	*(buf_cur++) = (ctx->bitlen[1] >> 8) & 0xff;
+	*(buf_cur++) = (ctx->bitlen[1] >> 0) & 0xff;
+	*(buf_cur++) = (ctx->bitlen[0] >> 24) & 0xff;
+	*(buf_cur++) = (ctx->bitlen[0] >> 16) & 0xff;
+	*(buf_cur++) = (ctx->bitlen[0] >> 8) & 0xff;
+	*(buf_cur++) = (ctx->bitlen[0] >> 0) & 0xff;
+#endif				/* HAVE_LITTLE_ENDIAN */
+
+	sha1_over_block(ctx, ctx->buf);
+
+#ifdef HAVE_BIG_ENDIAN
+	memcpy(digest + 0, (uint8_t *) (&(ctx->A)), sizeof(uint32_t));
+	memcpy(digest + 4, (uint8_t *) (&(ctx->B)), sizeof(uint32_t));
+	memcpy(digest + 8, (uint8_t *) (&(ctx->C)), sizeof(uint32_t));
+	memcpy(digest + 12, (uint8_t *) (&(ctx->D)), sizeof(uint32_t));
+	memcpy(digest + 16, (uint8_t *) (&(ctx->E)), sizeof(uint32_t));
+#endif				/* HAVE_BIG_ENDIAN */
+
+#ifdef HAVE_LITTLE_ENDIAN
+	digest[0] = ((ctx->A) >> 24) & 0xff;
+	digest[1] = ((ctx->A) >> 16) & 0xff;
+	digest[2] = ((ctx->A) >> 8) & 0xff;
+	digest[3] = ((ctx->A) >> 0) & 0xff;
+	digest[4] = ((ctx->B) >> 24) & 0xff;
+	digest[5] = ((ctx->B) >> 16) & 0xff;
+	digest[6] = ((ctx->B) >> 8) & 0xff;
+	digest[7] = ((ctx->B) >> 0) & 0xff;
+	digest[8] = ((ctx->C) >> 24) & 0xff;
+	digest[9] = ((ctx->C) >> 16) & 0xff;
+	digest[10] = ((ctx->C) >> 8) & 0xff;
+	digest[11] = ((ctx->C) >> 0) & 0xff;
+	digest[12] = ((ctx->D) >> 24) & 0xff;
+	digest[13] = ((ctx->D) >> 16) & 0xff;
+	digest[14] = ((ctx->D) >> 8) & 0xff;
+	digest[15] = ((ctx->D) >> 0) & 0xff;
+	digest[16] = ((ctx->E) >> 24) & 0xff;
+	digest[17] = ((ctx->E) >> 16) & 0xff;
+	digest[18] = ((ctx->E) >> 8) & 0xff;
+	digest[19] = ((ctx->E) >> 0) & 0xff;
+#endif				/* HAVE_LITTLE_ENDIAN */
+}
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/hmac.h linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/hmac.h
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/hmac.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/hmac.h	2003-05-18 11:33:53.000000000 +0200
@@ -0,0 +1,97 @@
+/*     Message authentication algorithms        
+ *	
+ *      Authors: 
+ *      Alexis Olivereau              <Alexis.Olivereau@crm.mot.com>
+ * 
+ *      $Id: s.hmac.h 1.7 02/10/16 16:51:41+03:00 henkku@mart10.hut.mediapoli.com $
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ *
+ *
+ */
+#ifndef _HMAC_H
+#define _HMAC_H
+
+#include <linux/types.h>
+#include <linux/in6.h>
+
+#define HAVE_LITTLE_ENDIAN
+
+#define NO_EXPIRY 1  /* For sec_as */
+
+#define ALG_AUTH_NONE           0
+#define ALG_AUTH_HMAC_MD5       1
+#define ALG_AUTH_HMAC_SHA1      2
+
+struct sec_as;
+struct ah_processing {
+	void *context;
+	struct sec_as *sas;
+	u_int8_t *key_auth;
+	u_int32_t key_auth_len;
+};
+
+struct antireplay {
+	u_int32_t count;
+	u_int32_t bitmap; 
+};
+
+typedef struct {
+  u_int32_t A, B, C, D;
+  u_int32_t bitlen[2];
+  u_int8_t* buf_cur;
+  u_int8_t buf[64];
+} MD5_CTX;
+
+typedef struct {
+  u_int32_t A, B, C, D, E;
+  u_int32_t bitlen[2];
+  u_int8_t* buf_cur;
+  u_int8_t buf[64];
+} SHA1_CTX;
+
+
+
+int ah_hmac_md5_init (struct ah_processing *ahp, u_int8_t *key, u_int32_t key_len);
+void ah_hmac_md5_loop(struct ah_processing*, void*, u_int32_t);
+void ah_hmac_md5_result(struct ah_processing*, char*);
+int ah_hmac_sha1_init(struct ah_processing*, u_int8_t *key, u_int32_t key_len);
+void ah_hmac_sha1_loop(struct ah_processing*, void*, u_int32_t);
+void ah_hmac_sha1_result(struct ah_processing*, char*);
+
+
+#define AH_HDR_LEN 12   /* # of bytes for Next Header, Payload Length,
+                           RESERVED, Security Parameters Index and
+
+                           Sequence Number Field */
+
+void md5_init(MD5_CTX *ctx);
+void md5_over_block(MD5_CTX *ctx, u_int8_t* data);
+void create_M_blocks(u_int32_t* M, u_int8_t* data);
+void md5_compute(MD5_CTX *ctx, u_int8_t* data, u_int32_t len);
+void md5_final(MD5_CTX *ctx, u_int8_t* digest);
+
+void sha1_init(SHA1_CTX *ctx);
+void sha1_over_block(SHA1_CTX *ctx, u_int8_t* data);
+void create_W_blocks(u_int32_t* W, u_int8_t* data);
+void sha1_compute(SHA1_CTX *ctx, u_int8_t* data, u_int32_t len);
+void sha1_final(SHA1_CTX *ctx, u_int8_t* digest);
+
+struct mipv6_acq {
+	struct in6_addr coa;
+	struct in6_addr haddr;
+	struct in6_addr peer;
+	u_int32_t spi;
+};
+#define MIPV6_MAX_AUTH_DATA 20
+
+#define HMAC_MD5_HASH_LEN   16
+#define HMAC_SHA1_HASH_LEN  20
+#define HMAC_SHA1_KEY_SIZE  20
+#define HMAC_MD5_ICV_LEN   12 /* RFC 2403 */
+#define HMAC_SHA1_ICV_LEN  12 /* RFC 2404 */
+
+#endif /* _HMAC_H */
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/ioctl_mn.c linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/ioctl_mn.c
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/ioctl_mn.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/ioctl_mn.c	2003-05-18 11:33:53.000000000 +0200
@@ -0,0 +1,137 @@
+/*
+ *	Mobile Node IOCTL Control device
+ *
+ *	Authors:
+ *	Henrik Petander		<lpetande@tml.hut.fi>
+ *
+ *	$Id$
+ *
+ *	This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/poll.h>
+#include <net/ipv6.h>
+#include <asm/uaccess.h>
+
+#include "mipv6_ioctl.h"
+#include "debug.h"
+#include "util.h"
+#include "mdetect.h"
+#include "mn.h"
+#include "hmac.h"
+#include "config.h"
+#include "multiaccess_ctl.h"
+
+static int inuse = 0;
+
+static int mipv6_open(struct inode *inode, struct file *file)
+{
+	DEBUG(DBG_INFO, "(%p)\n", file);
+
+	if (inuse)
+		return -EBUSY;
+
+	inuse++;
+
+	MOD_INC_USE_COUNT;
+
+	return 0;
+}
+
+static int mipv6_close(struct inode *inode, struct file *file)
+{
+	DEBUG(DBG_INFO, "(%p,%p)\n", inode, file);
+	inuse--;
+
+	MOD_DEC_USE_COUNT;
+
+	return 0;
+}
+
+int mipv6_ioctl(struct inode *inode, struct file *file, 
+		unsigned int ioctl_num,	/* The number of the ioctl */
+		unsigned long arg)	/* The parameter to it */
+{
+	struct in6_addr careofaddr;
+
+	/* Switch according to the ioctl called */
+	switch (ioctl_num) {
+	case IOCTL_GET_CAREOFADDR:
+		DEBUG(DBG_DATADUMP, "IOCTL_GET_CAREOFADDR");
+		/* First get home address from user and then look up 
+		 * the care-of address and return it
+		 */
+		if (copy_from_user(&careofaddr, (struct in6_addr *)arg, 
+				   sizeof(struct in6_addr)) < 0) {
+			DEBUG(DBG_WARNING, "Copy from user failed");
+			return -EFAULT;
+		}
+		mipv6_get_care_of_address(&careofaddr, &careofaddr);
+		DEBUG(DBG_INFO, "COA: %x:%x:%x:%x:%x:%x:%x:%x",
+		      NIPV6ADDR(&careofaddr));
+		if (copy_to_user((struct in6_addr *)arg, &careofaddr,
+				 sizeof(struct in6_addr)) < 0) {
+			DEBUG(DBG_WARNING, "copy_to_user failed");
+			return -EFAULT;
+		}
+		break;
+	case MA_IOCTL_SET_IFACE_PREFERENCE:
+		DEBUG(DBG_INFO, "MA_IOCTL_SET_IFACE_PREFERENCE");
+		ma_ctl_set_preference(arg);
+		break;
+
+	default:
+		DEBUG(DBG_WARNING, "Unknown ioctl cmd (%d)", ioctl_num);
+		return -ENOENT;
+	}
+	return 0;
+}
+
+struct file_operations Fops = {
+	owner: THIS_MODULE,
+	read: NULL,
+	write: NULL,
+	poll: NULL,
+	ioctl: mipv6_ioctl,
+	open: mipv6_open,
+	release: mipv6_close
+};
+
+
+/* Initialize the module - Register the character device */
+int mipv6_ioctl_mn_init(void)
+{
+	int ret_val;
+
+	/* Register the character device (atleast try) */
+	ret_val = register_chrdev(MAJOR_NUM, CTLFILE, &Fops);
+
+	/* Negative values signify an error */
+	if (ret_val < 0) {
+		DEBUG(DBG_ERROR, "failed registering char device (err=%d)",
+		      ret_val);
+		return ret_val;
+	}
+
+	DEBUG(DBG_INFO, "Device number %x, success", MAJOR_NUM);
+	return 0;
+}
+
+
+/* Cleanup - unregister the appropriate file from /proc */
+void mipv6_ioctl_mn_exit(void)
+{
+	int ret;
+	/* Unregister the device */
+	ret = unregister_chrdev(MAJOR_NUM, CTLFILE);
+
+	/* If there's an error, report it */
+	if (ret < 0)
+		DEBUG(DBG_ERROR, "errorcode: %d\n", ret);
+}
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/mdetect.c linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/mdetect.c
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/mdetect.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/mdetect.c	2003-05-18 11:33:53.000000000 +0200
@@ -0,0 +1,790 @@
+/*
+ *      Movement Detection Module
+ *
+ *      Authors:
+ *      Henrik Petander                <lpetande@cc.hut.fi>
+ *
+ *      $Id: s.mdetect.c 1.112 02/12/19 15:40:26-02:00 henkku@mart10.hut.mediapoli.com $
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ *
+ *      Handles the L3 movement detection of mobile node and also
+ *      changing of its routes.
+ *  
+ */
+
+/*
+ *	Changes:
+ *
+ *	Nanno Langstraat	:	Locking fixes
+ *      Venkata Jagana          :       Locking fix
+ */
+
+#include <linux/autoconf.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/if_arp.h>
+#include <linux/route.h>
+#include <net/ipv6.h>
+#include <net/ip6_route.h>
+#include <net/addrconf.h>
+#include <net/mipglue.h>
+#ifdef CONFIG_SYSCTL
+#include <linux/sysctl.h>
+#endif /* CONFIG_SYSCTL */
+
+#include "util.h"
+#include "mdetect.h"
+#include "mn.h"
+#include "debug.h"
+#include "tunnel.h"
+#include "multiaccess_ctl.h"
+
+#define START 0
+#define CONTINUE 1
+#define OK 2
+#define DEBUG_MDETECT 7
+
+#define DEF_RTR_POLL_IVAL 5 /* In seconds */
+
+#define NO_RTR 0
+#define RTR_SUSPECT 1
+#define CURR_RTR_OK 2
+
+#define RA_RCVD 0
+#define NA_RCVD 1
+#define TIMEOUT 2
+
+/* dad could also be RESPECT_DAD for duplicate address detection of
+   new care-of addresses */
+static int dad = 0;
+
+/* Only one choice, nothing else implemented */
+int max_rtr_reach_time = DEF_RTR_POLL_IVAL;
+int mdet_mech = EAGER_CELL_SWITCHING; 
+
+int eager_cell_switching = 1;  /* This can't be set from anywhere for now */
+static spinlock_t router_lock; 
+
+int mipv6_router_state(struct router *rtr);
+static void timer_handler(unsigned long foo);
+static struct router *curr_router = NULL, *next_router = NULL;
+static struct timer_list r_timer = { function: timer_handler };
+
+#define MAX_ROUTERS 1000
+static LIST_HEAD(rtr_list);
+static int num_routers = 0;
+
+/*
+ * Functions for handling the default router list, which movement
+ * detection uses for avoiding loops etc.
+ */
+
+/* searches for a specific router or any router that is reachable, 
+ * if address is NULL. Also deletes obsolete routers.
+ */
+static void mipv6_router_gc(void)
+{
+	struct router *curr = NULL;
+	struct list_head *lh, *lh_tmp;
+
+	DEBUG_FUNC();
+
+	list_for_each_safe(lh, lh_tmp, &rtr_list) {
+		curr =  list_entry(lh, struct router, list);
+		if (mipv6_router_state(curr) == NOT_REACHABLE && !curr->is_current) {
+			num_routers--;
+			list_del_init(&curr->list);
+			DEBUG(DBG_DATADUMP, "Deleting unreachable router  %x:%x:%x:%x:%x:%x:%x:%x", 
+			      NIPV6ADDR(&curr->raddr));
+			kfree(curr);
+		}
+		else {
+			DEBUG(DBG_DATADUMP, "NOT Deleting router  %x:%x:%x:%x:%x:%x:%x:%x", 
+			      NIPV6ADDR(&curr->raddr));
+		}
+	}
+}
+
+static struct router *mipv6_rtr_get(struct in6_addr *search_addr)
+{
+	struct router *rtr = NULL;
+	struct list_head *lh;
+
+	DEBUG_FUNC();
+
+	if (search_addr == NULL)
+		return NULL;
+	list_for_each(lh, &rtr_list) {
+		rtr = list_entry(lh, struct router, list);
+		if(!ipv6_addr_cmp(search_addr, &rtr->raddr)) {
+			return rtr;
+		}
+	}
+	return NULL;
+}
+
+/*
+ * Adds router to list
+ */
+static struct router *mipv6_rtr_add(struct router *nrt)
+{
+
+	struct router *rptr;
+
+	DEBUG_FUNC();
+
+	/* check if someone is trying DoS attack, or we just have some
+           memory leaks... */
+	if (num_routers > MAX_ROUTERS) {
+		DEBUG(DBG_CRITICAL, 
+		      "failed to add new router, MAX_ROUTERS exceeded");
+		return NULL;
+	}
+	
+	rptr = kmalloc(sizeof(struct router), GFP_ATOMIC);
+	if (rptr) {
+		memcpy(rptr, nrt, sizeof(struct router));
+		list_add(&rptr->list, &rtr_list);
+		num_routers++;
+	}
+	DEBUG(DBG_INFO, "Adding router: %x:%x:%x:%x:%x:%x:%x:%x, "
+	      "lifetime : %d sec, adv.interval: %d millisec", 
+	      NIPV6ADDR(&rptr->raddr), rptr->lifetime, rptr->interval);
+
+	DEBUG(DBG_INFO, "num_routers after addition: %d", num_routers);
+	return rptr;
+}
+
+/* Cleans up the list */
+static void list_free(struct router **curr_router_p)
+{
+	struct router *tmp;
+	struct list_head *lh, *lh_tmp;
+
+	DEBUG_FUNC();
+
+	DEBUG(DBG_INFO, "Freeing the router list");
+	/* set curr_router->prev_router and curr_router NULL */
+	*curr_router_p = NULL;
+	list_for_each_safe(lh, lh_tmp, &rtr_list) {
+		tmp = list_entry(lh, struct router, list);
+		DEBUG(DBG_INFO, "%x:%x:%x:%x:%x:%x:%x:%x",
+		      NIPV6ADDR(&tmp->ll_addr));
+		list_del(&tmp->list);
+		kfree(tmp);
+		num_routers--;
+	}
+}
+
+int rs_state = START;
+
+/* Sends router solicitations to all valid devices 
+ * source  = link local address (of sending interface)
+ * dstaddr = all routers multicast address
+ * Solicitations are sent at an exponentially decreasing rate
+ *
+ * TODO: send solicitation first at a normal rate (from ipv6) and
+ *       after that use the exponentially increasing intervals 
+ */
+int rs_send(void)
+{
+	struct net_device *dev;
+	struct in6_addr raddr, lladdr;
+	struct inet6_dev *in6_dev = NULL;
+	static unsigned long ival;
+	static int num_rs = 0;
+
+	ipv6_addr_all_routers(&raddr);
+	read_lock(&dev_base_lock); 
+	/*  Send router solicitations to all interfaces  */
+	for (dev = dev_base; dev; dev = dev->next) {
+		if ((dev->flags & IFF_UP) && dev->type == ARPHRD_ETHER) {
+			DEBUG(DBG_DATADUMP, "Sending RS to device %s", 
+			      (int)dev->name);
+				if (!ipv6_get_lladdr(dev, &lladdr)) {
+					ndisc_send_rs(dev, &lladdr, &raddr);
+					in6_dev = in6_dev_get(dev);
+					in6_dev->if_flags |= IF_RS_SENT;
+					in6_dev_put(in6_dev);
+				} else {
+					DEBUG(DBG_DATADUMP, "%s: device doesn't have link-local address!\n", (int)dev->name);
+					continue;
+				}
+		}
+		
+	}
+	read_unlock(&dev_base_lock);
+	/* Send MAX_RTR_SOLICITATIONS linearly, then 
+	 * increase the delay exponentially till 
+	 * delay == RS_RESEND_LINEAR
+	 */
+	if (rs_state == START) {
+		ival = MAX_RTR_SOLICITATION_DELAY; /* RFC 2461 */
+		num_rs = 0;
+		rs_state = CONTINUE;
+	} 
+	else {
+		if (ival < RS_RESEND_LINEAR / 2) /* mdetect.h */
+			ival = ival * 2;
+		else
+			ival = RS_RESEND_LINEAR;
+	}
+	return ival;		
+}
+
+/* Create a new CoA for MN and also add a route to it if it is still tentative 
+   to allow MN to get packets to the address immediately
+ */
+int form_coa(struct in6_addr *coa, struct in6_addr *pfix, int plen, int ifindex)
+{
+	struct net_device *dev;
+	int ret;
+	if (plen != 64)
+		return -1;
+
+	if ((dev = dev_get_by_index(ifindex)) == NULL) {
+		DEBUG(DBG_WARNING, "Device is not present");
+		return -1;
+	}
+	ipv6_get_lladdr(dev, coa);
+	coa->s6_addr32[0] = pfix->s6_addr32[0];
+	coa->s6_addr32[1] = pfix->s6_addr32[1];
+	
+	if (ipv6_chk_addr(coa, dev) == 0) { 
+		DEBUG(DBG_WARNING, "care-of address still tentative");
+		ret = 1;
+		ip6_rt_addr_add(coa, dev);
+	}
+	else
+		 ret = 0;
+	dev_put(dev);
+	DEBUG(DBG_INFO, "Formed new CoA:  %x:%x:%x:%x:%x:%x:%x:%x",
+	      NIPV6ADDR(coa));
+	return ret;
+}
+
+static inline int rtr_is_gw(struct router *rtr, struct rt6_info *rt) 
+{
+	return ((rt->rt6i_flags & RTF_GATEWAY) && 
+		!ipv6_addr_cmp(&rt->rt6i_gateway, &rtr->ll_addr));
+}
+
+static inline int is_prefix_route(struct router *rtr, struct rt6_info *rt) 
+{
+	return (!(rt->rt6i_flags & RTF_GATEWAY) &&
+		mipv6_prefix_compare(&rt->rt6i_dst.addr, &rtr->raddr, 
+				     rtr->pfix_len));
+}
+
+/*
+ * Function that determines whether given rt6_info should be destroyed
+ * (negative => destroy rt6_info, zero or positive => do nothing) 
+ */
+static int mn_route_cleaner(struct rt6_info *rt, void *arg)
+{
+	int type;
+
+	struct router *rtr = (struct router *)arg;
+
+	int ret = -1;
+
+	DEBUG_FUNC();
+	
+	if (!rt || !rtr) {
+		DEBUG(DBG_ERROR, "mn_route_cleaner: rt or rtr NULL");
+		return 0;
+	}
+
+	/* Do not delete routes to local addresses or to multicast
+	 * addresses, since we need them to get router advertisements
+	 * etc. Multicast addresses are more tricky, but we don't
+	 * delete them in any case. The routing mechanism is not optimal for 
+	 * multihoming.   
+	 *
+	 * Also keep all new prefix routes, gateway routes through rtr and
+	 * all remaining default routes (including those used for reverse
+	 * tunneling)
+	 */
+	type = ipv6_addr_type(&rt->rt6i_dst.addr);
+	
+	if ((type & (IPV6_ADDR_MULTICAST | IPV6_ADDR_LINKLOCAL)) ||
+	    rt->rt6i_dev == &loopback_dev || rtr_is_gw(rtr, rt) ||
+	    is_prefix_route(rtr, rt) || (rt->rt6i_flags & RTF_DEFAULT))  
+		ret = 0;
+	
+	/*   delete all others */
+
+	if (rt->rt6i_dev != &loopback_dev) {
+		DEBUG(DEBUG_MDETECT, 
+		      "%s route:\n"
+		      "dev: %s,\n"
+		      "gw: %x:%x:%x:%x:%x:%x:%x:%x,\n"
+		      "flags: %x,\n"
+		      "metric: %d,\n"
+		      "src: %x:%x:%x:%x:%x:%x:%x:%x,\n"
+		      "dst: %x:%x:%x:%x:%x:%x:%x:%x,\n"
+		      "plen: %d\n",
+		      (ret ? "Deleting" : "Keeping"),
+		      rt->rt6i_dev->name,	       
+		      NIPV6ADDR(&rt->rt6i_gateway),	       
+		      rt->rt6i_flags,
+		      rt->rt6i_metric,
+		      NIPV6ADDR(&rt->rt6i_src.addr),
+		      NIPV6ADDR(&rt->rt6i_dst.addr),
+		      rt->rt6i_dst.plen);
+	}
+	return ret;
+}
+
+/* 
+ * Deletes old routes 
+ */
+static __inline__ void delete_routes(struct router *rtr)
+{
+	DEBUG_FUNC();
+
+	/* Routing table is locked to ensure that nobody uses its */  
+	write_lock_bh(&rt6_lock);
+	DEBUG(DBG_INFO, "mipv6: Purging routes");
+	/*  TODO: Does not prune, should it?  */
+	fib6_clean_tree(&ip6_routing_table, 
+			mn_route_cleaner, 0, rtr);
+	write_unlock_bh(&rt6_lock);
+
+}
+
+
+
+int next_mdet_state[3][3] = {{CURR_RTR_OK, NO_RTR, NO_RTR},
+			     {CURR_RTR_OK, CURR_RTR_OK, NO_RTR},
+			     {CURR_RTR_OK, CURR_RTR_OK, RTR_SUSPECT}};
+ 
+char *states[3] = {"NO_RTR", "RTR_SUSPECT", "CURR_RTR_OK"};
+char *events[3] = {"RA_RCVD", "NA_RCVD", "TIMEOUT"};
+
+/* State transitions
+ * NO_RTR, RA_RCVD -> CURR_RTR_OK
+ * NO_RTR, NA_RCVD -> NO_RTR
+ * NO_RTR, TIMEOUT -> NO_RTR
+
+ * RTR_SUSPECT, RA_RCVD -> CURR_RTR_OK
+ * RTR_SUSPECT, NA_RCVD -> CURR_RTR_OK
+ * RTR_SUSPECT, TIMEOUT -> NO_RTR
+
+ * CURR_RTR_OK, RA_RCVD -> CURR_RTR_OK
+ * CURR_RTR_OK, NA_RCVD -> CURR_RTR_OK
+ * CURR_RTR_OK, TIMEOUT -> RTR_SUSPECT
+ */
+static int _curr_state = NO_RTR;
+
+static int get_mdet_state(void){
+	int state;
+	spin_lock_bh(&router_lock); 
+	state = _curr_state;
+	spin_unlock_bh(&router_lock);
+	return state;
+}
+/* Needs to be called with router_lock locked */
+static int mdet_statemachine(int event)
+{
+	
+	if (event > 2 || _curr_state > 2) {
+	       DEBUG(DBG_ERROR, "Got illegal event or curr_state");
+	       return -1;
+	}
+
+	DEBUG(DBG_DATADUMP, "Got event %s and curr_state is %s", 
+	      events[event], states[_curr_state]); 
+	
+	_curr_state = next_mdet_state[_curr_state][event];
+	DEBUG(DBG_DATADUMP, "Next state is %s", states[_curr_state]);
+	return _curr_state;
+}
+
+/* 
+ * Changes the router, called from ndisc.c if mipv6_router_event 
+ * returns true.
+ */
+
+void mipv6_change_router(void)
+{
+	struct router *tmp;
+	struct handoff ho;
+	int ret, dummy;
+
+	DEBUG_FUNC(); 
+
+	
+	if (next_router == NULL) 
+		return;
+	
+	spin_lock(&router_lock);
+	
+	if (curr_router != NULL && 
+	    !ipv6_addr_cmp(&curr_router->ll_addr, &next_router->ll_addr)) {
+		DEBUG(DBG_INFO,"Trying to handoff from: "
+		      "%x:%x:%x:%x:%x:%x:%x:%x",
+		      NIPV6ADDR(&curr_router->ll_addr));
+		DEBUG(DBG_INFO,"Trying to handoff to: "
+		      "%x:%x:%x:%x:%x:%x:%x:%x",
+		      NIPV6ADDR(&next_router->ll_addr));
+		next_router = NULL; /* Let's not leave dangling pointers */
+		spin_unlock(&router_lock);
+		return;
+        }
+
+	delete_routes(next_router);
+
+	tmp = curr_router;
+	curr_router = next_router;
+	curr_router->is_current = 1;
+	next_router = NULL; 
+
+	ret = form_coa(&curr_router->CoA, &curr_router->raddr, 64, 
+		       curr_router->ifindex);
+	if (ret < 0) {
+		DEBUG(DBG_ERROR, "handoff: Creation of coa failed");
+		spin_unlock(&router_lock);
+		return;
+	}
+	if (ret)
+		curr_router->extra_addr_route = 1;
+
+	memcpy(&ho.rtr_new, curr_router, sizeof(struct router));
+
+	if (tmp) { 
+		tmp->is_current = 0;
+
+		if (tmp->extra_addr_route && 
+		    !mipv6_mn_is_home_addr(&tmp->CoA)) {
+			/* Delete the extra route to prev. CoA 
+			 */
+			struct net_device *dev = NULL;
+			
+			if ((dev = dev_get_by_index(tmp->ifindex)) != NULL) {
+				ip6_rt_addr_del(&tmp->CoA, dev);
+				dev_put(dev);
+				tmp->extra_addr_route = 0;
+			}
+		}
+		ho.flags = MIPV6_MDF_HAS_RTR_PREV;
+		memcpy(&ho.rtr_prev, tmp, sizeof(struct router));
+	}
+	else {
+		ho.flags = MIPV6_MDF_NONE;
+	}
+	mdet_statemachine(RA_RCVD);
+	if (curr_router->interval)
+		mod_timer(&r_timer, jiffies + 
+			  (curr_router->interval * HZ)/1000);
+	else
+		mod_timer(&r_timer, jiffies + max_rtr_reach_time * HZ);
+	ma_ctl_upd_iface(curr_router->ifindex, MA_IFACE_CURRENT, &dummy);
+	ma_ctl_upd_iface(curr_router->ifindex, MA_IFACE_CURRENT, &dummy);
+	spin_unlock(&router_lock);
+	mipv6_mobile_node_moved(&ho);
+} 
+
+/* TODO: Send NS to router after MAX interval has passed from last RA */
+int mipv6_router_state(struct router *rtr) {
+	if (rtr->interval) {
+		if (time_before(jiffies, (rtr->last_ra_rcvd + (rtr->interval * HZ) / 1000)))
+			return ROUTER_REACHABLE;
+		else
+			return NOT_REACHABLE;
+	}
+	else
+		if (time_after(jiffies, rtr->last_ra_rcvd + rtr->lifetime))
+			return NOT_REACHABLE;
+	return ROUTER_REACHABLE;
+}
+
+
+static unsigned long ns_send(void)
+{
+	struct neighbour *neigh;
+	struct net_device *dev;
+
+	DEBUG(DBG_DATADUMP, "Sending Neighbour solicitation to default router to verify its reachability");
+	if (!curr_router) 
+		return HZ;
+	if ((dev = dev_get_by_index(curr_router->ifindex)) == NULL)
+		return HZ;
+	if ((neigh = ndisc_get_neigh(dev, &curr_router->ll_addr)) == NULL) {
+		dev_put(dev);
+		return HZ;
+	}
+	curr_router->last_ns_sent = jiffies;
+	ndisc_send_ns(dev, neigh, &curr_router->ll_addr,
+		      &curr_router->ll_addr , NULL);	
+
+	neigh_release(neigh);
+	dev_put(dev);
+	return HZ/5; /* Wait 200ms for a reply */
+}
+
+static int na_rcvd(void)
+{	
+	int neigh_ok = 0;
+	struct neighbour *neigh;
+	struct net_device *dev;
+
+	if (!curr_router) 
+		return 0;
+	if ((dev = dev_get_by_index(curr_router->ifindex)) == NULL)
+		return 0;
+	if ((neigh = ndisc_get_neigh(dev, &curr_router->ll_addr)) == NULL) {
+		dev_put(dev);
+		return 0;
+	}
+	if (time_after(neigh->confirmed, curr_router->last_ns_sent) || 
+	    neigh->confirmed == curr_router->last_ns_sent) {
+		neigh_ok = 1;
+		DEBUG(DBG_DATADUMP, "Mdetect event: NA rcvd from curr rtr");
+	} else
+		DEBUG(DBG_DATADUMP, "Mdetect event: NA NOT rcvd from curr rtr within time limit");
+	neigh_release(neigh);
+	dev_put(dev);
+	return neigh_ok;
+}
+
+static void timer_handler(unsigned long foo)
+{
+	unsigned long timeout;
+	int state;
+	spin_lock_bh(&router_lock);
+	if (_curr_state != NO_RTR)
+		rs_state = START;
+
+	if (_curr_state == RTR_SUSPECT && na_rcvd()) {
+		state = mdet_statemachine(NA_RCVD);
+		timeout = curr_router->interval ? curr_router->interval : max_rtr_reach_time * HZ;
+	} else { 
+		state =  mdet_statemachine(TIMEOUT);
+		if (state == NO_RTR)
+			timeout = rs_send();
+		else  /* RTR_SUSPECT */
+			timeout = ns_send();
+	}
+
+	if (timeout < 2) {
+		DEBUG(DBG_ERROR, "mdetect timeout < 0.02s"); 
+		timeout = 10;
+	}
+	mipv6_router_gc();
+	mod_timer(&r_timer, jiffies + timeout);
+	spin_unlock_bh(&router_lock);
+}
+
+/**
+ * mipv6_get_care_of_address - get node's care-of primary address
+ * @homeaddr: one of node's home addresses
+ * @coaddr: buffer to store care-of address
+ *
+ * Stores the current care-of address in the @coaddr, assumes
+ * addresses in EUI-64 format.  Since node might have several home
+ * addresses caller MUST supply @homeaddr.  If node is at home
+ * @homeaddr is stored in @coaddr.  Returns 0 on success, otherwise a
+ * negative value.
+ **/
+int mipv6_get_care_of_address(
+	struct in6_addr *homeaddr, struct in6_addr *coaddr)
+{
+	struct net_device *currdev;
+	
+	DEBUG_FUNC();
+
+	if (homeaddr == NULL)
+		return -1;
+	spin_lock_bh(&router_lock);
+	if (curr_router == NULL || mipv6_mn_is_at_home(homeaddr) || 
+	    mipv6_prefix_compare(homeaddr, &curr_router->raddr, 64)) {
+		DEBUG(DBG_INFO,
+		      "mipv6_get_care_of_address: returning home address");
+		ipv6_addr_copy(coaddr, homeaddr);
+		spin_unlock_bh(&router_lock);
+		return 0;
+
+	}
+ 	if ((currdev = dev_get_by_index(curr_router->ifindex)) == NULL) {
+		DEBUG(DBG_WARNING, "Device is not present");
+		spin_unlock_bh(&router_lock);
+		return -1;
+	}
+
+	ipv6_get_lladdr(currdev, coaddr);
+	coaddr->s6_addr32[0] = curr_router->raddr.s6_addr32[0];
+	coaddr->s6_addr32[1] = curr_router->raddr.s6_addr32[1];
+
+	if (dad == RESPECT_DAD && ipv6_chk_addr(coaddr, currdev) == 0) { 
+		/* address check failure probably due to dad wait*/
+		DEBUG(DBG_WARNING, "care-of address not valid, using home "
+		      "address instead");
+		ipv6_addr_copy(coaddr, homeaddr);
+	}
+	dev_put(currdev);
+	spin_unlock_bh(&router_lock);
+	return 0;
+}
+
+/* Decides whether router candidate is the same router as current rtr
+ * based on prefix / global addresses of the routers and their link local 
+ * addresses 
+ */
+static int is_current_rtr(struct router *nrt, struct router *crt)
+{
+	DEBUG_FUNC();
+	
+	DEBUG(DEBUG_MDETECT, "Current router: "
+	      "%x:%x:%x:%x:%x:%x:%x:%x and", NIPV6ADDR(&crt->raddr));
+	DEBUG(DEBUG_MDETECT, "Candidate router: "
+	      "%x:%x:%x:%x:%x:%x:%x:%x", NIPV6ADDR(&nrt->raddr));
+
+	return (!ipv6_addr_cmp(&nrt->raddr,&crt->raddr) && 
+		!ipv6_addr_cmp(&nrt->ll_addr, &crt->ll_addr));
+}
+
+/* 
+ * Set next router to nrtr
+ * TODO: Locking to ensure nothing happens to next router
+ * before handoff is done
+ */ 
+static void set_next_rtr(struct router *nrtr, struct router *ortr)
+{
+	DEBUG_FUNC();
+	next_router = nrtr;
+}
+static int clean_ncache(struct router *nrt, struct router *ort, int same_if)
+{
+	struct net_device *ortdev;
+	DEBUG_FUNC();
+
+	/* Always call ifdown after a handoff to ensure proper routing */
+	
+	if (!ort) 
+		return 0;
+	if ((ortdev = dev_get_by_index(ort->ifindex)) == NULL) {
+		DEBUG(DBG_WARNING, "Device is not present");
+		return -1;
+	}
+	neigh_ifdown(&nd_tbl, ortdev);
+	dev_put(ortdev);	
+	return 0;
+}
+
+int mdet_get_if_preference(int ifi)
+{
+	int pref = 0;
+
+	DEBUG_FUNC();
+
+	pref = ma_ctl_get_preference(ifi);
+
+	DEBUG(DEBUG_MDETECT, "ifi: %d preference %d", ifi, pref);
+
+	return pref;
+}
+
+/*
+ * Called from mipv6_mn_ra_rcv to determine whether to do a handoff. 
+ */
+int mipv6_router_event(struct router *rptr)
+{
+	struct router *nrt = NULL;
+	int new_router = 0, same_if = 1;
+	int ret = MIPV6_IGN_RTR;
+	int oldstate = _curr_state;
+	int addrtype = ipv6_addr_type(&rptr->raddr);
+
+	DEBUG_FUNC();
+
+	DEBUG(DEBUG_MDETECT, "Received a RA from router: "
+	      "%x:%x:%x:%x:%x:%x:%x:%x", NIPV6ADDR(&rptr->raddr));
+	spin_lock(&router_lock);
+
+	/* Add or update router entry */
+	if ((nrt = mipv6_rtr_get(&rptr->raddr)) == NULL) {
+		if (addrtype == IPV6_ADDR_ANY || (nrt = mipv6_rtr_add(rptr)) == NULL) {
+				spin_unlock(&router_lock);
+				return ret;
+		}
+		DEBUG(DBG_INFO, "Router not on list,adding it to the list"); 
+		new_router = 1;
+	}
+	nrt->last_ra_rcvd = jiffies;
+	nrt->state = ROUTER_REACHABLE;
+	nrt->interval = rptr->interval;
+	nrt->lifetime = rptr->lifetime;
+	nrt->ifindex = rptr->ifindex;
+
+	/* Whether from current router */
+	if (curr_router && is_current_rtr(nrt, curr_router)) {
+		if (nrt->interval)
+			mod_timer(&r_timer, jiffies + (nrt->interval * HZ)/1000);
+		else
+			mod_timer(&r_timer, jiffies + max_rtr_reach_time * HZ);
+		mdet_statemachine(RA_RCVD);
+		spin_unlock(&router_lock);
+		return MIPV6_ADD_RTR;
+	} else if (oldstate == NO_RTR) {
+		DEBUG(DBG_INFO, "No router or router not reachable, switching to new one");   
+		goto handoff;
+	}
+	if (!curr_router) {
+		DEBUG(0, "Bug in MN statemachine: We should never get here!");
+		spin_unlock(&router_lock);
+		goto handoff;
+	}
+	/* Router behind same interface as current one ?*/
+	same_if = (nrt->ifindex == curr_router->ifindex);
+	/* Switch to new router behind same interface if eager cell 
+	 *  switching is used or if the interface is preferred
+	 */
+	if ((new_router && eager_cell_switching && same_if) ||
+	    (mdet_get_if_preference(nrt->ifindex) > 
+	     mdet_get_if_preference(curr_router->ifindex))) {
+		DEBUG(DBG_INFO, "Switching to new router.");
+		goto handoff;
+	}
+	
+	/* No handoff, don't add default route */
+	DEBUG(DEBUG_MDETECT, "Ignoring RA");
+	spin_unlock(&router_lock);
+	return ret;
+handoff:
+	clean_ncache(nrt, curr_router, same_if);
+	set_next_rtr(nrt, curr_router);
+	spin_unlock(&router_lock);
+	rt6_purge_dflt_routers(0);
+
+	return MIPV6_CHG_RTR;
+}	
+
+int __init mipv6_initialize_mdetect(void)
+{
+
+	DEBUG_FUNC();
+
+	spin_lock_init(&router_lock);
+	init_timer(&r_timer);
+	r_timer.expires = jiffies + HZ;
+	add_timer(&r_timer);
+	return 0;
+}
+
+int __exit mipv6_shutdown_mdetect()
+{
+
+	DEBUG_FUNC();
+	spin_lock_bh(&router_lock);
+	del_timer(&r_timer);
+	/* Free the memory allocated by router list */
+	list_free(&curr_router);
+	spin_unlock_bh(&router_lock);
+
+	return 0;
+}
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/mdetect.h linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/mdetect.h
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/mdetect.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/mdetect.h	2003-05-18 11:33:53.000000000 +0200
@@ -0,0 +1,94 @@
+/*
+ *      Movement detection module header file
+ *
+ *      Authors:
+ *      Henrik Petander               <lpetande@cc.hut.fi>
+ *
+ *      $Id: s.mdetect.h 1.26 02/12/19 15:40:26-02:00 henkku@mart10.hut.mediapoli.com $
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef _MDETECT_H
+#define _MDETECT_H
+
+#define ROUTER_REACHABLE 1
+#define RADV_MISSED 2
+#define NOT_REACHABLE 3
+
+/* R_TIME_OUT paramater is used to make the decision when to change the 
+ * default  router, if the current one is unreachable. 2s is pretty aggressive 
+ * and may result in hopping between two routers. OTOH a small value enhances 
+ * the  performance
+ */
+#define R_TIME_OUT 30*HZ
+
+/* maximum RA interval for router unreachability detection */
+#define MAX_RADV_INTERVAL 6000*HZ  /* 6000 ms... */
+
+/* Threshold for exponential resending of router solicitations */
+#define RS_RESEND_LINEAR 10*HZ
+
+#define EAGER_CELL_SWITCHING 1
+#define LAZY_CELL_SWITCHING 0
+#define RESPECT_DAD 1
+
+#define ROUTER_ADDRESS 0x20
+
+#define ADDRANY {{{0, 0, 0, 0}}}
+
+/* RA flags */
+#define ND_RA_FLAG_MANAGED  0x80
+#define ND_RA_FLAG_OTHER    0x40
+#define ND_RA_FLAG_HA       0x20
+
+struct router {
+	struct list_head list;
+	struct in6_addr ll_addr;
+	struct in6_addr raddr; /* Also contains prefix */
+	__u8 link_addr[MAX_ADDR_LEN]; /* link layer address */
+	__u8 link_addr_len;
+	__u8 state;
+	__u8 is_current;
+	int ifindex;
+	int pfix_len; /* Length of the network prefix */
+	unsigned long lifetime; /* from ra */
+	__u32 last_ns_sent; 
+	__u32 last_ra_rcvd;
+	__u32 interval; /* ra interval in milliseconds, 0 if not set */ 
+	int glob_addr; /*Whether raddr contains also routers global address*/
+	__u8 flags; /* RA flags, for example ha */
+        struct in6_addr CoA;     /* care-off address used with this router */
+	int extra_addr_route;
+	struct router *next; 
+};
+
+#define MIPV6_MDF_NONE 0x0
+#define MIPV6_MDF_HAS_RTR_PREV 0x1
+
+struct handoff {
+	int flags;
+	struct router rtr_new;
+	struct router rtr_prev;
+};
+int mipv6_initialize_mdetect(void);
+
+int mipv6_shutdown_mdetect(void);
+
+int mipv6_get_care_of_address(
+	struct in6_addr *homeaddr,
+	struct in6_addr *coa);
+
+void mipv6_get_old_care_of_address(
+        struct in6_addr *homeaddr,
+        struct in6_addr *prevcoa);
+
+void mipv6_change_router(void);
+
+int mipv6_router_event(struct router *nrt);
+
+#endif /* _MDETECT_H */
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/mipv6_icmp.c linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/mipv6_icmp.c
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/mipv6_icmp.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/mipv6_icmp.c	2003-05-18 11:33:53.000000000 +0200
@@ -0,0 +1,279 @@
+/**
+ * Generic icmp routines
+ *
+ * Authors:
+ * Jaakko Laine <medved@iki.fi>
+ *
+ * $Id: s.mipv6_icmp.c 1.23 02/11/25 11:18:16+02:00 vnuorval@amber.hut.mediapoli.com $
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/config.h>
+#include <linux/icmpv6.h>
+#include <net/checksum.h>
+#include <net/ipv6.h>
+#include <net/ip6_route.h>
+#include <net/mipv6.h>
+#include <net/mipglue.h>
+
+#include "debug.h"
+#include "util.h"
+#include "bcache.h"
+#include "mipv6_icmp.h"
+
+struct icmpv6_msg {
+	struct icmp6hdr icmph;
+	__u8 *data;
+};
+
+#define MIPV6_ICMP_HOP_LIMIT 64
+
+static struct socket *icmpv6_socket = NULL;
+static __u16 identifier = 0;
+
+/**
+ * mipv6_icmpv6_dest_unreach - Destination Unreachable ICMP error message handler
+ * @skb: buffer containing ICMP error message
+ *
+ * Special Mobile IPv6 ICMP handling.  If Correspondent Node receives
+ * persistent ICMP Destination Unreachable messages for a destination
+ * in its Binding Cache, the binding should be deleted.  See draft
+ * section 8.8.
+ **/
+static int mipv6_icmpv6_rcv_dest_unreach(struct sk_buff *skb)
+{
+	struct icmp6hdr *phdr = (struct icmp6hdr *) skb->h.raw;
+	int left = (skb->tail - (unsigned char *) (phdr + 1))
+	    - sizeof(struct ipv6hdr);
+	struct ipv6hdr *hdr = (struct ipv6hdr *) (phdr + 1);
+	struct ipv6_opt_hdr *ehdr;
+	struct ipv6_rt_hdr *rthdr = NULL;
+	struct in6_addr *addr, *ha;
+	int hdrlen, nexthdr = hdr->nexthdr;
+
+	DEBUG_FUNC();
+
+	ehdr = (struct ipv6_opt_hdr *) (hdr + 1);
+
+	while (left > 0) {
+		hdrlen = ipv6_optlen(ehdr);
+		if (hdrlen > left)
+			return 0;
+
+		if (!(nexthdr == NEXTHDR_HOP || nexthdr == NEXTHDR_DEST || 
+		      nexthdr == NEXTHDR_ROUTING))
+			return 0;
+
+		if (nexthdr == NEXTHDR_ROUTING) {
+			rthdr = (struct ipv6_rt_hdr *) ehdr;
+			if (rthdr->segments_left != 1)
+				return 0;
+			if (rthdr->type == IPV6_SRCRT_TYPE_2)
+				break;
+		}
+		nexthdr = ehdr->nexthdr;
+		ehdr = (struct ipv6_opt_hdr *) ((u8 *) ehdr + hdrlen);
+		left -= hdrlen;
+	}
+
+	if (rthdr == NULL) return 0;
+
+	addr = (struct in6_addr *) ((u32 *) rthdr + 2);
+	ha = (struct in6_addr *) &skb->nh.ipv6h->daddr;
+	if (mipv6_bcache_exists(addr, ha) >= 0) {
+		if (!mipv6_bcache_delete(addr, ha, CACHE_ENTRY)) {
+			DEBUG(DBG_INFO, "Deleted bcache entry "
+			      "%x:%x:%x:%x:%x:%x:%x:%x "
+			      "%x:%x:%x:%x:%x:%x:%x:%x (reason: "
+			      "dest unreachable) ",
+			      NIPV6ADDR(addr), NIPV6ADDR(ha));
+		}
+	}
+	return 0;
+}
+
+/**
+ * mipv6_icmpv6_send - generic icmpv6 message send
+ * @daddr: destination address
+ * @saddr: source address
+ * @type: icmp type
+ * @code: icmp code
+ * @id: packet identifier. If null, uses internal counter to get new id
+ * @data: packet data
+ * @datalen: length of data in bytes
+ */
+void mipv6_icmpv6_send(struct in6_addr *daddr, struct in6_addr *saddr, int type,
+		       int code, __u16 *id, void *data, int datalen)
+{
+	int len, err;
+	struct sock *sk = icmpv6_socket->sk;
+	struct sk_buff *skb;
+	struct ipv6hdr *hdr;
+	struct icmpv6_msg *msg;
+	struct flowi fl;
+	struct dst_entry *dst;
+
+	DEBUG_FUNC();
+
+	if (!daddr)
+		return;
+
+	fl.proto = IPPROTO_ICMPV6;
+	fl.fl6_dst = daddr;
+	fl.fl6_src = saddr;
+	fl.fl6_flowlabel = 0;
+	fl.uli_u.icmpt.type = type;
+	fl.uli_u.icmpt.code = code;
+
+	dst = ip6_route_output(NULL, &fl);
+
+	if (dst->error || !dst->dev)
+		return;
+
+	len = sizeof(struct icmp6hdr) + datalen;
+	skb = sock_alloc_send_skb(sk, MAX_HEADER + len +
+				  dst->dev->hard_header_len + 15, 0, &err);
+
+	if (!skb) {
+		DEBUG(DBG_WARNING, "Alloc skb failed");
+		return;
+	}
+
+	skb->dst = dst;
+	skb->dev = dst->dev;
+
+	/* ll header */
+	if (!skb->dev->hard_header)
+		goto fail;
+
+	skb_reserve(skb, (skb->dev->hard_header_len + 15) & ~15);
+
+	if (skb->dev->hard_header(skb, skb->dev, ETH_P_IPV6,
+				  skb->dst->neighbour->ha,
+				  NULL, len) < 0)
+		goto fail;
+
+	/* IP */
+	skb->protocol = htons(ETH_P_IPV6);
+
+	hdr = (struct ipv6hdr *) skb_put(skb, sizeof(struct ipv6hdr));
+	skb->nh.ipv6h = hdr;
+	*(u32 *)hdr = htonl(0x60000000);
+
+	hdr->payload_len = htons(len);
+	hdr->nexthdr = IPPROTO_ICMPV6;
+	hdr->hop_limit = MIPV6_ICMP_HOP_LIMIT;
+
+	ipv6_addr_copy(&hdr->saddr, saddr);
+	ipv6_addr_copy(&hdr->daddr, daddr);
+
+	/* icmp */
+	msg = (struct icmpv6_msg *) skb_put(skb, sizeof(struct icmp6hdr));
+	msg->icmph.icmp6_type = type;
+	msg->icmph.icmp6_code = code;
+	msg->icmph.icmp6_cksum = 0;
+
+	if (id)
+		msg->icmph.icmp6_identifier = htons(*id);
+	else
+		msg->icmph.icmp6_identifier = htons(identifier++);
+
+	/* data */
+	if (datalen > 0) {
+		msg->data = skb_put(skb, datalen);
+		memcpy(msg->data, data, datalen);
+	}
+
+	msg->icmph.icmp6_cksum = csum_ipv6_magic(&skb->nh.ipv6h->saddr,
+						 daddr, len, 
+						 IPPROTO_ICMPV6,
+						 csum_partial((__u8 *) msg, 
+							      len, 0));
+
+	/* pojehali! */
+	dev_queue_xmit(skb);
+
+	ICMP6_INC_STATS_BH(Icmp6OutMsgs);
+
+	return;
+
+ fail:
+	kfree_skb(skb);
+}
+
+/**
+ * icmp6_rcv - ICMPv6 receive and multiplex
+ * @skb: buffer containing ICMP message
+ *
+ * Generic ICMPv6 receive function to multiplex messages to approriate
+ * handlers.  Only used for ICMP messages with special handling in
+ * Mobile IPv6.
+ **/
+static void icmp6_rcv(struct sk_buff *skb)
+{
+	struct icmp6hdr *hdr = (struct icmp6hdr *) skb->h.raw;
+	switch (hdr->icmp6_type) {
+	case ICMPV6_DEST_UNREACH:
+		mipv6_icmpv6_rcv_dest_unreach(skb);
+		break;
+
+	case ICMPV6_PARAMPROB:
+		mipv6_icmpv6_rcv_paramprob(skb);
+		break;
+
+	case MIPV6_DHAAD_REPLY:
+		mipv6_icmpv6_rcv_dhaad_rep(skb);
+		break;
+
+	case MIPV6_PREFIX_ADV:
+		mipv6_icmpv6_rcv_pfx_adv(skb);
+		break;
+
+	case MIPV6_DHAAD_REQUEST:
+		mipv6_icmpv6_rcv_dhaad_req(skb);
+		break;
+
+	case MIPV6_PREFIX_SOLICIT:
+		mipv6_icmpv6_rcv_pfx_sol(skb);
+		break;
+	}
+}
+
+int mipv6_initialize_icmpv6(void)
+{
+	struct sock *sk;
+	int err;
+
+	if ((icmpv6_socket = sock_alloc()) == NULL) {
+		DEBUG(DBG_ERROR, "Cannot allocate icmpv6_socket");
+		return -1;
+	}
+	icmpv6_socket->type = SOCK_RAW;
+
+	if ((err = sock_create(PF_INET6, SOCK_RAW, IPPROTO_ICMP, 
+			       &icmpv6_socket)) < 0) {
+		DEBUG(DBG_ERROR, "Cannot initialize icmpv6_socket");
+		sock_release(icmpv6_socket);
+		icmpv6_socket = NULL; /* For safety */
+		return err;
+	}
+	sk = icmpv6_socket->sk;
+	sk->allocation = GFP_ATOMIC;
+	sk->prot->unhash(sk);
+
+	/* Register our ICMP handler */
+	MIPV6_SETCALL(mipv6_icmp_rcv, icmp6_rcv);
+	return 0;
+}
+
+void mipv6_shutdown_icmpv6(void)
+{
+
+	if (icmpv6_socket)
+		sock_release(icmpv6_socket);
+	icmpv6_socket = NULL; /* For safety */
+}
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/mipv6_icmp.h linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/mipv6_icmp.h
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/mipv6_icmp.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/mipv6_icmp.h	2003-05-18 11:33:53.000000000 +0200
@@ -0,0 +1,74 @@
+/**
+ * ICMP send and receive prototypes
+ *
+ * Authors:
+ * Jaakko Laine <medved@iki.fi>
+ *
+ * $Id: s.mipv6_icmp.h 1.6 02/11/25 11:18:16+02:00 vnuorval@amber.hut.mediapoli.com $
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#ifndef _MIPV6_ICMP
+#define _MIPV6_ICMP
+
+#include <linux/config.h>
+#include <linux/in6.h>
+
+/**
+ * mipv6_icmpv6_send - generic icmpv6 message send
+ * @daddr: destination address
+ * @saddr: source address
+ * @type: icmp type
+ * @code: icmp code
+ * @id: packet identifier. If null, uses internal counter to get new id
+ * @data: packet data
+ * @datalen: length of data in bytes
+ */
+void mipv6_icmpv6_send(struct in6_addr *daddr, struct in6_addr *saddr, int type,
+		       int code,  __u16 *id, void *data, int datalen);
+
+/*
+ * Send DHAAD request to home subnet's Home Agents anycast address 
+ */
+void mipv6_icmpv6_send_dhaad_req(struct in6_addr *home_addr, int plen, __u16 dhaad_id);
+
+/*
+ * Send DHAAD reply in response to DHAAD request
+ */
+void mipv6_icmpv6_send_dhaad_rep(int ifindex, __u16 id, struct in6_addr *daddr);
+
+#ifdef CONFIG_IPV6_MOBILITY_MN
+
+/* Receive DHAAD Reply message */
+int mipv6_icmpv6_rcv_dhaad_rep(struct sk_buff *skb);
+/* Receive Parameter Problem message */
+int mipv6_icmpv6_rcv_paramprob(struct sk_buff *skb);
+/* Receive prefix advertisements */
+int mipv6_icmpv6_rcv_pfx_adv(struct sk_buff *skb);
+
+#else
+static inline int mipv6_icmpv6_rcv_dhaad_rep(struct sk_buff *skb) { return 0; }
+static inline int mipv6_icmpv6_rcv_paramprob(struct sk_buff *skb) { return 0; }
+static inline int mipv6_icmpv6_rcv_pfx_adv(struct sk_buff *skb) { return 0; }
+#endif
+
+#ifdef CONFIG_IPV6_MOBILITY_HA
+
+/* Receive DHAAD Request message */
+int mipv6_icmpv6_rcv_dhaad_req(struct sk_buff *skb);
+/* Receive prefix solicitations */
+int mipv6_icmpv6_rcv_pfx_sol(struct sk_buff *skb);
+
+#else
+static inline int mipv6_icmpv6_rcv_dhaad_req(struct sk_buff *skb) { return 0; }
+static inline int mipv6_icmpv6_rcv_pfx_sol(struct sk_buff *skb) { return 0; }
+#endif
+
+int mipv6_initialize_icmpv6(void);
+void mipv6_shutdown_icmpv6(void);
+
+#endif
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/mipv6_icmp_ha.c linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/mipv6_icmp_ha.c
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/mipv6_icmp_ha.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/mipv6_icmp_ha.c	2003-05-18 11:33:53.000000000 +0200
@@ -0,0 +1,188 @@
+/*
+ *	Home Agent specific ICMP routines
+ *
+ *	Authors:
+ *	Antti Tuominen	<ajtuomin@tml.hut.fi>
+ *	Jaakko Laine	<medved@iki.fi>
+ *
+ *      $Id$
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/autoconf.h>
+#include <linux/sched.h>
+#include <net/ipv6.h>
+#include <net/addrconf.h>
+#include <net/ip6_route.h>
+#include <net/mipv6.h>
+
+#include "halist.h"
+#include "mdetect.h"
+#include "debug.h"
+#include "util.h"
+#include "mipv6_icmp.h"
+#include "prefix.h"
+
+/**
+ * mipv6_icmpv6_send_dhaad_rep - Reply to DHAAD Request
+ * @ifindex: index of interface request was received from
+ * @id: request's identification number
+ * @daddr: requester's IPv6 address
+ *
+ * When Home Agent receives Dynamic Home Agent Address Discovery
+ * request, it replies with a list of home agents available on the
+ * home link.
+ */
+void mipv6_icmpv6_send_dhaad_rep(int ifindex, __u16 id, struct in6_addr *daddr)
+{
+	__u8 *data, *addrs;
+	struct in6_addr home, *ha_addrs = NULL;
+	int addr_count, max_addrs, size = 0;
+
+	if (daddr == NULL)
+		return;
+
+	if (mipv6_ha_get_addr(ifindex, &home) < 0) {
+		DEBUG(DBG_INFO, "Not Home Agent in this interface");
+		return;
+	}
+
+	/* We send all available HA addresses, not exceeding a maximum
+	 * number we can fit in a packet with minimum IPv6 MTU (to
+	 * avoid fragmentation).
+	 */
+	max_addrs = 76;
+	addr_count = mipv6_ha_get_pref_list(ifindex, &ha_addrs, max_addrs);
+
+	if (addr_count < 0) return;
+
+	if (addr_count != 0 && ha_addrs == NULL) {
+		DEBUG(DBG_ERROR, "addr_count = %d but return no addresses", 
+		      addr_count);
+		return;
+	}
+	/* We allocate space for the icmp data with 8 reserved bytes
+	 * in the beginning (there is actually 10 but first 2 are part
+	 * of the icmp6hdr).
+	 */
+	size = 8 + addr_count * sizeof(struct in6_addr);
+	data = kmalloc(size, GFP_ATOMIC);
+	if (data == NULL) {
+		DEBUG(DBG_ERROR, "Couldn't allocate memory");
+		kfree(ha_addrs);
+		return;
+	}
+
+	memset(data, 0, size);
+	if (addr_count > 0) {
+		int off = 0;
+		if (ipv6_addr_cmp(ha_addrs, &home) == 0) {
+			size -= sizeof(struct in6_addr);
+			off = 1;
+		}
+		if (addr_count > off) {
+			addrs = (data + 8); /* skip reserved and copy addresses*/
+			memcpy(addrs, ha_addrs + off, 
+			       (addr_count - off) * sizeof(struct in6_addr));
+		}
+		kfree(ha_addrs);
+	}
+
+	mipv6_icmpv6_send(daddr, &home, MIPV6_DHAAD_REPLY, 0, &id, &data, size);
+	kfree(data);
+}
+
+/** 
+ * mipv6_icmpv6_dhaad_req - Home Agent Address Discovery Request ICMP handler
+ * @skb: buffer containing ICMP information message
+ *
+ * Special Mobile IPv6 ICMP message.  Handles Dynamic Home Agent
+ * Address Discovery Request messages.
+ **/
+int mipv6_icmpv6_rcv_dhaad_req(struct sk_buff *skb)
+{
+	struct icmp6hdr *phdr = (struct icmp6hdr *) skb->h.raw;
+	struct in6_addr *saddr = &skb->nh.ipv6h->saddr;
+	struct in6_addr *daddr = &skb->nh.ipv6h->daddr;
+	__u16 identifier;
+	int ifindex = ((struct inet6_skb_parm *)skb->cb)->iif;
+	struct rt6_info *rt;
+	struct in6_addr ha_anycast;
+
+	DEBUG_FUNC();
+
+	/* Invalid packet checks. */
+	if (phdr->icmp6_code != 0)
+		return 0;
+
+	identifier = ntohs(phdr->icmp6_identifier);
+
+
+	/*
+	 * Use the network prefix only but not the
+	 * entire * address from the anycast to find
+	 * out the route entry * corresponding to a
+	 * proper device entry but not a 'lo' * entry.
+	 */
+	ipv6_addr_set(&ha_anycast, daddr->s6_addr32[0], 
+		      daddr->s6_addr32[1], 0, 0);
+
+	/* 
+	 * Make sure we have the right ifindex (if the
+	 * req came through another interface. 
+	 */
+
+	rt = rt6_lookup(&ha_anycast, NULL, 0, 0);
+	if (rt) {
+		ifindex = rt->rt6i_dev->ifindex;
+		dst_release(&rt->u.dst);
+	} else {
+		/*
+		 * Can't send a reply since the right
+		 * interface * is not found 
+		 */
+		DEBUG(DBG_WARNING, "No route entry found for"
+		      "a DHAAD request");
+		return 0;
+	}
+	/*
+	 * send reply with list
+	 */
+	mipv6_icmpv6_send_dhaad_rep(ifindex, identifier, saddr);
+	return 1;
+}
+
+/**
+ * mipv6_icmpv6_handle_pfx_sol - handle prefix solicitations
+ * @skb: sk_buff including the icmp6 message
+ */
+int mipv6_icmpv6_rcv_pfx_sol(struct sk_buff *skb)
+{
+	struct icmp6hdr *hdr = (struct icmp6hdr *) skb->h.raw;
+	struct in6_addr *saddr = &skb->nh.ipv6h->saddr;
+	struct in6_addr *daddr = &skb->nh.ipv6h->daddr;
+	struct prefix_info *plist;
+	struct inet6_ifaddr *ifp;
+	__u16 identifier = ntohs(hdr->icmp6_identifier);
+	int count;
+
+	DEBUG_FUNC();
+
+	if (!(ifp = ipv6_get_ifaddr(daddr, NULL)))
+		return -1;
+
+	if ((count = ipv6_get_prefix_entries(&plist, ifp->idev->dev->ifindex, 0)) > 0) {
+		mipv6_icmpv6_send(saddr, daddr, MIPV6_PREFIX_ADV, 0, &identifier,
+				  plist, count * sizeof(struct prefix_info));
+		kfree(plist);
+	}
+
+	in6_ifa_put(ifp);
+	mipv6_pfx_cancel_send(saddr, -1);
+
+	return 0;
+}
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/mipv6_icmp_mn.c linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/mipv6_icmp_mn.c
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/mipv6_icmp_mn.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/mipv6_icmp_mn.c	2003-05-18 11:33:53.000000000 +0200
@@ -0,0 +1,300 @@
+/*
+ *	Mobile Node specific ICMP routines
+ *
+ *	Authors:
+ *	Antti Tuominen	<ajtuomin@tml.hut.fi>
+ *	Jaakko Laine	<medved@iki.fi>
+ *
+ *      $Id$
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/sched.h>
+#include <net/ipv6.h>
+#include <net/ip6_route.h>
+#include <net/addrconf.h>
+#include <net/mipv6.h>
+
+#include "halist.h"
+#include "mn.h"
+#include "bul.h"
+#include "mdetect.h"
+#include "debug.h"
+#include "util.h"
+#include "mipv6_icmp.h"
+#include "prefix.h"
+
+#define INFINITY 0xffffffff
+
+/* BUL callback */
+
+static int bul_entry_expired(struct mipv6_bul_entry *bulentry)
+{
+	DEBUG(DBG_INFO, "bul entry 0x%x lifetime expired, deleting entry",
+	      (int) bulentry);
+	return 1;
+}
+
+/**
+ * mipv6_icmpv6_paramprob - Parameter Problem ICMP error message handler
+ * @skb: buffer containing ICMP error message
+ *
+ * Special Mobile IPv6 ICMP handling.  If Mobile Node receives ICMP
+ * Parameter Problem message when using a Home Address Option,
+ * offending node should be logged and error message dropped.  If
+ * error is received because of a Binding Update, offending node
+ * should be recorded in Binding Update List and no more Binding
+ * Updates should be sent to this destination.  See draft section
+ * 10.15.
+ **/
+int mipv6_icmpv6_rcv_paramprob(struct sk_buff *skb)
+{
+	struct icmp6hdr *phdr = (struct icmp6hdr *) skb->h.raw;
+	struct in6_addr *saddr = skb ? &skb->nh.ipv6h->saddr : NULL;
+	struct in6_addr *daddr = skb ? &skb->nh.ipv6h->daddr : NULL;
+	struct ipv6hdr *hdr = (struct ipv6hdr *) (phdr + 1);
+	int ulen = (skb->tail - (unsigned char *) (phdr + 1));
+
+	int errptr;
+	__u8 *off_octet;
+
+	DEBUG_FUNC();
+
+	/* We only handle code 1 & 2 messages. */
+	if (phdr->icmp6_code != ICMPV6_UNK_NEXTHDR &&
+		phdr->icmp6_code != ICMPV6_UNK_OPTION)
+		return 0;
+
+	/* Find offending octet in the original packet. */
+	errptr = ntohl(phdr->icmp6_pointer);
+
+	/* There is not enough of the original packet left to figure
+	 * out what went wrong. Bail out. */
+	if (ulen <= errptr)
+		return 0;
+
+	off_octet = ((__u8 *) hdr + errptr);
+	DEBUG(DBG_INFO, "Parameter problem: offending octet %d [0x%2x]",
+	      errptr, *off_octet);
+
+	/* If CN did not understand Mobility Header, set BUL entry to
+	 * ACK_ERROR so no further BUs are sumbitted to this CN. */
+	if (phdr->icmp6_code == ICMPV6_UNK_NEXTHDR) {
+		struct mipv6_bul_entry *bulentry = NULL;
+		if (*off_octet != IPPROTO_MOBILITY)
+			return 0;
+
+		write_lock_bh(&bul_lock);
+		bulentry = mipv6_bul_get(saddr, daddr);
+		if (bulentry) {
+			bulentry->state = ACK_ERROR;
+			bulentry->callback = bul_entry_expired;
+			bulentry->callback_time = jiffies +
+				DUMB_CN_BU_LIFETIME * HZ;
+			DEBUG(DBG_INFO, "BUL entry set to ACK_ERROR");
+			mipv6_bul_reschedule(bulentry);
+		}
+		write_unlock_bh(&bul_lock);
+	}
+
+	/* If CN did not understand Home Address Option, we log an
+	 * error and discard the error message. */
+	if (phdr->icmp6_code == ICMPV6_UNK_OPTION &&
+	    *off_octet == MIPV6_TLV_HOMEADDR) {
+		DEBUG(DBG_WARNING, "Correspondent node does not "
+		      "implement Home Address Option receipt.");
+		return 1;
+	}
+	return 0;
+}
+
+/**
+ * mipv6_mn_dhaad_send_req - Send DHAAD Request to home network
+ * @home_addr: address to do DHAAD for
+ * @plen: prefix length for @home_addr
+ *
+ * Send Dynamic Home Agent Address Discovery Request to the Home
+ * Agents anycast address in the nodes home network.
+ **/
+void 
+mipv6_icmpv6_send_dhaad_req(struct in6_addr *home_addr, int plen, __u16 dhaad_id)
+{
+	struct in6_addr ha_anycast;
+	struct in6_addr careofaddr;
+	
+	if (mipv6_get_care_of_address(home_addr, &careofaddr) < 0) {
+		DEBUG(DBG_WARNING, "Could not get node's Care-of Address");
+		return;
+	}
+
+	ipv6_addr_copy(&ha_anycast, home_addr);
+	if (homeagent_anycast(&ha_anycast, plen) < 0) {
+		DEBUG(DBG_WARNING, 
+		      "Could not get Home Agent Anycast address");
+		return;
+	}
+
+	mipv6_icmpv6_send(&ha_anycast, &careofaddr, MIPV6_DHAAD_REQUEST, 0, 
+			  &dhaad_id, NULL, 0);
+
+}
+
+/** 
+ * mipv6_icmpv6_dhaad_rep - Home Agent Address Discovery Reply ICMP handler
+ * @skb: buffer containing ICMP information message
+ *
+ * Special Mobile IPv6 ICMP message.  Handles Dynamic Home Agent
+ * Address Discovery Reply messages.
+ **/
+int mipv6_icmpv6_rcv_dhaad_rep(struct sk_buff *skb)
+{
+	struct icmp6hdr *phdr = (struct icmp6hdr *) skb->h.raw;
+	struct in6_addr *address;
+	struct in6_addr *saddr = &skb->nh.ipv6h->saddr;
+	__u16 identifier;
+	int ulen = (skb->tail - (unsigned char *) ((__u32 *) phdr + 4));
+	int i;
+	struct in6_addr home_addr, coa;
+	struct in6_addr *first_ha = NULL;
+	struct mn_info *minfo;
+	int sender_on_list = 0;
+	int n_addr = ulen / sizeof(struct in6_addr);
+
+	DEBUG_FUNC();
+
+	/* Invalid packet checks. */
+	if (ulen % sizeof(struct in6_addr) != 0)
+		return 0;
+
+	if (phdr->icmp6_code != 0)
+		return 0;
+
+	identifier = ntohs(phdr->icmp6_identifier);
+	address = (struct in6_addr *) ((__u32 *) phdr + 4);
+
+	/* receive list of home agent addresses
+	 * add to home agents list
+	 */
+	if (ulen % sizeof(struct in6_addr)) return 1;
+	DEBUG(DBG_INFO, "DHAAD: got %d home agents", n_addr);
+
+	first_ha = address;
+
+	/* lookup H@ with identifier */
+	read_lock(&mn_info_lock);
+	minfo = mipv6_mninfo_get_by_id(identifier);
+	if (!minfo) {
+		read_unlock(&mn_info_lock);
+		DEBUG(DBG_INFO, "no mninfo with id %d", 
+		      identifier);
+		return 0;
+	}
+	spin_lock(&minfo->lock);
+
+	/* Logic:
+	 * 1. if old HA on list, prefer it
+	 * 2. if reply sender not on list, prefer it
+	 * 3. otherwise first HA on list prefered
+	 */
+	for (i = 0; i < n_addr; i++) {
+		DEBUG(DBG_INFO, "HA[%d] %x:%x:%x:%x:%x:%x:%x:%x",
+		      i, NIPV6ADDR(address));
+		if (ipv6_addr_cmp(saddr, address) == 0)
+			sender_on_list = 1;
+		if (ipv6_addr_cmp(&minfo->ha, address) == 0) {
+			spin_unlock(&minfo->lock);
+			read_unlock(&mn_info_lock);
+			return 0;
+		}
+		address++;
+	}
+	if (!sender_on_list)
+		ipv6_addr_copy(&minfo->ha, saddr);
+	else
+		ipv6_addr_copy(&minfo->ha, first_ha);
+	spin_unlock(&minfo->lock);
+	ipv6_addr_copy(&home_addr, &minfo->home_addr);
+	read_unlock(&mn_info_lock);
+
+	mipv6_get_care_of_address(&home_addr, &coa);
+	init_home_registration(&home_addr, &coa);
+
+	return 1;
+}
+
+/**
+ * mipv6_icmpv6_handle_pfx_adv - handle prefix advertisements
+ * @skb: sk_buff including the icmp6 message
+ */
+int mipv6_icmpv6_rcv_pfx_adv(struct sk_buff *skb)
+{
+	struct icmp6hdr *hdr = (struct icmp6hdr *) skb->h.raw;
+	struct in6_addr *saddr = &skb->nh.ipv6h->saddr;
+	struct in6_addr *daddr = &skb->nh.ipv6h->daddr;
+	__u8 *opt = (__u8 *) (hdr + 1);
+	int optlen = (skb->tail - opt);
+	unsigned long min_expire = INFINITY;
+	struct inet6_skb_parm *parm = (struct inet6_skb_parm *) skb->cb;
+
+	DEBUG_FUNC();
+
+	while (optlen > 0) {
+		int len = opt[1] << 3;
+		if (len == 0)
+			goto set_timer;
+
+		if (opt[0] == ND_OPT_PREFIX_INFO) {
+			int ifindex;
+			unsigned long expire;
+			struct prefix_info *pinfo =
+				(struct prefix_info *) opt;
+			struct in6_addr home_addr;
+			struct net_device *dev;
+			struct mn_info *mninfo;
+
+			read_lock(&mn_info_lock);
+			mninfo = mipv6_mninfo_get_by_ha(saddr);
+			if (mninfo == NULL) {
+				ifindex = 0;
+			} else {
+				spin_lock(&mninfo->lock);
+				ifindex = mninfo->ifindex;
+				spin_unlock(&mninfo->lock);
+				mninfo = NULL;
+			}
+			read_unlock(&mn_info_lock);
+
+			if (!(dev = dev_get_by_index(ifindex))) {
+				DEBUG(DBG_WARNING, "Cannot find device by index %d", parm->iif);
+				goto nextopt;
+			}
+
+			expire = ntohl(pinfo->valid);
+			expire = expire == 0 ? INFINITY : expire;
+
+			min_expire = expire < min_expire ? expire : min_expire;
+
+			if (addrconf_pfx_adv_rcv(dev, pinfo, &home_addr) > 0)
+				mipv6_mninfo_add(ifindex, &home_addr, 
+						 pinfo->prefix_len, 
+						 MN_NOT_AT_HOME,
+						 ntohl(pinfo->valid),
+						 saddr, 0, 0, 0);
+
+			dev_put(dev);
+		}
+
+nextopt:
+		optlen -= len;
+		opt += len;
+	}
+
+set_timer:
+
+	mipv6_pfx_add_home(parm->iif, saddr, daddr, min_expire);
+	return 0;
+}
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/mipv6_ioctl.h linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/mipv6_ioctl.h
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/mipv6_ioctl.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/mipv6_ioctl.h	2003-05-18 11:33:53.000000000 +0200
@@ -0,0 +1,92 @@
+/*      
+ *	IOCTLs for MIPL Mobile IPv6 module
+ *	
+ *      Authors: 
+ *      Henrik Petander         <lpetande@tml.hut.fi>
+ * 
+ *      $Id: s.mipv6_ioctl.h 1.18 02/11/25 11:18:16+02:00 vnuorval@amber.hut.mediapoli.com $ 
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ *
+ *
+ */
+
+#ifndef _MIPV6_IOCTL_H
+#define _MIPV6_IOCTL_H
+
+#include <linux/ioctl.h> 
+
+int mipv6_ioctl_mn_init(void);
+int mipv6_ioctl_ha_init(void);
+void mipv6_ioctl_mn_exit(void);
+void mipv6_ioctl_ha_exit(void);
+void set_sa_acq(void);
+void un_set_sa_acq(void);
+
+/*
+ * Mobile Node information record for userspace coomunications
+ */
+struct mn_info_ext {
+	struct in6_addr home_addr;
+	struct in6_addr ha;
+	__u8 home_plen;
+	__u8 is_at_home;
+	__u8 has_home_reg;
+	__u8 man_conf;
+	int ifindex;
+	unsigned long home_addr_expires;
+};
+
+/* Reserved for local / experimental use */
+#define MAJOR_NUM 0xf9
+
+/* Adds a SA (manual keying) */
+#define IOCTL_DEL_SA_BUNDLE _IOWR(MAJOR_NUM, 0, void *)
+
+/* Adds an outbound SA as a result of ACQUIRE */
+#define IOCTL_ADD_OB_SA _IOWR(MAJOR_NUM, 1, void *) 
+
+/* Adds an outbound SA as a result of ACQUIRE */
+#define IOCTL_ADD_IB_SA _IOWR(MAJOR_NUM, 2, void *) 
+
+/* Tells the kmd to create a SA */
+#define IOCTL_ACQUIRE_SA _IOR(MAJOR_NUM, 3, void *)
+
+/* Prints a sa_bundle */
+#define IOCTL_PRINT_SA _IOWR(MAJOR_NUM, 4, void *)
+
+/* Set home address information for Mobile Node */
+#define IOCTL_SET_HOMEADDR _IOR(MAJOR_NUM, 5, void *)
+
+/* Set home agent information for Mobile Node */
+#define IOCTL_SET_HOMEAGENT _IOR(MAJOR_NUM, 6, void *)
+
+/* Get home address information for Mobile Node */
+#define IOCTL_GET_HOMEADDR _IOWR(MAJOR_NUM, 7, void *)
+
+/* Get home agent information for Mobile Node */
+#define IOCTL_GET_HOMEAGENT _IOWR(MAJOR_NUM, 8, void *)
+
+/* Get Care-of address information for Mobile Node */
+#define IOCTL_GET_CAREOFADDR _IOWR(MAJOR_NUM, 9, void *)
+
+/* Set home address and corresponding home agent address */
+#define IOCTL_SET_MN_INFO _IOR(MAJOR_NUM, 14, void *)
+
+/* Get home address and corresponding home agent address */
+#define IOCTL_GET_MN_INFO _IOWR(MAJOR_NUM, 15, void *)
+
+#define IOCTL_ADD_ACL_RULE _IOWR(MAJOR_NUM, 16, void *)
+
+#define MA_IOCTL_REQUEST_IFACE _IOR (MAJOR_NUM, 10, void *)
+#define MA_IOCTL_PRINT_CURRENT_IFACE _IOWR (MAJOR_NUM, 11, void *)
+#define MA_IOCTL_PRINT_IFACE_PREFERENCES _IOWR (MAJOR_NUM, 12, void *)
+#define MA_IOCTL_SET_IFACE_PREFERENCE _IOR (MAJOR_NUM, 13, void *)
+
+/* The name of the device file */
+#define CTLFILE "mipv6_dev"
+
+#endif /* _MIPV6_IOCTL_H */
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/mn.c linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/mn.c
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/mn.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/mn.c	2003-05-18 11:33:53.000000000 +0200
@@ -0,0 +1,1429 @@
+/*
+ *      Mobile-node functionality
+ *
+ *      Authors:
+ *      Sami Kivisaari          <skivisaa@cc.hut.fi>
+ *
+ *      $Id: s.mn.c 1.160 02/12/20 09:30:48+02:00 antti@jon.mipl.mediapoli.com $
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/autoconf.h>
+#include <linux/sched.h>
+#include <linux/ipv6.h>
+#include <linux/net.h>
+#include <linux/init.h>
+#include <linux/skbuff.h>
+#include <linux/rtnetlink.h>
+#include <linux/if_arp.h>
+#include <linux/ipsec.h>
+#include <linux/notifier.h>
+#include <linux/list.h>
+#include <linux/route.h>
+#include <linux/netfilter.h>
+#include <linux/netfilter_ipv6.h>
+#include <linux/tqueue.h>
+#include <linux/proc_fs.h>
+
+#include <asm/uaccess.h>
+
+#include <net/ipv6.h>
+#include <net/addrconf.h>
+#include <net/ndisc.h>
+#include <net/ipv6_tunnel.h>
+#include <net/ip6_route.h>
+#include <net/mipglue.h>
+
+#include "util.h"
+#include "mdetect.h"
+#include "bul.h"
+#include "mobhdr.h"
+#include "hashlist.h"
+#include "debug.h"
+#include "mn.h"
+#include "mipv6_icmp.h"
+#include "multiaccess_ctl.h"
+#include "prefix.h"
+#include "tunnel.h"
+#include "stats.h"
+
+#define MIPV6_BUL_SIZE 128
+#define EXPIRE_INFINITE 0xffffffff
+
+static LIST_HEAD(mn_info_list);
+/* Lock for list of MN infos */
+rwlock_t mn_info_lock = RW_LOCK_UNLOCKED;
+
+static spinlock_t ifrh_lock = SPIN_LOCK_UNLOCKED;
+
+static LIST_HEAD(ifrh_list);
+
+struct ifr_holder {
+	struct list_head list;
+	struct in6_ifreq ifr;
+	int old_ifi;
+};
+
+static struct tq_struct mv_home_addr_task;
+
+/* Whether all parts are initialized, from mipv6.c */
+extern int mipv6_is_initialized;
+
+/* Determines whether manually configured home addresses are preferred as 
+ * source addresses over dynamically configured ones
+ */
+int mipv6_use_preconfigured_hoaddr = 1; 
+
+/* Determines whether home addresses, which are at home are preferred as 
+ * source addresses over other home addresses
+ */
+int mipv6_use_topol_corr_hoaddr = 0;
+
+/*  Defined in ndisc.c of IPv6 module */
+extern void ndisc_send_na(
+	struct net_device *dev, struct neighbour *neigh,
+	struct in6_addr *daddr, struct in6_addr *solicited_addr,
+	int router, int solicited, int override, int inc_opt);
+
+static spinlock_t icmpv6_id_lock = SPIN_LOCK_UNLOCKED;
+static __u16 icmpv6_id = 0;
+
+static inline __u16 mipv6_get_dhaad_id(void)
+{
+	__u16 ret;
+	spin_lock_bh(&icmpv6_id_lock);
+	ret = ++icmpv6_id;
+	spin_unlock_bh(&icmpv6_id_lock);
+	return ret;
+}
+
+/** 
+ * mipv6_mninfo_get_by_home - Returns mn_info for a home address
+ * @haddr: home address of MN
+ *
+ * Returns mn_info on success %NULL otherwise.  Caller MUST hold
+ * @mn_info_lock (read or write).
+ **/
+struct mn_info *mipv6_mninfo_get_by_home(struct in6_addr *haddr)
+{
+	struct list_head *lh;
+	struct mn_info *minfo;
+
+	DEBUG_FUNC();
+
+	if (!haddr)
+		return NULL;
+
+	list_for_each(lh, &mn_info_list) {
+		minfo = list_entry(lh, struct mn_info, list);
+		spin_lock(&minfo->lock);
+		if (!ipv6_addr_cmp(&minfo->home_addr, haddr)) {
+			spin_unlock(&minfo->lock);
+			return minfo;
+		}
+		spin_unlock(&minfo->lock);
+	}
+	return NULL;
+}
+
+/**
+ * mipv6_mninfo_get_by_ha - Lookup mn_info with Home Agent address
+ * @home_agent: Home Agent address
+ *
+ * Searches for a mn_info entry with @ha set to @home_agent.  You MUST
+ * hold @mn_info_lock when calling this function.  Returns pointer to
+ * mn_info entry or %NULL on failure.
+ **/
+struct mn_info *mipv6_mninfo_get_by_ha(struct in6_addr *home_agent)
+{
+	struct list_head *lh;
+	struct mn_info *minfo;
+
+	if (!home_agent)
+		return NULL;
+
+	list_for_each(lh, &mn_info_list) {
+		minfo = list_entry(lh, struct mn_info, list);
+		spin_lock(&minfo->lock);
+		if (!ipv6_addr_cmp(&minfo->ha, home_agent)) {
+			spin_unlock(&minfo->lock);
+			return minfo;
+		}
+		spin_unlock(&minfo->lock);
+	}
+	return NULL;
+}
+
+/**
+ * mipv6_mninfo_get_by_id - Lookup mn_info with id
+ * @id: DHAAD identifier
+ *
+ * Searches for a mn_info entry with @dhaad_id set to @id.  You MUST
+ * hold @mn_info_lock when calling this function.  Returns pointer to
+ * mn_info entry or %NULL on failure.
+ **/
+struct mn_info *mipv6_mninfo_get_by_id(unsigned short id)
+{
+	struct list_head *lh;
+	struct mn_info *minfo = 0;
+
+	list_for_each(lh, &mn_info_list) {
+		minfo = list_entry(lh, struct mn_info, list);
+		spin_lock(&minfo->lock);
+		if (minfo->dhaad_id == id) {
+			spin_unlock(&minfo->lock);
+			return minfo;
+		}
+		spin_unlock(&minfo->lock);
+	}
+	return NULL;
+}
+
+/** 
+ * mipv6_mninfo_add - Adds a new home info for MN
+ * @ifindex: Interface for home address
+ * @home_addr:  Home address of MN, must be set
+ * @plen: prefix length of the home address, must be set
+ * @isathome : home address at home
+ * @lifetime: lifetime of the home address, 0 is infinite
+ * @ha: home agent for the home address
+ * @ha_plen: prefix length of home agent's address, can be zero 
+ * @ha_lifetime: Lifetime of the home address, 0 is infinite
+ *
+ * The function adds a new home info entry for MN, allowing it to
+ * register the home address with the home agent.  Starts home
+ * registration process.  If @ha is %ADDRANY, DHAAD is performed to
+ * find a home agent.  Returns 0 on success, a negative value
+ * otherwise.  Caller MUST NOT hold @mn_info_lock or
+ * @addrconf_hash_lock.
+ **/
+void mipv6_mninfo_add(int ifindex, struct in6_addr *home_addr, int plen, 
+		      int isathome, unsigned long lifetime, struct in6_addr *ha, 
+		      int ha_plen, unsigned long ha_lifetime, int man_conf)
+{
+	struct mn_info *minfo;
+	struct in6_addr coa;
+
+	DEBUG_FUNC();
+
+	write_lock_bh(&mn_info_lock);
+	if ((minfo = mipv6_mninfo_get_by_home(home_addr)) == NULL) {
+	        minfo = kmalloc(sizeof(struct mn_info), GFP_ATOMIC);
+		if (!minfo) {
+			write_unlock_bh(&mn_info_lock);
+			return;
+		}
+		memset(minfo, 0, sizeof(struct mn_info));
+		spin_lock_init(&minfo->lock);
+	}
+	
+	ipv6_addr_copy(&minfo->home_addr, home_addr);
+
+	if (ha)
+		ipv6_addr_copy(&minfo->ha, ha);
+	minfo->home_plen = plen;       
+	minfo->ifindex = ifindex;
+
+	/* TODO: we should get home address lifetime from somewhere */
+	/* minfo->home_addr_expires = jiffies + lifetime * HZ; */
+
+	/* manual configuration flag cannot be unset by dynamic updates 
+	 *  from prefix advertisements
+	 */
+	if (!minfo->man_conf) minfo->man_conf = man_conf; 
+	minfo->is_at_home = isathome;
+
+	list_add(&minfo->list, &mn_info_list);
+	write_unlock_bh(&mn_info_lock);
+
+	mipv6_get_care_of_address(home_addr, &coa); 
+	init_home_registration(home_addr, &coa);
+}
+
+/**
+ * mipv6_mninfo_del - Delete home info for MN 
+ * @home_addr : Home address or prefix 
+ * @del_dyn_only : Delete only dynamically created home entries 
+ *
+ *
+ * Deletes every mn_info entry that matches the first plen bits of
+ * @home_addr.  Returns number of deleted entries on success and a
+ * negative value otherwise.  Caller MUST NOT hold @mn_info_lock.
+ **/
+int mipv6_mninfo_del(struct in6_addr *home_addr, int del_dyn_only)
+{
+	struct list_head *lh, *next;
+	struct mn_info *minfo;
+	int ret = -1;
+	if (!home_addr)
+		return -1;
+
+	write_lock(&mn_info_lock);
+
+	list_for_each_safe(lh, next, &mn_info_list) {
+		minfo = list_entry(lh, struct mn_info, list);
+		if (!mipv6_prefix_compare(&minfo->home_addr, home_addr, 
+					  minfo->home_plen) 
+		    && ((!minfo->man_conf && del_dyn_only) || !del_dyn_only)) {
+			list_del(&minfo->list);
+			kfree(minfo);
+			ret++;
+		}
+	}
+	write_unlock(&mn_info_lock);
+	return ret;
+}
+
+void mipv6_mn_set_home(int ifindex, struct in6_addr *homeaddr, int plen,
+		       struct in6_addr *homeagent, int ha_plen)
+{
+	mipv6_mninfo_add(ifindex, homeaddr, plen, 0, 0, 
+			 homeagent, ha_plen, 0, 1);
+}
+
+/**
+ * mipv6_mn_is_home_addr - Determines if addr is node's home address
+ * @addr: IPv6 address
+ *
+ * Returns 1 if addr is node's home address.  Otherwise returns zero.
+ **/
+int mipv6_mn_is_home_addr(struct in6_addr *addr)
+{
+	int ret = 0;
+
+	if (addr == NULL) {
+		DEBUG(DBG_CRITICAL, "Null argument");
+		return -1;
+	}
+	read_lock_bh(&mn_info_lock);
+	if (mipv6_mninfo_get_by_home(addr))
+		ret = 1;
+	read_unlock_bh(&mn_info_lock);
+
+	return (ret);
+}
+
+
+/** 
+ * mipv6_mn_is_at_home - determine if node is home for a home address
+ * @home_addr : home address of MN
+ *
+ * Returns 1 if home address in question is in the home network, 0
+ * otherwise.  Caller MUST NOT not hold @mn_info_lock.
+ **/ 
+int mipv6_mn_is_at_home(struct in6_addr *home_addr)
+{
+	struct mn_info *minfo;
+	int ret = 0;
+	read_lock_bh(&mn_info_lock);
+	if ((minfo = mipv6_mninfo_get_by_home(home_addr)) != NULL) {
+		spin_lock(&minfo->lock);
+		ret = (minfo->is_at_home == MN_AT_HOME);
+		spin_unlock(&minfo->lock);
+	}
+	read_unlock_bh(&mn_info_lock);
+	return ret;
+}	
+
+/**
+ * mipv6_mn_get_homeaddr - Get node's home address
+ * @home_addr: buffer to store home address
+ *
+ * Stores Mobile Node's home address in the given space.  Returns
+ * prefix length of home address.  Negative return value means failure
+ * to retrieve home address.  Caller MUST NOT hold @mn_info_lock.
+ **/
+int mipv6_mn_get_homeaddr(struct in6_addr *home_addr)
+{
+	struct mn_info *minfo;
+	struct list_head *p;
+	int plen = 0;
+
+	if (!home_addr) return -1;
+
+	read_lock_bh(&mn_info_lock);
+
+	if (list_empty(&mn_info_list)) {
+		read_unlock_bh(&mn_info_lock);
+		return -1;
+	}
+
+	p = mn_info_list.next;
+
+	if (p != NULL) {
+		minfo = list_entry(p, struct mn_info, list);
+		ipv6_addr_copy(home_addr, &minfo->home_addr);
+		spin_lock(&minfo->lock);
+		plen = minfo->home_plen;
+		spin_unlock(&minfo->lock);
+	}
+	read_unlock_bh(&mn_info_lock);
+
+	return plen;
+}
+
+void mipv6_get_saddr_hook(struct inet6_ifaddr *ifp,
+			  struct in6_addr *homeaddr)
+{
+	int found = 0, reiter = 0;
+	struct list_head *lh;
+	struct mn_info *minfo = NULL;
+	struct in6_addr coa;
+
+	read_lock_bh(&mn_info_lock);
+restart:
+	list_for_each(lh, &mn_info_list) {
+		minfo = list_entry(lh, struct mn_info, list);
+		if ((ipv6_addr_scope(homeaddr) != ipv6_addr_scope(&minfo->home_addr)) 
+		    || ipv6_chk_addr(&minfo->home_addr, NULL) == 0)
+			continue; 
+
+		spin_lock(&minfo->lock);
+		if (minfo->is_at_home == MN_AT_HOME || minfo->has_home_reg) {
+			if ((mipv6_use_topol_corr_hoaddr && 
+			     minfo->is_at_home == MN_AT_HOME) || 
+			    (mipv6_use_preconfigured_hoaddr && 
+			     minfo->man_conf) ||
+			    (!(mipv6_use_preconfigured_hoaddr || 
+			       mipv6_use_topol_corr_hoaddr) || reiter)) {
+				spin_unlock(&minfo->lock);
+				ipv6_addr_copy(homeaddr, &minfo->home_addr);
+				found = 1;
+				break;
+			}
+		}
+		spin_unlock(&minfo->lock);
+	}
+	if (!found && !reiter) {
+		reiter = 1;
+		goto restart;
+	}
+
+	if (!found && minfo && 
+	    !mipv6_get_care_of_address(&minfo->home_addr, &coa)) {
+		ipv6_addr_copy(homeaddr, &coa); 
+	}
+	read_unlock_bh(&mn_info_lock);
+
+	DEBUG(DBG_INFO, "Source address selection:  %x:%x:%x:%x:%x:%x:%x:%x", 
+	      NIPV6ADDR(homeaddr));
+	return;
+}
+
+static void mv_home_addr(void *arg)
+{
+	mm_segment_t oldfs;
+	int err = 0, new_if = 0, new_plen = 0;
+	struct list_head *lh, *next;
+	struct ifr_holder *ifrh;
+
+	DEBUG(DBG_INFO, "mipv6 move home address task");
+
+	oldfs = get_fs(); set_fs(KERNEL_DS);
+	spin_lock_bh(&ifrh_lock);
+	list_for_each_safe(lh, next, &ifrh_list) {
+		ifrh = list_entry(lh, struct ifr_holder, list);
+		/* need to inform that we are doing this inside kernel */
+		if (ifrh->old_ifi) {
+			new_if = ifrh->ifr.ifr6_ifindex;
+			ifrh->ifr.ifr6_ifindex = ifrh->old_ifi;
+			new_plen = ifrh->ifr.ifr6_prefixlen;
+			ifrh->ifr.ifr6_prefixlen = 128;
+			err = addrconf_del_ifaddr(&ifrh->ifr); 
+			ifrh->ifr.ifr6_prefixlen = new_plen;
+			ifrh->ifr.ifr6_ifindex = new_if;
+		}
+		if(!err) {
+			err = addrconf_add_ifaddr(&ifrh->ifr);
+		}
+		list_del(&ifrh->list);
+		kfree(ifrh);
+	}
+	spin_unlock_bh(&ifrh_lock);
+	set_fs(oldfs);
+
+	if (err < 0)
+		DEBUG(DBG_WARNING, "adding of home address to a new interface failed %d", err);
+	else
+		DEBUG(DBG_WARNING, "adding of home address to a new interface OK");
+}
+
+struct dhaad_halist {
+	struct list_head list;
+	struct in6_addr addr;
+	int retry;
+};
+
+/* clear all has from candidate list.  do this when a new dhaad reply
+ * is received. */
+int mipv6_mn_flush_ha_candidate(struct list_head *ha)
+{
+	struct list_head *p, *tmp;
+	struct dhaad_halist *e;
+
+	list_for_each_safe(p, tmp, ha) {
+		e = list_entry(p, struct dhaad_halist, list);
+		list_del(p);
+		kfree(e);
+		e = NULL;
+	}
+	return 0;
+}
+
+/* add new ha to candidates. only done when dhaad reply is received. */
+int mipv6_mn_add_ha_candidate(struct list_head *ha, struct in6_addr *addr)
+{
+	struct dhaad_halist *e;
+
+	e = kmalloc(sizeof(*e), GFP_ATOMIC);
+	memset(e, 0, sizeof(*e));
+	ipv6_addr_copy(&e->addr, addr);
+
+	list_add_tail(&e->list, ha);
+	return 0;
+}
+
+#define MAX_RETRIES_PER_HA 3
+
+/* get next ha candidate.  this is done when dhaad reply has been
+ * received and we want to register with the best available ha. */
+int mipv6_mn_get_ha_candidate(struct list_head *ha, struct in6_addr *addr)
+{
+	struct list_head *p;
+
+	list_for_each(p, ha) {
+		struct dhaad_halist *e;
+		e = list_entry(p, typeof(*e), list);
+		if (e->retry >= 0 && e->retry < MAX_RETRIES_PER_HA) {
+			ipv6_addr_copy(addr, &e->addr);
+			return 0;
+		}
+	}
+	return -1;
+}
+
+/* change candidate status.  if registration with ha fails, we
+ * increase retry for ha candidate.  if retry is >= 3 we set it to -1
+ * (failed), do get_ha_candidate() again */
+int mipv6_mn_try_ha_candidate(struct list_head *ha, struct in6_addr *addr)
+{
+	struct list_head *p;
+
+	list_for_each(p, ha) {
+		struct dhaad_halist *e;
+		e = list_entry(p, typeof(*e), list);
+		if (ipv6_addr_cmp(addr, &e->addr) == 0) {
+			if (e->retry >= MAX_RETRIES_PER_HA) e->retry = -1;
+			else if (e->retry >= 0) e->retry++;
+			return 0;
+		}
+	}
+	return -1;
+}
+
+/**
+ * mipv6_mn_get_bulifetime - Get lifetime for a binding update
+ * @home_addr: home address for BU 
+ * @coa: care-of address for BU
+ * @flags: flags used for BU 
+ *
+ * Returns maximum lifetime for BUs determined by the lifetime of
+ * care-of address and the lifetime of home address.
+ **/
+__u32 mipv6_mn_get_bulifetime(struct in6_addr *home_addr, struct in6_addr *coa,
+			      __u8 flags)
+{
+	
+	__u32 lifetime; 
+	
+	struct inet6_ifaddr * ifp_coa, *ifp_hoa;
+
+	ifp_hoa = ipv6_get_ifaddr(home_addr, NULL);
+	if(!ifp_hoa) {
+		DEBUG(DBG_ERROR, "home address missing");
+		return 0;
+	}
+	ifp_coa = ipv6_get_ifaddr(coa, NULL);
+	if (!ifp_coa) {
+		in6_ifa_put(ifp_hoa);
+		DEBUG(DBG_ERROR, "care-of address missing");
+		return 0;
+	}
+	if (flags & MIPV6_BU_F_HOME)
+		lifetime = HA_BU_DEF_LIFETIME;
+	else
+		lifetime = CN_BU_DEF_LIFETIME;
+
+	if (!(ifp_hoa->flags & IFA_F_PERMANENT)){
+		if (ifp_hoa->valid_lft)
+			lifetime = min_t(__u32, lifetime, ifp_hoa->valid_lft);
+		else
+			DEBUG(DBG_ERROR, "Zero lifetime for home address");
+	}
+	if (!(ifp_coa->flags & IFA_F_PERMANENT)) {
+		if(ifp_coa->valid_lft)
+			lifetime = min_t(__u32, lifetime, ifp_coa->valid_lft);
+		else
+			DEBUG(DBG_ERROR, 
+			      "Zero lifetime for care-of address");
+	}
+	in6_ifa_put(ifp_hoa);
+	in6_ifa_put(ifp_coa);
+	DEBUG(DBG_INFO, "Lifetime for binding is %ld", lifetime);
+	return lifetime;
+}
+
+static int 
+mipv6_mn_tnl_rcv_send_bu_hook(struct ipv6_tnl *t, struct sk_buff *skb)
+{
+	struct ipv6hdr *inner = (struct ipv6hdr *)skb->h.raw;
+	struct ipv6hdr *outer = skb->nh.ipv6h; 
+	struct mn_info *minfo = NULL;
+	struct inet6_skb_parm *opt;
+	__u32 lifetime;
+
+	DEBUG_FUNC();
+
+	if (!is_mipv6_tnl(t))
+		return IPV6_TNL_ACCEPT;
+
+	read_lock(&mn_info_lock);
+	minfo = mipv6_mninfo_get_by_home(&inner->daddr);
+
+	if (!minfo) {
+		DEBUG(DBG_WARNING, "MN info missing");
+		read_unlock(&mn_info_lock);
+		return IPV6_TNL_ACCEPT;
+	}
+	DEBUG(DBG_DATADUMP, "MIPV6 MN: Received a tunneled IPv6 packet"
+	      " to %x:%x:%x:%x:%x:%x:%x:%x,"
+	      " from %x:%x:%x:%x:%x:%x:%x:%x with\n tunnel header"
+	      "daddr: %x:%x:%x:%x:%x:%x:%x:%x,"
+	      "saddr: %x:%x:%x:%x:%x:%x:%x:%x", 
+	       NIPV6ADDR(&inner->daddr), NIPV6ADDR(&inner->saddr),
+	       NIPV6ADDR(&outer->daddr), NIPV6ADDR(&outer->saddr));
+
+	spin_lock(&minfo->lock);
+
+	/* We don't send bus in response to all tunneled packets */
+
+        if (!ipv6_addr_cmp(&minfo->ha, &inner->saddr)) {
+		spin_unlock(&minfo->lock);
+		read_unlock(&mn_info_lock);
+                DEBUG(DBG_ERROR, "HA BUG: Received a tunneled packet "
+		      "originally sent by home agent, not sending BU");
+		return IPV6_TNL_ACCEPT;
+        }
+	if (ipv6_addr_cmp(&minfo->ha, &outer->saddr)) {
+		spin_unlock(&minfo->lock);
+		read_unlock(&mn_info_lock);
+		DEBUG(DBG_WARNING, "MIPV6 MN: Received a tunneled IPv6 packet"
+		      " that was not tunneled by HA %x:%x:%x:%x:%x:%x:%x:%x,"
+		      " but by %x:%x:%x:%x:%x:%x:%x:%x", 
+		      NIPV6ADDR(&minfo->ha), NIPV6ADDR(&outer->saddr));
+		return IPV6_TNL_ACCEPT;
+        }
+	spin_unlock(&minfo->lock);
+	read_unlock(&mn_info_lock);
+
+	DEBUG(DBG_DATADUMP, "Sending BU to correspondent node");
+
+	if (inner->nexthdr != IPPROTO_DSTOPTS && inner->nexthdr != IPPROTO_MOBILITY) {
+		struct in6_addr coa;
+		lifetime = mipv6_mn_get_bulifetime(&inner->daddr,
+						   &outer->daddr, 0); 
+		if(lifetime && 
+		   !mipv6_get_care_of_address(&inner->daddr, &coa)) {
+			write_lock(&bul_lock);
+			mipv6_send_bu(&inner->daddr, &inner->saddr, &coa,
+				      CN_BU_DELAY, INITIAL_BINDACK_TIMEOUT,
+				      MAX_BINDACK_TIMEOUT , 1, 
+#ifdef CN_REQ_ACK
+				      MIPV6_BU_F_ACK, /* ack */
+#else
+				      0, /* no ack */
+#endif
+				      0, lifetime, NULL);
+			write_unlock(&bul_lock);
+		}
+	}
+	/* (Mis)use ipsec tunnel flag  */
+	DEBUG(DBG_DATADUMP, "setting rcv_tunnel flag in skb");
+	opt = (struct inet6_skb_parm *)skb->cb;
+	opt->mipv6_flags |= MIPV6_RCV_TUNNEL;
+	return IPV6_TNL_ACCEPT;
+}
+
+static struct ipv6_tnl_hook_ops mipv6_mn_tnl_rcv_send_bu_ops = {
+	{NULL, NULL}, 
+	IPV6_TNL_PRE_DECAP,
+	IPV6_TNL_PRI_FIRST,
+	mipv6_mn_tnl_rcv_send_bu_hook
+};
+
+static int
+mipv6_mn_tnl_xmit_stats_hook(struct ipv6_tnl *t, struct sk_buff *skb)
+{
+	DEBUG_FUNC();
+	if (is_mipv6_tnl(t))
+		MIPV6_INC_STATS(n_encapsulations);
+	return IPV6_TNL_ACCEPT;
+}
+
+static struct ipv6_tnl_hook_ops mipv6_mn_tnl_xmit_stats_ops = {
+	{NULL, NULL},
+	IPV6_TNL_PRE_ENCAP,
+	IPV6_TNL_PRI_LAST,
+	mipv6_mn_tnl_xmit_stats_hook
+};
+
+static int
+mipv6_mn_tnl_rcv_stats_hook(struct ipv6_tnl *t, struct sk_buff *skb)
+{
+	DEBUG_FUNC();	
+	if (is_mipv6_tnl(t))
+		MIPV6_INC_STATS(n_decapsulations);
+	return IPV6_TNL_ACCEPT;
+}
+
+static struct ipv6_tnl_hook_ops mipv6_mn_tnl_rcv_stats_ops = {
+	{NULL, NULL},
+	IPV6_TNL_PRE_DECAP,
+	IPV6_TNL_PRI_LAST,
+	mipv6_mn_tnl_rcv_stats_hook
+};
+
+void mipv6_check_tunneled_packet(struct sk_buff *skb)
+{
+	struct inet6_skb_parm *opt = (struct inet6_skb_parm *)skb->cb;
+	DEBUG_FUNC();
+	/* If tunnel flag was set */
+	if (opt->mipv6_flags & MIPV6_RCV_TUNNEL) {
+		struct in6_addr coa; 
+		__u32 lifetime;
+		mipv6_get_care_of_address(&skb->nh.ipv6h->daddr, &coa);
+		lifetime = mipv6_mn_get_bulifetime(&skb->nh.ipv6h->daddr,
+ 							 &coa, 0); 
+
+		DEBUG(DBG_WARNING, "packet to address %x:%x:%x:%x:%x:%x:%x:%x"
+		      "was tunneled. NOT Sending BU to CN" 
+		      "%x:%x:%x:%x:%x:%x:%x:%x", 
+		      NIPV6ADDR(&skb->nh.ipv6h->daddr),
+		      NIPV6ADDR(&skb->nh.ipv6h->saddr)); 
+		/* This should work also with home address option */
+		write_lock(&bul_lock);
+		mipv6_send_bu(&skb->nh.ipv6h->daddr, &skb->nh.ipv6h->saddr, 
+			      &coa, CN_BU_DELAY, INITIAL_BINDACK_TIMEOUT,
+			      MAX_BINDACK_TIMEOUT, 1, 
+#ifdef CN_REQ_ACK
+			      MIPV6_BU_F_ACK, /* ack */
+#else
+			      0, /* no ack */
+#endif
+			      64, lifetime, NULL);
+		write_unlock(&bul_lock);
+	}
+}
+int sched_mv_home_addr_task(struct mn_info *minfo, int plen_new, 
+			    int newif, int oldif)
+{
+	struct ifr_holder *ifrh = NULL;
+
+	ifrh = kmalloc(sizeof(*ifrh), GFP_ATOMIC);
+	if (ifrh == NULL) {
+		DEBUG(DBG_ERROR, "Out of memory");
+		return -1;
+	}
+	/* must queue task to avoid deadlock with rtnl */
+	ifrh->ifr.ifr6_ifindex = newif;
+	ifrh->ifr.ifr6_prefixlen = plen_new;
+	ipv6_addr_copy(&ifrh->ifr.ifr6_addr, &minfo->home_addr);
+	ifrh->old_ifi = oldif;
+	
+	spin_lock_bh(&ifrh_lock);
+	list_add_tail(&ifrh->list, &ifrh_list);
+	spin_unlock_bh(&ifrh_lock);
+	schedule_task(&mv_home_addr_task);
+
+	minfo->ifindex = newif;
+
+	return 0;
+}
+
+static void mn_ha_handoff(struct handoff *ho)
+{
+	struct list_head *lh;
+	struct mn_info *minfo;
+	
+	read_lock(&mn_info_lock);
+	list_for_each(lh, &mn_info_list) {
+		__u8 has_home_reg;
+		int ifindex;
+		struct in6_addr ha;
+		__u8 athome;
+		__u32 lifetime;
+		struct mipv6_bul_entry *entry = NULL;
+		
+		minfo = list_entry(lh, struct mn_info, list);
+		spin_lock(&minfo->lock);
+		has_home_reg = minfo->has_home_reg;
+		ifindex = minfo->ifindex;
+		ipv6_addr_copy(&ha, &minfo->ha);
+		
+		if (mipv6_prefix_compare(&ho->rtr_new.raddr, &minfo->home_addr,
+					 ho->rtr_new.pfix_len)) {
+			if (minfo->has_home_reg)
+				athome = minfo->is_at_home = MN_RETURNING_HOME;
+			else
+				athome = minfo->is_at_home = MN_AT_HOME;
+			spin_unlock(&minfo->lock);
+			
+			/* Cancel prefix solicitation */
+			mipv6_pfx_cancel_send(&ho->rtr_new.raddr, ifindex);
+			
+			/* Check if home address has been moved around */
+			if (ifindex != ho->rtr_new.ifindex) {
+				DEBUG(DBG_INFO, 
+				      "Moving home address back to "
+				      "the home interface");
+				sched_mv_home_addr_task(minfo, 
+							ho->rtr_new.pfix_len,
+							ho->rtr_new.ifindex, 
+							ifindex);
+			}
+			if (!has_home_reg)
+				continue;
+
+			lifetime = 0;
+		} else {
+			athome = minfo->is_at_home = MN_NOT_AT_HOME;
+			spin_unlock(&minfo->lock);
+			
+			if (!has_home_reg) {
+				init_home_registration(&minfo->home_addr, 
+						       &ho->rtr_new.CoA);
+				continue;
+			}
+			lifetime = mipv6_mn_get_bulifetime(&minfo->home_addr, 
+							   &ho->rtr_new.CoA,
+							   MIPV6_BU_F_HOME);
+			
+		}
+		write_lock(&bul_lock);
+		if (!(entry = mipv6_bul_get(&ha, &minfo->home_addr)) ||
+		    !(entry->flags & MIPV6_BU_F_HOME)) {
+			DEBUG(DBG_ERROR, 
+			      "Unable to find home registration for "
+			      "home address: %x:%x:%x:%x:%x:%x:%x:%x!\n",
+			      NIPV6ADDR(&minfo->home_addr));
+			write_unlock(&bul_lock);
+			continue;
+		}
+		DEBUG(DBG_INFO, "Sending home de ? %d registration for "
+		      "home address: %x:%x:%x:%x:%x:%x:%x:%x\n" 
+		      "to home agent %x:%x:%x:%x:%x:%x:%x:%x, "
+		      "with lifetime %ld, prefixlength %d", 
+		      (athome != MN_NOT_AT_HOME),  
+		      NIPV6ADDR(&entry->home_addr), 
+		      NIPV6ADDR(&entry->cn_addr), lifetime, entry->prefix);
+		mipv6_send_bu(&entry->home_addr, &entry->cn_addr, 
+			      &ho->rtr_new.CoA, HA_BU_DELAY, 
+			      INITIAL_BINDACK_TIMEOUT, MAX_BINDACK_TIMEOUT, 1, 
+			      entry->flags, entry->prefix, lifetime, NULL);
+		write_unlock(&bul_lock);
+
+	}
+	read_unlock(&mn_info_lock);
+}
+/**
+ * mn_cn_handoff - called for every bul entry to send BU to CN
+ * @rawentry: bul entry
+ * @args: handoff event
+ * @sortkey:
+ *
+ * Since MN can have many home addresses and home networks, every BUL
+ * entry needs to be checked
+ **/
+static int mn_cn_handoff(void *rawentry, void *args, unsigned long *sortkey)
+{
+	struct mipv6_bul_entry *entry = (struct mipv6_bul_entry *)rawentry;
+	struct handoff *ho = (struct handoff *)args;
+	DEBUG_FUNC();
+
+	/* Home registrations already handled by mn_ha_handoff */
+	if (!(entry->flags & MIPV6_BU_F_HOME)) {
+		__u32 lifetime;
+		if (mipv6_prefix_compare(&ho->rtr_new.raddr, 
+					 &entry->home_addr,
+					 ho->rtr_new.pfix_len)) {
+			lifetime = 0;
+		} else {
+			lifetime = mipv6_mn_get_bulifetime(&entry->home_addr, 
+							   &ho->rtr_new.CoA,
+							   entry->flags);
+		}
+		DEBUG(DBG_INFO, "Sending BU for home address: "
+		      "%x:%x:%x:%x:%x:%x:%x:%x \n" 
+		      "to CN: %x:%x:%x:%x:%x:%x:%x:%x, "
+		      "with lifetime %ld",   NIPV6ADDR(&entry->home_addr), 
+		      NIPV6ADDR(&entry->cn_addr), lifetime);
+		/* BUL is locked by mipv6_mobile_node_moved which calls us 
+		   through bul_iterate */
+		mipv6_send_bu(&entry->home_addr, &entry->cn_addr, 
+			      &ho->rtr_new.CoA, CN_BU_DELAY, 
+			      INITIAL_BINDACK_TIMEOUT, MAX_BINDACK_TIMEOUT, 1,
+			      entry->flags, entry->prefix, lifetime, 
+			      NULL);
+	}
+	return ITERATOR_CONT;
+}
+
+/**
+ * init_home_registration - start Home Registration process
+ * @home_addr: home address
+ * @coa: care-of address
+ *
+ * Checks whether we have a Home Agent address for this home address.
+ * If not starts Dynamic Home Agent Address Discovery.  Otherwise
+ * tries to register with home agent if not already registered.
+ **/
+int init_home_registration(struct in6_addr *home_addr, struct in6_addr *coa)
+{
+	struct mn_info *hinfo;
+	struct in6_addr ha;
+	__u8 man_conf;
+	int ifindex;
+	__u32 lifetime;
+	int mipv6_dad = 0;
+
+	DEBUG_FUNC();
+
+	read_lock_bh(&mn_info_lock);
+        if ((hinfo = mipv6_mninfo_get_by_home(home_addr)) == NULL) {
+                DEBUG(DBG_ERROR, "No mn_info found for address: "
+		      "%x:%x:%x:%x:%x:%x:%x:%x",
+		      NIPV6ADDR(home_addr));
+		read_unlock_bh(&mn_info_lock);
+                return -ENOENT;
+        }
+	spin_lock(&hinfo->lock);
+	if (mipv6_prefix_compare(&hinfo->home_addr, coa, hinfo->home_plen)) { 
+		spin_unlock(&hinfo->lock);
+		read_unlock_bh(&mn_info_lock);
+		DEBUG(DBG_INFO, "Adding home address, MN at home");
+		return 0;
+	}
+        if (ipv6_addr_any(&hinfo->ha)) {
+                int dhaad_id = mipv6_get_dhaad_id();
+                int home_plen = hinfo->home_plen;
+                hinfo->dhaad_id = dhaad_id;
+		spin_unlock(&hinfo->lock);
+                mipv6_icmpv6_send_dhaad_req(home_addr, home_plen, dhaad_id);
+		read_unlock_bh(&mn_info_lock);
+                DEBUG(DBG_INFO,
+		      "Home Agent address not set, initiating DHAAD");
+                return 0;
+        }
+        ipv6_addr_copy(&ha, &hinfo->ha);
+        man_conf = hinfo->man_conf;
+        ifindex = hinfo->ifindex;
+	spin_unlock(&hinfo->lock);
+	read_unlock_bh(&mn_info_lock);
+	
+	if (man_conf)
+		mipv6_pfx_add_ha(&ha, coa, ifindex);
+	
+	if (mipv6_bul_exists(&ha, home_addr)) {
+		DEBUG(DBG_INFO, "BU already sent to HA");
+		return 0;
+	}
+	lifetime = mipv6_mn_get_bulifetime(home_addr, coa, 
+					   MIPV6_BU_F_HOME | MIPV6_BU_F_ACK);
+	DEBUG(DBG_INFO, "Sending initial home registration for "
+	      "home address: %x:%x:%x:%x:%x:%x:%x:%x\n" 
+	      "to home agent %x:%x:%x:%x:%x:%x:%x:%x, "
+	      "with lifetime %ld, prefixlength %d",   
+	      NIPV6ADDR(home_addr), NIPV6ADDR(&ha), lifetime, 0);
+#ifndef MIPV6_NO_PROXY_DAD
+	mipv6_dad = MIPV6_BU_F_DAD;
+#endif
+	write_lock_bh(&bul_lock);
+	mipv6_send_bu(home_addr, &ha, coa, HA_BU_DELAY, 
+		      INITIAL_BINDACK_DAD_TIMEOUT, MAX_BINDACK_TIMEOUT, 1,
+		      MIPV6_BU_F_HOME | MIPV6_BU_F_ACK | mipv6_dad, 
+		      0, lifetime, NULL);
+	write_unlock_bh(&bul_lock);
+
+	return 0;
+}
+
+/**
+ * mipv6_mobile_node_moved - Send BUs to all HAs and CNs
+ * @ho: handoff structure contains the new and previous routers
+ *
+ * Event for handoff.  Sends BUs everyone on Binding Update List.
+ **/
+int mipv6_mobile_node_moved(struct handoff *ho)
+{
+#if 0
+	int bu_to_prev_router = 1;
+#endif
+	int dummy;
+
+	DEBUG_FUNC();
+
+	if (!mipv6_is_initialized)
+		return 0;
+
+	ma_ctl_upd_iface(ho->rtr_new.ifindex, 
+			 MA_IFACE_CURRENT | MA_IFACE_HAS_ROUTER, &dummy);
+
+	/* First send BU to HA, then to all other nodes that are on BU list */
+	mn_ha_handoff(ho);
+	write_lock(&bul_lock);
+	bul_iterate(mn_cn_handoff, ho);
+	write_unlock(&bul_lock);
+
+	mipv6_mn_prefix_route(&ho->rtr_new.raddr, ho->rtr_new.pfix_len, 0, 
+			      EXPIRE_INFINITE);
+#if 0	 
+	/* Add current care-of address to mn_info list, if current router acts 
+	   as a HA.*/ 
+
+	if (ho->rtr_new.flags & ND_RA_FLAG_HA && 
+	    ho->rtr_new.glob_addr && bu_to_prev_router) 
+		mipv6_mninfo_add(&ho->rtr_new.CoA, ho->rtr_new.pfix_len, 
+				 MN_AT_HOME, 0, &ho->rtr_new.raddr, 
+				 ho->rtr_new.pfix_len, ROUTER_BU_DEF_LIFETIME,
+				 0);
+				  
+#endif
+	return 0;		
+}
+
+/**
+ * mipv6_mn_send_home_na - send NA when returning home
+ * @haddr: home address to advertise
+ *
+ * After returning home, MN must advertise all its valid addresses in
+ * home link to all nodes.
+ **/
+void mipv6_mn_send_home_na(struct in6_addr *haddr)
+{
+	struct net_device *dev = NULL;
+	struct in6_addr mc_allnodes;
+	struct mn_info *hinfo = NULL;
+	struct in6_addr addr;
+ 
+	read_lock(&mn_info_lock);
+	hinfo = mipv6_mninfo_get_by_home(haddr);
+	if (!hinfo) {
+		read_unlock(&mn_info_lock);
+		return;
+	}
+	spin_lock(&hinfo->lock);
+	hinfo->is_at_home = MN_AT_HOME;
+	hinfo->has_home_reg = 0;
+	dev = dev_get_by_index(hinfo->ifindex);
+	spin_unlock(&hinfo->lock);
+	read_unlock(&mn_info_lock);
+	if (dev == NULL) {
+		DEBUG(DBG_ERROR, "Send home_na: device not found.");
+		return;
+	}
+	
+	ipv6_addr_all_nodes(&mc_allnodes);
+	if (ipv6_get_lladdr(dev, &addr) == 0)
+		ndisc_send_na(dev, NULL, &mc_allnodes, &addr, 0, 0, 1, 1);
+	ndisc_send_na(dev, NULL, &mc_allnodes, haddr, 0, 0, 1, 1);
+	dev_put(dev);
+}
+
+int mipv6_mn_use_hao(struct in6_addr *daddr, struct in6_addr *saddr)
+{
+	struct mipv6_bul_entry *entry;
+	int add_ha = 0;
+
+        if (mipv6_mn_is_home_addr(saddr)) {
+		read_lock_bh(&bul_lock);
+		if ((entry = mipv6_bul_get(daddr, saddr)) == NULL) {
+			read_unlock_bh(&bul_lock);
+			return add_ha;
+		}
+		add_ha = (!entry->rr || entry->rr->rr_state == RR_DONE || 
+			  entry->flags & MIPV6_BU_F_HOME);
+		read_unlock_bh(&bul_lock);
+	}
+	return add_ha;
+}
+
+static inline int 
+add_prefix_route(struct in6_addr *saddr, struct in6_addr *pfx, int plen,
+		 int ifindex, unsigned long expires)
+{
+	struct in6_rtmsg rtmsg;
+	memset(&rtmsg, 0, sizeof(rtmsg));
+	ipv6_addr_copy(&rtmsg.rtmsg_dst, pfx);
+	rtmsg.rtmsg_dst_len = plen;
+	ipv6_addr_copy(&rtmsg.rtmsg_src, saddr);
+	rtmsg.rtmsg_src_len = 128;
+	rtmsg.rtmsg_metric = IP6_RT_PRIO_MIPV6;
+	rtmsg.rtmsg_ifindex = ifindex;
+	rtmsg.rtmsg_info = expires;
+	rtmsg.rtmsg_flags = RTF_UP | RTF_EXPIRES;
+	rtmsg.rtmsg_type = RTMSG_NEWROUTE;
+	return ip6_route_add(&rtmsg);
+}
+
+
+void mipv6_mn_prefix_route(struct in6_addr *pfx, int plen, int delete, 
+			   unsigned long expires)
+{
+	struct list_head *lh;
+	
+	DEBUG_FUNC();
+
+	read_lock(&mn_info_lock);
+	
+	list_for_each(lh, &mn_info_list) {
+		struct mn_info *minfo; 
+		struct in6_addr ha, coa;
+		struct ipv6_tnl *t;
+		struct rt6_info *rt;
+
+		minfo = list_entry(lh, struct mn_info, list);	
+		if (mipv6_prefix_compare(&minfo->home_addr, pfx, plen)) {
+			continue;
+		}
+		if (mipv6_get_care_of_address(&minfo->home_addr, &coa) < 0) {
+			DEBUG(DBG_WARNING, 
+			      ": unable to get care-of address for "
+			      "%x:%x:%x:%x:%x:%x:%x:%x", 
+			      NIPV6ADDR(&minfo->home_addr));
+			continue;
+		}
+		spin_lock(&minfo->lock);
+		ipv6_addr_copy(&ha, &minfo->ha);
+		spin_unlock(&minfo->lock);
+
+		t = ipv6_ipv6_tnl_lookup(&ha, &coa);
+		
+		if (!is_mipv6_tnl(t)) {
+			DEBUG(DBG_WARNING, "MIPv6 tunnel not found!");
+			continue;
+		}
+		rt = rt6_lookup(pfx, &minfo->home_addr, t->dev->ifindex, 1);
+	
+		if (rt && !(rt->rt6i_flags & RTF_DEFAULT)) {  
+			if (rt->rt6i_flags & RTF_EXPIRES) {
+				if (delete) {
+					ip6_del_rt(rt);
+					rt = NULL;
+				} else {
+					rt->rt6i_expires = expires;
+				}
+			}
+		} else if (!delete) {
+			add_prefix_route(&minfo->home_addr, pfx, plen, 
+					 t->dev->ifindex, expires);
+		}
+		if (rt) {
+			dst_release(&rt->u.dst);
+		}
+	}
+	read_unlock(&mn_info_lock);
+}
+
+static int 
+mn_dev_event(struct notifier_block *nb, unsigned long event, void *ptr)
+{
+	struct net_device *dev = ptr;
+	struct list_head *lh;
+	struct mn_info *minfo;
+	int newif = 0, err =0;
+
+	/* here are probably the events we need to worry about */
+	switch (event) {
+	case NETDEV_UP:
+		DEBUG(DBG_DATADUMP, "New netdevice %s registered.", dev->name);
+		if ((dev->type != ARPHRD_LOOPBACK) &&
+		    (dev->type != ARPHRD_IPV6_IPV6_TUNNEL))
+			ma_ctl_add_iface(dev->ifindex);
+		break;
+	case NETDEV_GOING_DOWN:
+		DEBUG(DBG_DATADUMP, "Netdevice %s disappeared.", dev->name);
+		ma_ctl_upd_iface(dev->ifindex, MA_IFACE_NOT_PRESENT, &newif);
+		newif =  ma_ctl_get_preferred_if();
+		if (newif <= 0  || (newif == loopback_dev.ifindex)) {
+			DEBUG(DBG_WARNING, "Couldn't find a valid interface to add home address into");
+			err = -1;
+		}
+		else
+			DEBUG(DBG_INFO, "Netdevice %s was in use.  Switch to %d.",
+			       dev->name, newif);
+		/* 
+		 * Go through mn_info list and move all home addresses on the
+		 * netdev going down to a new device. This will make it 
+                 * practically impossible for the home address to return home,
+		 * but allow MN to retain its connections using the address.
+		 */
+
+		read_lock_bh(&mn_info_lock);
+		list_for_each(lh, &mn_info_list) {
+			minfo = list_entry(lh, struct mn_info, list);
+			spin_lock(&minfo->lock);
+			if (minfo->ifindex == dev->ifindex) {
+				if (err)
+					minfo->ifindex = 0;
+				else if (minfo->man_conf && 
+					 sched_mv_home_addr_task(minfo, 128, 
+								 newif, 
+								 0) < 0) {
+					spin_unlock(&minfo->lock);
+					read_unlock_bh(&mn_info_lock);
+					return NOTIFY_DONE;
+				}
+			}
+			spin_unlock(&minfo->lock);				
+		}
+		
+		read_unlock_bh(&mn_info_lock);
+	}
+	return NOTIFY_DONE;
+}
+
+struct notifier_block mipv6_mn_dev_notifier = {
+	mn_dev_event,
+	NULL,
+	0 /* check if using zero is ok */
+};
+
+static void deprecate_addr(struct mn_info *minfo)
+{
+	/*
+	 * Lookup address from IPv6 address list and set deprecated flag
+	 */
+	
+}
+
+int mipv6_mn_may_solicit_ha(struct in6_addr *target)
+{
+	struct list_head *lh;
+	struct mn_info *minfo; 
+	int ret = 0;
+
+	DEBUG_FUNC();
+
+	read_lock_bh(&mn_info_lock);
+	list_for_each(lh, &mn_info_list) {
+		minfo = list_entry(lh, struct mn_info, list);
+		spin_lock(&minfo->lock);
+		if (!ipv6_addr_cmp(&minfo->ha, target) && 
+		    (ret = (minfo->is_at_home == MN_RETURNING_HOME))) {
+			spin_unlock(&minfo->lock);
+			break;
+		}
+		spin_unlock(&minfo->lock);
+	}
+	read_unlock_bh(&mn_info_lock);
+	return ret;
+}
+
+int mipv6_mn_may_advertise(struct in6_addr *target, struct in6_addr *saddr)
+{
+	struct list_head *lh;
+	struct mn_info *minfo = NULL; 
+	int ret = 1;
+
+	DEBUG_FUNC();
+
+	read_lock(&mn_info_lock);
+
+	/* Only answer to a NS to the  home address from the HA when it is 
+	   returning home */
+
+	list_for_each(lh, &mn_info_list) {
+		minfo = list_entry(lh, struct mn_info, list);
+		spin_lock(&minfo->lock);
+		if (minfo->is_at_home == MN_RETURNING_HOME &&
+		    !ipv6_addr_cmp(&minfo->home_addr, target)) {
+			ret = !ipv6_addr_cmp(saddr, &minfo->ha);
+			spin_unlock(&minfo->lock);
+			break;
+		}
+		spin_unlock(&minfo->lock);
+	}
+	read_unlock(&mn_info_lock);
+
+	return ret;
+}
+
+/*
+ * Required because we can only modify addresses after the packet is
+ * constructed.  We otherwise mess with higher level protocol
+ * pseudoheaders. With strict protocol layering life would be SO much
+ * easier!  
+ */
+static unsigned int modify_xmit_addrs(unsigned int hooknum,
+				      struct sk_buff **pskb,
+				      const struct net_device *in,
+				      const struct net_device *out,
+				      int (*okfn) (struct sk_buff *))
+{
+	struct sk_buff *skb = *pskb;
+
+	DEBUG_FUNC();
+	
+	if (skb) {
+		struct ipv6hdr *hdr = skb->nh.ipv6h;
+		struct inet6_skb_parm *opt = (struct inet6_skb_parm *)skb->cb;
+		struct in6_addr coa;
+
+		if ((opt->mipv6_flags & MIPV6_SND_HAO) &&
+		    !mipv6_get_care_of_address(&hdr->saddr, &coa)) {
+			DEBUG(DBG_INFO, 
+			      "Replace source address with CoA and reroute");
+			ipv6_addr_copy(&hdr->saddr, &coa);
+			skb->nfcache |= NFC_ALTERED;
+		}
+	}
+	return NF_ACCEPT;
+}
+
+/* We set a netfilter hook so that we can modify outgoing packet's
+ * source addresses 
+ */
+struct nf_hook_ops addr_modify_hook_ops = {
+	{NULL, NULL},		/* List head, no predecessor, no successor */
+	modify_xmit_addrs,
+	PF_INET6,
+	NF_IP6_LOCAL_OUT,
+	NF_IP6_PRI_FIRST       	/* Should be of EXTREMELY high priority since we
+				 * do not want to mess with IPSec (possibly
+				 * implemented as packet filter)
+				 */
+};
+
+#define MN_INFO_LEN 77
+
+static int mn_proc_info(char *buffer, char **start, off_t offset,
+			int length)
+{
+	struct list_head *p;
+	struct mn_info *minfo;
+	int len = 0, skip = 0;
+
+	DEBUG_FUNC();
+
+	read_lock_bh(&mn_info_lock);
+	list_for_each(p, &mn_info_list) {
+		if (len < offset / MN_INFO_LEN) {
+			skip++;
+			continue;
+		}
+		if (len >= length)
+			break;
+		minfo = list_entry(p, struct mn_info, list);
+		spin_lock(&minfo->lock);
+		len += sprintf(buffer + len, "%02d %04x%04x%04x%04x%04x%04x%04x%04x %02x "
+			       "%04x%04x%04x%04x%04x%04x%04x%04x %d %d\n",
+			       minfo->ifindex, NIPV6ADDR(&minfo->home_addr),
+			       minfo->home_plen, NIPV6ADDR(&minfo->ha),
+			       minfo->is_at_home, minfo->has_home_reg);
+		spin_unlock(&minfo->lock);
+	}
+	read_unlock_bh(&mn_info_lock);
+
+	*start = buffer;
+	if (offset)
+		*start += offset % MN_INFO_LEN;
+
+	len -= offset % MN_INFO_LEN;
+
+	if (len > length)
+		len = length;
+	if (len < 0)
+		len = 0;
+	
+	return len;
+}
+
+int __init mipv6_mn_init(void)
+{
+	struct net_device *dev;
+
+	DEBUG_FUNC();
+
+	mipv6_bul_init(MIPV6_BUL_SIZE);
+	mipv6_initialize_mdetect();
+
+	INIT_TQUEUE(&mv_home_addr_task, mv_home_addr, NULL);
+
+	ma_ctl_init();
+	for (dev = dev_base; dev; dev = dev->next) {
+		if ((dev->flags & IFF_UP) && 
+		    (dev->type != ARPHRD_LOOPBACK) &&
+		    (dev->type != ARPHRD_IPV6_IPV6_TUNNEL)) {
+			ma_ctl_add_iface(dev->ifindex);
+		}
+	} 
+	DEBUG(DBG_INFO, "Multiaccess support initialized");
+
+	register_netdevice_notifier(&mipv6_mn_dev_notifier);
+
+	ipv6_ipv6_tnl_register_hook(&mipv6_mn_tnl_rcv_send_bu_ops);
+	ipv6_ipv6_tnl_register_hook(&mipv6_mn_tnl_xmit_stats_ops);
+	ipv6_ipv6_tnl_register_hook(&mipv6_mn_tnl_rcv_stats_ops);
+
+	MIPV6_SETCALL(mipv6_set_home, mipv6_mn_set_home);
+	MIPV6_SETCALL(mipv6_prefix_route, mipv6_mn_prefix_route);
+
+	/* COA to home transformation hook */
+	MIPV6_SETCALL(mipv6_get_home_address, mipv6_get_saddr_hook);
+	/* Actual HO, also deletes old routes after the addition of new ones 
+	   in ndisc */
+	MIPV6_SETCALL(mipv6_change_router, mipv6_change_router);
+
+	MIPV6_SETCALL(mipv6_mn_may_solicit_ha, mipv6_mn_may_solicit_ha);
+	MIPV6_SETCALL(mipv6_mn_may_advertise, mipv6_mn_may_advertise);
+
+	proc_net_create("mip6_mninfo", 0, mn_proc_info);
+	/* Set packet modification hook (source addresses) */
+	nf_register_hook(&addr_modify_hook_ops);
+
+	return 0;
+}
+
+void __exit mipv6_mn_exit(void)
+{
+	struct list_head *lh, *tmp;
+	struct mn_info *minfo;
+	DEBUG_FUNC();
+
+	nf_unregister_hook(&addr_modify_hook_ops);
+	proc_net_remove("mip6_mninfo");
+	mipv6_shutdown_mdetect();
+	ipv6_ipv6_tnl_unregister_hook(&mipv6_mn_tnl_rcv_stats_ops);
+	ipv6_ipv6_tnl_unregister_hook(&mipv6_mn_tnl_xmit_stats_ops);
+	ipv6_ipv6_tnl_unregister_hook(&mipv6_mn_tnl_rcv_send_bu_ops);
+	ma_ctl_clean();
+
+	unregister_netdevice_notifier(&mipv6_mn_dev_notifier);
+	write_lock_bh(&mn_info_lock);
+
+	list_for_each_safe(lh, tmp, &mn_info_list) {
+		minfo = list_entry(lh, struct mn_info, list);
+		if (minfo->is_at_home == MN_NOT_AT_HOME) 
+			deprecate_addr(minfo);
+		list_del(&minfo->list);
+		kfree(minfo);
+	}
+	write_unlock_bh(&mn_info_lock);
+	mipv6_bul_exit();
+	flush_scheduled_tasks();
+}
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/mn.h linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/mn.h
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/mn.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/mn.h	2003-05-18 11:33:53.000000000 +0200
@@ -0,0 +1,154 @@
+/*
+ *      Mobile-node header file
+ *
+ *      Authors:
+ *      Sami Kivisaari          <skivisaa@cc.hut.fi>
+ *
+ *      $Id: s.mn.h 1.48 02/12/19 16:14:47+02:00 antti@jon.mipl.mediapoli.com $
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef _MN_H
+#define _MN_H
+
+#include <linux/config.h>
+#include <linux/in6.h>
+#include <net/mipv6.h>
+
+#include "sortedlist.h"
+#include "mipv6_icmp.h"
+#include "prefix.h"
+#ifdef CONFIG_IPV6_MOBILITY_MN
+
+/* constants for sending of BUs*/
+#define HA_BU_DELAY 0 
+
+#define HA_BU_DEF_LIFETIME 10000
+#define CN_BU_DELAY 500 /* In case there is some data pckets to add the bu to */
+#define CN_BU_DEF_LIFETIME 420 /* Max lifetime for RR bindings from mipv6 draft v19 */  
+#define DUMB_CN_BU_LIFETIME 600 /* BUL entry lifetime in case of dumb CN */
+#define ROUTER_BU_DEF_LIFETIME 30 /* For packet forwarding from previous coa */
+
+#define ERROR_DEF_LIFETIME DUMB_CN_BU_LIFETIME
+
+//#define CN_REQ_ACK /* Request Acks from CN's */
+
+/*
+ * Global configuration flags
+ */
+extern int mipv6_is_mn;
+
+extern rwlock_t mn_info_lock;
+
+#define MN_NOT_AT_HOME 0
+#define MN_RETURNING_HOME 1
+#define MN_AT_HOME 2
+
+/*
+ * Mobile Node information record
+ */
+struct mn_info {
+	struct in6_addr home_addr;
+	struct in6_addr ha;
+	__u8 home_plen;
+	__u8 is_at_home;
+	__u8 has_home_reg;
+	__u8 man_conf;
+	int ifindex;
+	unsigned long home_addr_expires;
+	unsigned short dhaad_id;
+	struct list_head list;
+	spinlock_t lock;
+};
+
+/* prototypes for interface functions */
+int mipv6_mn_init(void);
+void mipv6_mn_exit(void);
+
+
+struct handoff;
+/* Interface to source address selection in IPv6 */
+void mipv6_get_saddr_hook(struct inet6_ifaddr *ifp,
+			  struct in6_addr *homeaddr);
+
+/* Interface to movement detection */
+int mipv6_mobile_node_moved(struct handoff *ho);
+
+void mipv6_mn_send_home_na(struct in6_addr *haddr);
+/* Init home reg. with coa */
+int init_home_registration(struct in6_addr *home_addr, struct in6_addr *coa);
+
+/* mn_info functions that require locking by caller */
+struct mn_info *mipv6_mninfo_get_by_home(struct in6_addr *haddr);
+
+struct mn_info *mipv6_mninfo_get_by_ha(struct in6_addr *home_agent);
+
+struct mn_info *mipv6_mninfo_get_by_id(unsigned short id);
+
+/* "safe" mn_info functions */
+void mipv6_mninfo_add(int ifindex, struct in6_addr *home_addr, int plen, 
+		      int isathome, unsigned long lifetime, struct in6_addr *ha, 
+		      int ha_plen, unsigned long ha_lifetime, int man_conf);
+
+int mipv6_mninfo_del(struct in6_addr *home_addr, int del_dyn_only);
+
+int mipv6_mn_is_at_home(struct in6_addr *addr);
+
+int mipv6_mn_is_home_addr(struct in6_addr *addr);
+
+__u32 mipv6_mn_get_bulifetime(struct in6_addr *home_addr, 
+			      struct in6_addr *coa, __u8 flags);
+
+int mipv6_mn_may_solicit_ha(struct in6_addr *target);
+
+int mipv6_mn_may_advertise(struct in6_addr *target, struct in6_addr *saddr);
+
+void
+mipv6_mn_prefix_route(struct in6_addr *pfx, int plen, int delete, 
+		      unsigned long expires);
+
+int mipv6_mn_use_hao(struct in6_addr *daddr, struct in6_addr *saddr);
+
+void mipv6_check_tunneled_packet(struct sk_buff *skb);
+/*
+ * This function is deprecated and they should not be used, but some
+ * parts still use them.  It only works for one home address.
+ */
+int mipv6_mn_get_homeaddr(struct in6_addr *home_addr);
+
+/**
+ * set_mn_pfx_list - manipulate pfx_list for MN when timer goes off
+ * @entry: pfx_list_entry that is due
+ */
+static inline void set_mn_pfx_list(struct pfx_list_entry *entry)
+{
+	extern struct list_head pfx_list;
+
+	mipv6_icmpv6_send(&entry->daddr, &entry->saddr, MIPV6_PREFIX_SOLICIT, 
+			  0, NULL, NULL, 0); /* entry->ifindex */
+
+	if (++entry->retries <= MAX_RTR_SOLICITATIONS)
+		mipv6_slist_push_first(&pfx_list, jiffies +
+				RTR_SOLICITATION_INTERVAL * HZ);
+	else
+		kfree(mipv6_slist_del_first(&pfx_list));
+}
+
+#else	/* CONFIG_IPV6_MOBILITY_MN */
+
+static __inline__ void set_mn_pfx_list(struct pfx_list_entry *entry)
+{ return; }
+static inline int mipv6_mn_use_hao(struct in6_addr *daddr, 
+				   struct in6_addr *saddr)
+{ return 0; }
+static inline void mipv6_check_tunneled_packet(struct sk_buff *skb)
+{ return; }
+
+#endif	/* CONFIG_IPV6_MOBILITY_MN */
+
+#endif /* _MN_H */
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/mobhdr.h linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/mobhdr.h
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/mobhdr.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/mobhdr.h	2003-05-18 11:33:53.000000000 +0200
@@ -0,0 +1,198 @@
+/*
+ *      Option sending and piggybacking module
+ *
+ *      Authors:
+ *      Niklas Kmpe                <nhkampe@cc.hut.fi>
+ *
+ *      $Id: s.mobhdr.h 1.42 02/11/25 12:40:01+02:00 vnuorval@amber.hut.mediapoli.com $
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef _MOBHDR_H
+#define _MOBHDR_H
+
+/*
+ * Status codes for mipv6_ack_rcvd()
+ */
+#define STATUS_UPDATE 0
+#define STATUS_REMOVE 1
+
+#define HOME_INIT_COOKIE	0x8
+#define CAREOF_INIT_COOKIE	0x10
+#define HOME_COOKIE		0x20
+#define CAREOF_COOKIE		0x40
+
+#define WAIT_HOTI_COTI		(HOME_INIT_COOKIE|CAREOF_INIT_COOKIE)
+#define WAIT_HOT_COT		(HOME_COOKIE|CAREOF_COOKIE)
+
+/* RR states for mipv6_send_upd_option() */
+#define RR_INIT			0x00
+#define RR_WAITH		0x01
+#define RR_WAITC		0x02
+#define RR_WAITHC		0x13
+#define RR_DONE			0x10
+
+/* Return value of mipv6_rr_needed() */
+#define NO_RR			0
+#define DO_RR			1
+#define RR_FOR_COA              2
+#define INPROGRESS_RR		3
+
+#define MH_UNKNOWN_CN 1
+#define MH_AUTH_FAILED 2
+#define MH_SEQUENCE_MISMATCH 3
+
+struct mipv6_bul_entry;
+
+/*
+ * sendopts module initialization & deinitialization
+ */
+int mipv6_mh_common_init(void);
+void mipv6_mh_common_exit(void);
+int mipv6_mh_mn_init(void);
+
+struct mipv6_mh_opt {
+	struct mipv6_mo_uid		*uid;
+	struct mipv6_mo_alt_coa		*alt_coa;
+	struct mipv6_mo_nonce_indices	*nonce_indices;
+	struct mipv6_mo_bauth_data	*auth_data;
+	struct mipv6_mo_br_advice	*br_advice;
+	int freelen;
+	int totlen;
+	u8 *next_free;
+	u8 data[0];
+};
+
+struct mobopt {
+	struct mipv6_mo_alt_coa		*alt_coa;
+	struct mipv6_mo_nonce_indices	*nonce_indices;
+	struct mipv6_mo_bauth_data	*auth_data;
+	struct mipv6_mo_br_advice	*br_advice;
+};
+
+int parse_mo_tlv(void *mos, int len, struct mobopt *opts);
+
+int mipv6_add_pad(u8 *data, int n);
+
+struct mipv6_mh_opt *alloc_mh_opts(int totlen);
+int append_mh_opt(struct mipv6_mh_opt *ops, u8 type, u8 len, void *data);
+
+struct mipv6_auth_parm {
+	struct in6_addr *coa;
+	struct in6_addr *cn_addr;
+	__u8 *k_bu;
+};
+
+int send_mh(struct in6_addr *daddr, 
+	    struct in6_addr *saddr, 
+	    u8 *msg, u8 msg_len, u8 msg_type,
+	    struct in6_addr *hao_addr,
+	    struct in6_addr *rth_addr,
+	    struct mipv6_mh_opt *ops,
+	    struct mipv6_auth_parm *parm);
+
+int mipv6_mh_register(int type, int (*func)(
+	struct in6_addr *, struct in6_addr *, 
+	struct in6_addr *, struct in6_addr *, struct mipv6_mh *));
+
+/*
+ * Send a binding request. Actual sending may be delayed up to
+ * maxdelay milliseconds. If 0, request is sent immediately.
+ * On a mobile node, use the mobile node's home address for saddr.
+ * Returns 0 on success, non-zero on failure.
+ */
+int mipv6_send_brr(struct in6_addr *saddr, struct in6_addr *daddr,
+	long maxdelay, struct mipv6_mh_opt *ops);
+
+/*
+ * Send a binding acknowledgement. Actual sending may be delayed up to
+ * maxdelay milliseconds. If 0, acknowledgement is sent immediately.
+ * On a mobile node, use the mobile node's home address for saddr.
+ * Returns 0 on success, non-zero on failure.
+ */
+int mipv6_send_ba(struct in6_addr *saddr, struct in6_addr *daddr,
+	struct in6_addr *coaddr, long maxdelay, __u8 status, 
+	__u16 sequence, __u32 lifetime, __u32 refresh, __u8 *k_bu);
+
+/*
+ * Send a binding update. Actual sending may be delayed up to maxdelay
+ * milliseconds. 'flags' may contain any of MIPV6_BU_F_ACK,
+ * MIPV6_BU_F_HOME, MIPV6_BU_F_ROUTER bitwise ORed. If MIPV6_BU_F_ACK is
+ * included retransmission will be attempted until the update has been
+ * acknowledged. Retransmission is done if no acknowledgement is received
+ * within 'initdelay' seconds. 'exp' specifies whether to use exponential
+ * backoff (exp != 0) or linear backoff (exp == 0). For exponential
+ * backoff the time to wait for an acknowledgement is doubled on each
+ * retransmission until a delay of 'maxackdelay', after which
+ * retransmission is no longer attempted. For linear backoff the delay
+ * is kept constant and 'maxackdelay' specifies the maximum number of
+ * retransmissions instead. If sub-options are present ops must contain
+ * all sub-options to be added.
+ * On a mobile node, use the mobile node's home address for saddr.
+ * Returns 0 on success, non-zero on failure.
+ */
+int mipv6_send_bu(struct in6_addr *saddr, struct in6_addr *daddr, 
+		  struct in6_addr *coa, long maxdelay, __u32 initdelay, 
+		  __u32 maxackdelay, __u8 exp, __u8 flags, __u8 plength, 
+		  __u32 lifetime, struct mipv6_mh_opt *ops);
+
+/** send_bu_msg - sends a Binding Update 
+ *
+ * @bulentry : Binding Update List entry with the information 
+ * for building a BU
+ *
+ * Function builds a BU msg based on the contents of a bul entry.
+ * Does not change the bul entry.
+ **/
+int send_bu_msg(struct mipv6_bul_entry *bulentry);
+
+int mipv6_send_be(struct in6_addr *saddr, struct in6_addr *daddr, 
+		  struct in6_addr *home, __u8 status);
+int mipv6_send_RR_bu(struct mipv6_bul_entry *bulentry);
+/*
+ * This function must be called to notify the module of the receipt of
+ * a binding acknowledgement so that it can cease retransmitting the
+ * option. The caller must have validated the acknowledgement before calling
+ * this function. 'status' can be either STATUS_UPDATE in which case the
+ * binding acknowledgement is assumed to be valid and the corresponding
+ * binding update list entry is updated, or STATUS_REMOVE in which case
+ * the corresponding binding update list entry is removed (this can be
+ * used upon receiving a negative acknowledgement).
+ * Returns 0 if a matching binding update has been sent or non-zero if
+ * not.
+ */
+int mipv6_ba_rcvd(int ifindex, struct in6_addr *cnaddr, 
+		  struct in6_addr *home_addr, __u16 sequence,
+		  __u32 lifetime, __u32 refresh, int status);
+
+/* RR related function to initialize RR */
+int mipv6_RR_start(struct in6_addr *home_addr, struct in6_addr *cn_addr,
+		   struct in6_addr *coa, struct mipv6_bul_entry *bulentry,
+		   long maxdelay, __u32 initdelay, __u32 maxackdelay,
+		   __u8 flags, __u8 plength, __u32 lifetime,
+		   struct mipv6_mh_opt *ops);
+
+/* RR related function to send home_test and careof_test messages */
+int mipv6_send_addr_test(struct in6_addr *daddr, struct in6_addr *saddr, 
+			 struct mipv6_mh_addr_ti *init, int type);
+
+/* RR related function to send home_test_init and careof_test_init messages */
+int mipv6_send_addr_test_init(struct in6_addr *daddr, struct in6_addr *saddr,
+			      u8 msg_type, __u8 *test_cookie);
+
+/* Binding Authentication Data Option routines */
+#define MAX_HASH_LENGTH 20
+#define MIPV6_RR_MAC_LENGTH 12
+
+int mipv6_auth_build(struct in6_addr *cn_addr, struct in6_addr *coa, 
+		     __u8 *opt, __u8 *aud_data, __u8 *k_bu);
+
+int mipv6_auth_check(struct in6_addr *cn_addr, struct in6_addr *coa, 
+		     __u8 *opt, __u8 optlen, struct mipv6_mo_bauth_data *aud, 
+		     __u8 *k_bu);
+#endif /* _MOBHDR_H */
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/mobhdr_common.c linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/mobhdr_common.c
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/mobhdr_common.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/mobhdr_common.c	2003-05-18 11:33:53.000000000 +0200
@@ -0,0 +1,1380 @@
+/*
+ *	Mobile IPv6 Mobility Header Common Functions
+ *
+ *	Authors:
+ *	Antti Tuominen <ajtuomin@tml.hut.fi>
+ *
+ *      $Id: s.mh_recv.c 1.159 02/10/16 15:01:29+03:00 antti@traci.mipl.mediapoli.com $
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/autoconf.h>
+#include <linux/types.h>
+#include <linux/in6.h>
+#include <linux/skbuff.h>
+#include <linux/ipsec.h>
+#include <linux/init.h>
+#include <net/ipv6.h>
+#include <net/ip6_route.h>
+#include <net/addrconf.h>
+#include <net/mipv6.h>
+#include <net/checksum.h>
+#include <net/protocol.h>
+
+#include "util.h"
+#include "stats.h"
+#include "debug.h"
+#include "mobhdr.h"
+#include "ha.h"
+#include "bcache.h"
+#include "bul.h"
+#include "rr_crypto.h"
+#include "exthdrs.h"
+#include "config.h"
+#include "mn.h"
+
+#define MIPV6_MH_MAX MIPV6_MH_BE
+struct mh_proto {
+	int	(*func) (struct in6_addr *, struct in6_addr *, 
+			 struct in6_addr *, struct in6_addr *, 
+			 struct mipv6_mh *);
+};
+
+static struct mh_proto mh_rcv[MIPV6_MH_MAX];
+
+int mipv6_mh_register(int type, int (*func)(
+	struct in6_addr *, struct in6_addr *, 
+	struct in6_addr *, struct in6_addr *, struct mipv6_mh *))
+{
+	if (mh_rcv[type].func != NULL)
+		return -1;
+
+	mh_rcv[type].func = func;
+
+	return 0;
+}
+
+struct socket *mipv6_mh_socket = NULL;
+
+/* TODO: Fix fragmentation */
+static int dstopts_getfrag(
+	const void *data, struct in6_addr *addr,
+	char *buff, unsigned int offset, unsigned int len)
+{
+	memcpy(buff, data + offset, len);
+	return 0;
+}
+
+struct mipv6_mh_opt *alloc_mh_opts(int totlen)
+{
+	struct mipv6_mh_opt *ops;
+
+	ops = kmalloc(sizeof(*ops) + totlen, GFP_ATOMIC);
+	if (ops == NULL)
+		return NULL;
+
+	memset(ops, 0, sizeof(*ops));
+	ops->next_free = ops->data;
+	ops->freelen = totlen;
+
+	return ops;
+}
+
+int append_mh_opt(struct mipv6_mh_opt *ops, u8 type, u8 len, void *data)
+{
+	struct mipv6_mo *mo;
+
+	if (ops->next_free == NULL) {
+		DEBUG(DBG_ERROR, "No free room for option");
+		return -ENOMEM;
+	}
+	if (ops->freelen < len + 2) {
+		DEBUG(DBG_ERROR, "No free room for option");
+		return -ENOMEM;
+	}
+	else {
+		ops->freelen -= (len + 2);
+		ops->totlen += (len + 2);
+	}
+
+	mo = (struct mipv6_mo *)ops->next_free;
+	mo->type = type;
+	mo->length = len;
+
+	switch (type) {
+	case MIPV6_OPT_ALTERNATE_COA:
+		ops->alt_coa = (struct mipv6_mo_alt_coa *)mo;
+		ipv6_addr_copy(&ops->alt_coa->addr, (struct in6_addr *)data);
+		break;
+	case MIPV6_OPT_NONCE_INDICES:
+		DEBUG(DBG_INFO, "Added nonce indices pointer");
+		ops->nonce_indices = (struct mipv6_mo_nonce_indices *)mo;
+		ops->nonce_indices->home_nonce_i = *(__u16 *)data;
+		ops->nonce_indices->careof_nonce_i = *((__u16 *)data + 1);
+		break;
+	case MIPV6_OPT_AUTH_DATA:
+		DEBUG(DBG_INFO, "Added opt auth_data pointer");
+		ops->auth_data = (struct mipv6_mo_bauth_data *)mo;
+		break;
+	case MIPV6_OPT_BIND_REFRESH_ADVICE:
+		ops->br_advice = (struct mipv6_mo_br_advice *)mo;
+		ops->br_advice->refresh_interval = htons(*(u16 *)data);
+		break;
+	default:
+		DEBUG(DBG_ERROR, "Unknow option type");
+		break;
+	}
+	memcpy(ops->next_free, mo, len);
+
+	if (ops->freelen == 0)
+		ops->next_free = NULL;
+	else
+		ops->next_free += (len + 2);
+
+	return 0;
+}
+
+int mipv6_add_pad(u8 *data, int n)
+{
+	struct mipv6_mo_padn *padn;
+
+	if (n <= 0) return 0;
+	if (n == 1) {
+		*data = MIPV6_OPT_PAD1;
+		return 1;
+	}
+	padn = (struct mipv6_mo_padn *)data;
+	padn->type = MIPV6_OPT_PADN;
+	padn->length = n - 2;
+	memset(padn->data, 0, n - 2);
+	return n;
+}
+
+/*
+ *   Calculates required padding before given mobility option.
+ */
+static int option_pad(__u8 type, int offset)
+{
+	switch (type) {
+	case MIPV6_OPT_PAD1:			/* no pad */
+	case MIPV6_OPT_PADN:
+		return 0;
+
+	case MIPV6_OPT_ALTERNATE_COA:		/* 8n + 6 */
+		return (6 - (offset)) & 7;
+
+	case MIPV6_OPT_AUTH_DATA:		/* 8n + 2 */
+		return (2 - (offset)) & 7;
+
+	case MIPV6_OPT_BIND_REFRESH_ADVICE:	/* 2n     */
+	case MIPV6_OPT_NONCE_INDICES:
+		return (offset) & 1;
+	default:
+		DEBUG(DBG_ERROR, "invalid option type 0x%x", type);
+		return 0;
+	}
+}
+
+int prepare_mh_opts(struct mipv6_mh *mh, int msg_len, struct mipv6_mh_opt *ops)
+{
+	u8 *nextopt = (u8 *)(mh + 1) + msg_len;
+	u8 *first = nextopt;
+	int offset = msg_len, pad = 0;
+
+	if (ops == NULL) {
+		first = nextopt = NULL;
+		return -1;
+	}
+
+	if (ops->alt_coa) {
+		pad = option_pad(MIPV6_OPT_ALTERNATE_COA, offset);
+		nextopt += mipv6_add_pad(nextopt, pad);
+		memcpy(nextopt, ops->alt_coa, sizeof(struct mipv6_mo_alt_coa));
+		nextopt += sizeof(struct mipv6_mo_alt_coa);
+		offset = pad + sizeof(struct mipv6_mo_alt_coa);
+	}
+
+	if (ops->br_advice) {
+		pad = option_pad(MIPV6_OPT_BIND_REFRESH_ADVICE, offset);
+		nextopt += mipv6_add_pad(nextopt, pad);
+		memcpy(nextopt, ops->br_advice, sizeof(struct mipv6_mo_br_advice));
+		nextopt += sizeof(struct mipv6_mo_br_advice);
+		offset = pad + sizeof(struct mipv6_mo_br_advice);
+	}
+
+	if (ops->nonce_indices) {
+		pad = option_pad(MIPV6_OPT_NONCE_INDICES, offset);
+		nextopt += mipv6_add_pad(nextopt, pad);
+		memcpy(nextopt, ops->nonce_indices, sizeof(struct mipv6_mo_nonce_indices));
+		nextopt += sizeof(struct mipv6_mo_nonce_indices);
+		offset = pad + sizeof(struct mipv6_mo_nonce_indices);
+	}
+
+	if (ops->auth_data) {
+		pad = option_pad(MIPV6_OPT_AUTH_DATA, offset);
+		nextopt += mipv6_add_pad(nextopt, 
+					 8 - ((nextopt + 2 + ops->auth_data->length  - (u8 *)mh) & 7)); 
+		memcpy(nextopt, ops->auth_data, ops->auth_data->length + 2);
+		nextopt += ops->auth_data->length + 2;
+	}
+	first = nextopt = NULL;
+
+	return 0;
+}
+
+int calculate_mh_opts(struct mipv6_mh_opt *ops, int mh_len)
+{
+	int offset = mh_len;
+	
+	if (ops == NULL)
+		return 0;
+
+	if (ops->alt_coa)
+		offset += sizeof(struct mipv6_mo_alt_coa)
+			+ option_pad(MIPV6_OPT_ALTERNATE_COA, offset);
+
+	if (ops->br_advice)
+		offset += sizeof(struct mipv6_mo_br_advice)
+			+ option_pad(MIPV6_OPT_BIND_REFRESH_ADVICE, offset);
+
+	if (ops->nonce_indices)
+		offset += sizeof(struct mipv6_mo_nonce_indices)
+			+ option_pad(MIPV6_OPT_NONCE_INDICES, offset);
+
+	if (ops->auth_data) /* 8 - totlen & 7 */
+		offset += 8 - ((offset + mh_len + ops->auth_data->length + 2) & 7) + ops->auth_data->length + 2;
+
+	return offset - mh_len;
+}
+
+static inline int mh_may_use_hao(u8 type, struct in6_addr *daddr,
+				 struct in6_addr *saddr)
+{
+	if (type == MIPV6_MH_BU || type == MIPV6_MH_HOTI ||
+	    type == MIPV6_MH_COTI)
+		return 0;
+	return mipv6_mn_use_hao(daddr, saddr);
+}
+
+static inline int mh_may_use_rth(u8 type)
+{
+	if (type == MIPV6_MH_BA || type == MIPV6_MH_HOT)
+		return 0;
+	return 1;
+}
+
+/**
+ * send_mh - builds and sends a MH msg
+ *
+ * @daddr : destination address for packet
+ * @saddr : source address for packet
+ * @msg : MH type specific data
+ * @msg_type : type of MH
+ * @hoa_opt : home address for home address option
+ *
+ * Builds MH, appends the type specific msg data to the header and
+ * sends the packet with a home address option, if a home address was
+ * given. Returns 0, if everything succeeded and a negative error code
+ * otherwise.
+ **/
+int send_mh(struct in6_addr *daddr, 
+	    struct in6_addr *saddr, 
+	    u8 *msg,
+	    u8 msg_len,
+	    u8 msg_type,
+	    struct in6_addr *hao_addr,
+	    struct in6_addr *rth_addr,
+	    struct mipv6_mh_opt *ops,
+	    struct mipv6_auth_parm *parm)
+{
+	struct flowi fl;
+	struct mipv6_mh *mh; 
+	struct sock *sk = mipv6_mh_socket->sk;
+	struct ipv6_txoptions *txopt = NULL;
+	int tot_len = sizeof(struct mipv6_mh) + msg_len;
+	int padded_len = 0, txopt_len = 0;
+	struct mipv6_bcache_entry bc_entry;
+
+	DEBUG_FUNC();
+	/* Add length of options */
+	tot_len += calculate_mh_opts(ops, tot_len);
+	/* Needs to be a multiple of 8 octets */
+	padded_len = (tot_len & 7) ? tot_len + (8 - (tot_len & 7)) : tot_len;
+
+	mh = sock_kmalloc(sk, padded_len, GFP_ATOMIC);
+	if (!mh) {
+		DEBUG(DBG_ERROR, "memory allocation failed");
+		return -ENOMEM;
+	}
+
+	if (hao_addr || mh_may_use_hao(msg_type, daddr, saddr))
+		txopt_len += sizeof(struct mipv6_dstopt_homeaddr) + 6;
+	if (rth_addr)
+		txopt_len += sizeof(struct rt2_hdr);
+	if (mh_may_use_rth(msg_type) && rth_addr == NULL) {
+		if (mipv6_bcache_get(daddr, saddr, &bc_entry) == 0) {
+			rth_addr = &bc_entry.coa;
+			txopt_len += sizeof(struct rt2_hdr);
+		}
+	}
+
+	memset(&fl, 0, sizeof(fl)); 
+	fl.proto = IPPROTO_MOBILITY;
+	fl.fl6_dst = daddr;
+	fl.fl6_src = saddr;
+	fl.fl6_flowlabel = 0;
+	fl.oif = sk->bound_dev_if;
+
+	if (txopt_len > 0) {
+		__u8 *opt_ptr;
+		txopt_len += sizeof(*txopt);
+		txopt = sock_kmalloc(sk, txopt_len, GFP_ATOMIC);
+		if (txopt == NULL) {
+			DEBUG(DBG_ERROR, "No socket space left");
+			sock_kfree_s(sk, mh, padded_len);
+			return -ENOMEM;
+		}
+		memset(txopt, 0, txopt_len);
+		txopt->tot_len = txopt_len;
+		opt_ptr = (__u8 *) (txopt + 1);
+		if (hao_addr || mh_may_use_hao(msg_type, daddr, saddr)) {
+			int holen = sizeof(struct mipv6_dstopt_homeaddr) + 6;
+			txopt->dst1opt = (struct ipv6_opt_hdr *) opt_ptr;
+			txopt->opt_flen += holen;
+			opt_ptr += holen;
+			mipv6_append_dst1opts(txopt->dst1opt, saddr, 
+					      NULL, holen);
+			txopt->mipv6_flags = MIPV6_SND_HAO;
+		}
+		if (rth_addr) {
+			int rtlen = sizeof(struct rt2_hdr);
+			txopt->srcrt2 = (struct ipv6_rt_hdr *) opt_ptr;
+			txopt->opt_nflen += rtlen;
+			opt_ptr += rtlen;
+			mipv6_append_rt2hdr(txopt->srcrt2, rth_addr);
+		}
+	}
+
+	/* Fill in the fields of MH */
+	mh->payload = NEXTHDR_NONE;
+	mh->length = (padded_len >> 3) - 1;	/* Units of 8 octets - 1 */
+	mh->type = msg_type;
+	mh->reserved = 0;
+	mh->checksum = 0;
+
+	memcpy(mh->data, msg, msg_len);
+	prepare_mh_opts(mh, msg_len, ops);
+	mipv6_add_pad((u8 *)mh + tot_len, padded_len - tot_len);
+	
+	if (parm && parm->k_bu && ops && ops->auth_data) {
+		/* Calculate the position of the authorization data before adding checksum*/
+		mipv6_auth_build(parm->cn_addr, parm->coa, (__u8 *)mh, 
+				 (__u8 *)mh + padded_len - MIPV6_RR_MAC_LENGTH, parm->k_bu);
+	}
+	/* Calculate the MH checksum */
+	mh->checksum = csum_ipv6_magic(fl.fl6_src, fl.fl6_dst, 
+				       padded_len, IPPROTO_MOBILITY,
+				       csum_partial((char *)mh, padded_len, 0));
+	ip6_build_xmit(sk, dstopts_getfrag, mh, &fl, padded_len, txopt, 255,
+		       MSG_DONTWAIT);
+	/* dst cache must be cleared so RR messages can be routed through 
+	   different interfaces */
+	sk_dst_reset(sk);
+
+	if (txopt_len)
+		sock_kfree_s(sk, txopt, txopt_len);
+	sock_kfree_s(sk, mh, padded_len);
+	return 0;
+}
+
+/**
+ * mipv6_send_brr - send a Binding Refresh Request 
+ * @saddr: source address for BRR
+ * @daddr: destination address for BRR
+ * @maxdelay: maximum milliseconds before option is sent
+ * @ops: mobility options
+ *
+ * Sends a binding request.  Actual sending may be delayed up to
+ * @maxdelay milliseconds.  If 0, request is sent immediately.  On a
+ * mobile node, use the mobile node's home address for @saddr.
+ * Returns 0 on success, negative on failure.
+ **/
+int mipv6_send_brr(struct in6_addr *saddr,
+	struct in6_addr *daddr,	long maxdelay, 
+	struct mipv6_mh_opt *ops)
+{
+	struct mipv6_mh_brr br;
+
+	memset(&br, 0, sizeof(br));
+	/* We don't need to  explicitly add a RH to brr, since it will be 
+	 * included automatically, if a binding exists 
+	 */
+	MIPV6_INC_STATS(n_brr_sent);
+	return send_mh(daddr, saddr, (u8 *)&br, sizeof(br),  MIPV6_MH_BRR,
+		       NULL, NULL, ops, NULL);
+}
+
+/**
+ * mipv6_send_ba - send a Binding Acknowledgement 
+ * @saddr: source address for BA
+ * @daddr: destination address for BA 
+ * @coaddr: care-of address of MN
+ * @maxdelay: maximun milliseconds before option is sent
+ * @status: status field value
+ * @sequence: sequence number from BU
+ * @lifetime: granted lifetime for binding in seconds
+ * @refresh: refresh timeout
+ * @ops: mobility options
+ *
+ * Sends a binding acknowledgement.  
+ * Returns 0 on success, negative on failure.
+ **/
+int mipv6_send_ba(struct in6_addr *saddr, struct in6_addr *daddr, 
+		  struct in6_addr *coaddr, long maxdelay, u8 status, 
+		  u16 sequence, u32 lifetime, u32 refresh, u8 *k_bu)
+{
+	struct mipv6_mh_ba ba;
+	struct mipv6_auth_parm parm;
+	struct mipv6_mh_opt *ops = NULL; 
+	int ops_len = 0;
+
+	memset(&ba, 0, sizeof(ba));
+	
+	ba.status = status;
+	ba.sequence = htons(sequence);
+	ba.lifetime = htons(lifetime) >> 2;
+	
+	DEBUG(DBG_INFO, "sending a status %d BA %s authenticator to MN \n"
+	      "%x:%x:%x:%x:%x:%x:%x:%x  at care of address \n" 
+	      "%x:%x:%x:%x:%x:%x:%x:%x : with lifetime %d",
+	      status, k_bu ? "with" : "without", 
+	      NIPV6ADDR(daddr), NIPV6ADDR(coaddr), lifetime);
+
+	if (status < 128) {
+		MIPV6_INC_STATS(n_ba_sent);
+	} else {
+		MIPV6_INC_STATS(n_ban_sent);
+	}
+
+	memset(&parm, 0, sizeof(parm));
+	parm.coa = coaddr;
+	parm.cn_addr = saddr;
+
+	if (k_bu) {
+		ops_len += sizeof(struct mipv6_mo_bauth_data) + 
+			MIPV6_RR_MAC_LENGTH;
+		parm.k_bu = k_bu;
+	}
+	/* Other options (if any) should materialize right about here.
+	 * Since MIPV6_OPT_BR_ADVICE is the only other option possible
+	 * here (currently) and it is only defined for Home Agent, we
+	 * could easily make it into a configurable parameter. */
+	if (ops_len) {
+		ops = alloc_mh_opts(ops_len);
+		if (ops == NULL) {
+			DEBUG(DBG_WARNING, "Out of memory");
+			return -ENOMEM;
+		}
+		if (k_bu) {
+			if (append_mh_opt(ops, MIPV6_OPT_AUTH_DATA,
+					  MIPV6_RR_MAC_LENGTH, NULL) < 0) {
+				DEBUG(DBG_WARNING, "Adding BAD failed");
+				if (ops)
+					kfree(ops);
+				return -ENOMEM;
+			}
+		}
+	}
+
+	send_mh(daddr, saddr, (u8 *)&ba, sizeof(ba), MIPV6_MH_BA, 
+		NULL, coaddr, ops, &parm);
+
+	if (ops)
+		kfree(ops);
+
+	return 0;
+}
+
+/**
+ * mipv6_send_be - send a Binding Error message
+ * @saddr: source address for BE
+ * @daddr: destination address for BE
+ * @home: Home Address in offending packet (if any)
+ *
+ * Sends a binding error.  Actual sending may be delayed up to
+ * @maxdelay milliseconds.  If 0, request is sent immediately.  On a
+ * mobile node, use the mobile node's home address for @saddr.
+ * Returns 0 on success, negative on failure.
+ **/
+int mipv6_send_be(struct in6_addr *saddr, struct in6_addr *daddr, 
+		  struct in6_addr *home, __u8 status)
+{
+	struct sock *sk = mipv6_mh_socket->sk;
+	struct mipv6_mh_be *be;
+	struct mipv6_mh_opt *ops = NULL;
+	int be_len = sizeof(struct mipv6_mh_be);
+	int ret;
+
+	/* Future: add options, if there are such */
+	be = sock_kmalloc(sk, be_len, GFP_ATOMIC);
+	if (!be) {
+		DEBUG(DBG_ERROR, "Sending of BE failed: Out of memory");
+		return -ENOMEM;
+	}
+	memset(be, 0, sizeof(*be));
+	be->status = status;
+	if (home)
+		ipv6_addr_copy(&be->home_addr, home);
+
+	ret = send_mh(daddr, saddr, (u8 *)be, be_len,  MIPV6_MH_BE,
+		      NULL, NULL, ops, NULL);
+	if (!ret) 
+		MIPV6_INC_STATS(n_be_sent);
+	sock_kfree_s(sk, be, be_len);
+
+	return ret;
+}
+
+/**
+ * mipv6_send_addr_test_init - send a HoTI or CoTI message
+ * @saddr: source address for H/CoTI
+ * @daddr: destination address for H/CoTI
+ * @msg_type: Identifies whether HoTI or CoTI
+ * @test_cookie: the HoT or CoT cookie
+ *
+ * The message will be retransmitted till we get a HoT or CoT message, since 
+ * our caller (mipv6_RR_start) has entered this message in the BUL with
+ * exponential backoff retramission set.
+ */
+int mipv6_send_addr_test_init(struct in6_addr *saddr,
+	       struct in6_addr *daddr,
+	       u8 msg_type,
+	       u8 *test_cookie)
+{
+	struct mipv6_mh_addr_ti ti;
+	struct mipv6_mh_opt *ops = NULL;
+
+	/* Set reserved and copy the cookie from address test init msg */
+	ti.reserved = 0;
+	memcpy(ti.test_cookie, test_cookie, MIPV6_RR_COOKIE_LENGTH);
+
+	return send_mh(daddr, saddr, (u8 *)&ti, sizeof(ti), msg_type, 
+		       NULL, NULL, ops, NULL);
+}
+
+/**
+ * mipv6_send_addr_test - send a HoT or CoT message
+ * @saddr: source address
+ * @daddr: destination address
+ * @init: HoTI or CoTI message
+ * @type: HoT or CoT message
+ *
+ * Send a reply to HoTI or CoTI message. 
+ **/
+int mipv6_send_addr_test(struct in6_addr *saddr,
+	       struct in6_addr *daddr,
+	       struct mipv6_mh_addr_ti *init,
+	       int type)
+{
+	u_int8_t			*addr_cookie = NULL;
+	struct mipv6_mh_addr_test       addr_test;      
+	struct mipv6_rr_nonce		*nonce;
+	struct mipv6_mh_opt *ops = NULL;
+
+	DEBUG_FUNC();
+
+	if ((nonce = mipv6_rr_get_new_nonce())== NULL) {
+		DEBUG(DBG_WARNING, "Nonce creation failed");
+		return 0;
+	} 
+	if (mipv6_rr_cookie_create(daddr, &addr_cookie, nonce->index)) {
+		DEBUG(DBG_WARNING, "No cookie");
+		return 0;
+	}
+	
+	addr_test.nonce_index = nonce->index;
+	memcpy(addr_test.test_cookie, init->test_cookie,
+			MIPV6_RR_COOKIE_LENGTH);
+	memcpy(addr_test.addr_cookie, addr_cookie,
+			MIPV6_RR_COOKIE_LENGTH);
+
+	/* No options defined */
+	send_mh(daddr, saddr, (u8 *)&addr_test, sizeof(addr_test), type,
+		NULL, NULL, ops, NULL);
+	
+	return 1;
+}
+
+extern int mipv6_dad_start(
+	struct inet6_ifaddr *ifp, int ifindex,
+	struct in6_addr *saddr, struct in6_addr *daddr,
+	struct in6_addr *haddr, struct in6_addr *coa,
+	__u32 ba_lifetime, int plength, __u16 sequence,
+	int single);
+
+/*
+ * Lifetime checks. ifp->valid_lft >= ifp->prefered_lft always (see addrconf.c)
+ * Returned value is in seconds.
+ */
+
+static __u32 get_min_lifetime(struct inet6_ifaddr *ifp, __u32 lifetime)
+{
+	__u32 rem_lifetime = 0;
+	unsigned long now = jiffies;
+
+	if (ifp->valid_lft == 0) {
+		rem_lifetime = lifetime;
+	} else {
+		__u32 valid_lft_left =
+		    ifp->valid_lft - ((now - ifp->tstamp) / HZ);
+		rem_lifetime =
+		    min_t(unsigned long, valid_lft_left, lifetime);
+	}
+
+	return rem_lifetime;
+}
+
+#define MAX_LIFETIME 1000
+
+/**
+ * mipv6_lifetime_check - check maximum lifetime is not exceeded
+ * @lifetime: lifetime to check
+ *
+ * Checks @lifetime does not exceed %MAX_LIFETIME.  Returns @lifetime
+ * if not exceeded, otherwise returns %MAX_LIFETIME.
+ **/
+int mipv6_lifetime_check(int lifetime)
+{
+	return (lifetime > MAX_LIFETIME) ? MAX_LIFETIME : lifetime;
+}
+
+
+/* Generic routine handling finish of BU processing */
+void mipv6_bu_finish(struct inet6_ifaddr *ifp, __u8 ba_status,
+		     __u32 ba_lifetime, __u32 ba_refresh,
+		     __u32 maxdelay, int plength, __u16 sequence,
+		     struct in6_addr *saddr, struct in6_addr *daddr,
+		     struct in6_addr *haddr, struct in6_addr *coa,
+		     int ifindex, int single, __u8 *k_bu)
+{
+	struct in6_addr *reply_addr;
+	int err;
+
+	if (ba_status >= REASON_UNSPECIFIED) {
+		/* DAD failed */
+		reply_addr = saddr;
+		goto out;
+	}
+
+	reply_addr = haddr;
+	ba_lifetime = get_min_lifetime(ifp, ba_lifetime);
+	ba_lifetime = mipv6_lifetime_check(ba_lifetime);
+
+	if ((err = mipv6_bcache_add(ifindex, daddr, haddr, coa, 
+				    ba_lifetime, plength, sequence, 
+				    single, HOME_REGISTRATION)) != 0 ) {
+		if (err == -ENOMEDIUM) {
+			if (ifp)
+				in6_ifa_put(ifp);
+			return;
+		}
+		DEBUG(DBG_WARNING, "home reg failed.");
+
+		ba_status = INSUFFICIENT_RESOURCES;
+		reply_addr = saddr;
+	} else {
+		DEBUG(DBG_INFO, "home reg succeeded.");
+		/*
+		 * refresh MAY be lesser than the lifetime since the cache is
+		 * not crash-proof. Set refresh to 80% of lifetime value.  
+		 */
+		ba_refresh = ba_lifetime * 4 / 5;
+	}
+
+	DEBUG(DBG_DATADUMP, "home_addr: %x:%x:%x:%x:%x:%x:%x:%x",
+	      NIPV6ADDR(haddr));
+	DEBUG(DBG_DATADUMP, "coa: %x:%x:%x:%x:%x:%x:%x:%x",
+	      NIPV6ADDR(coa));
+	DEBUG(DBG_DATADUMP, "lifet:%d, plen:%d, seq:%d",
+	      ba_lifetime, plength, sequence);
+      out:
+	if (ifp)
+		in6_ifa_put(ifp);
+
+	DEBUG(DBG_INFO, "sending ack (code=%d)", ba_status);
+
+	mipv6_send_ba(daddr, haddr, coa, maxdelay, ba_status,
+		      sequence, ba_lifetime, ba_refresh, k_bu);
+}
+
+void mipv6_bu_add_cache(int ifindex, struct in6_addr *daddr,
+			struct in6_addr *haddr, struct in6_addr *coa, 
+			__u32 lifetime, int plength, __u16 sequence, 
+			int single, int ack, __u32 ba_lifetime, 
+			__u32 ba_refresh, __u8 *k_bu)
+{
+	__u8 ba_status = SUCCESS;
+
+	/* Not "home registration", use 0 as plength */
+	plength = 0;
+	if (mipv6_bcache_add(ifindex, daddr, haddr, coa, lifetime,
+			     plength, sequence, single,
+			     CACHE_ENTRY) != 0) {
+		DEBUG(DBG_ERROR, "binding failed.");
+		ba_status = INSUFFICIENT_RESOURCES;
+	} else
+		DEBUG(DBG_INFO, "binding succeeded");
+
+	DEBUG(DBG_DATADUMP, "home_addr: %x:%x:%x:%x:%x:%x:%x:%x",
+	      NIPV6ADDR(haddr));
+	DEBUG(DBG_DATADUMP, "coa: %x:%x:%x:%x:%x:%x:%x:%x",
+	      NIPV6ADDR(coa));
+	DEBUG(DBG_DATADUMP, "lifet: %d, plen: %d, seq: %d",
+	      lifetime, plength, sequence);
+	if (ack) {
+		DEBUG(DBG_INFO, "sending ack (code=%d)",
+		      ba_status);
+		mipv6_send_ba(daddr, haddr, coa, 0,
+			      ba_status, sequence,
+			      ba_lifetime, ba_refresh, k_bu);
+	}
+}
+
+/*
+ * performs the actual processing of a binding update the purpose
+ * of which is to add a binding.  
+ */
+static inline void mipv6_bu_add(int ifindex, struct in6_addr *daddr, 
+				struct in6_addr *haddr, struct in6_addr *coa, 
+				int ack, int home, int single, int dad, 
+				int lladdr, int plength, __u16 sequence, 
+				__u32 lifetime, __u8 *k_bu)
+{
+	__u32 ba_lifetime = lifetime;
+	__u32 ba_refresh = lifetime;
+
+
+	DEBUG_FUNC();
+
+	if (home == 0) {
+		mipv6_bu_add_cache(ifindex, daddr, haddr, coa, lifetime,
+				   plength, sequence, single, ack, ba_lifetime,
+				   ba_refresh, k_bu);
+	} else {
+		mipv6_bu_add_home(ifindex, haddr, daddr, haddr, coa, lifetime,
+				  plength, sequence, single, ack, ba_lifetime,
+				  ba_refresh, dad, lladdr, k_bu);
+	}
+}
+
+/*
+ * only called by mipv6_dstopt_process_bu. could well be inlined.
+ *
+ * performs the actual processing of a binding update the purpose
+ * of which is to delete a binding.
+ *
+ */
+static void mipv6_bu_delete(struct in6_addr *daddr,
+			    struct in6_addr *haddr, struct in6_addr *coa,
+			    int ack, int home, int single, int plength,
+			    __u16 sequence, __u32 lifetime, __u8 *k_bu)
+{
+	__u8 ba_status = SUCCESS;
+	__u32 ba_lifetime = 0;
+	__u32 ba_refresh = 0;
+	__u32 maxdelay = 0;
+	int need_ack = ack;
+
+	DEBUG_FUNC();
+
+	if (home == 0) {
+		/* Care-of Address entry deletion request */
+
+		if (mipv6_bcache_exists(haddr, daddr) == CACHE_ENTRY) {
+			if (mipv6_bcache_delete(haddr, daddr, CACHE_ENTRY) != 0)
+				DEBUG(DBG_ERROR, "delete failed.");
+			else
+				DEBUG(DBG_INFO, "delete succeeded.");
+
+			DEBUG(DBG_DATADUMP, "home_addr: %x:%x:%x:%x:%x:%x:%x:%x",
+			      NIPV6ADDR(haddr));
+			DEBUG(DBG_DATADUMP, "coa: %x:%x:%x:%x:%x:%x:%x:%x",
+			      NIPV6ADDR(coa));
+			DEBUG(DBG_DATADUMP, "lifet:%d, plen:%d, seq:%d",
+			      lifetime, plength, sequence);
+		} else {
+			DEBUG(DBG_WARNING, "entry is not in cache");
+			ba_status = REASON_UNSPECIFIED;
+		}
+
+	}
+
+	mipv6_bcache_delete_wrapper(haddr, daddr, coa, &ba_lifetime,
+			&ba_refresh, &need_ack, &ba_status, lifetime,
+			plength, sequence, home);
+
+	if (need_ack) {
+		mipv6_send_ba(daddr, haddr, coa, maxdelay,
+			      ba_status, sequence, ba_lifetime,
+			      ba_refresh, k_bu);
+	}
+}
+
+/*
+ *
+ * Mobility Header Message handlers
+ *
+ */
+
+/**
+ * parse_mo_tlv - Parse TLV-encoded Mobility Options
+ * @mos: pointer to Mobility Options
+ * @len: total length of options
+ * @opts: structure to store option pointers
+ *
+ * Parses Mobility Options passed in @mos.  Stores pointers in @opts
+ * to all valid mobility options found in @mos.  Unknown options and
+ * padding (%MIPV6_OPT_PAD1 and %MIPV6_OPT_PADN) is ignored and
+ * skipped.
+ **/
+int parse_mo_tlv(void *mos, int len, struct mobopt *opts)
+{
+	struct mipv6_mo *curr = (struct mipv6_mo *)mos;
+	int left = len;
+
+	while (left > 0) {
+		int optlen = 0;
+		if (curr->type == MIPV6_OPT_PAD1)
+			optlen = 1;
+		else
+			optlen = 2 + curr->length;
+
+		if (optlen > left)
+			goto bad;
+
+		switch (curr->type) {
+		case MIPV6_OPT_PAD1:
+			DEBUG(DBG_DATADUMP, "MIPV6_OPT_PAD1 at %x", curr);
+			break;
+		case MIPV6_OPT_PADN:
+			DEBUG(DBG_DATADUMP, "MIPV6_OPT_PADN at %x", curr);
+			break;
+		case MIPV6_OPT_ALTERNATE_COA:
+			DEBUG(DBG_DATADUMP, "MIPV6_OPT_ACOA at %x", curr);
+			opts->alt_coa = (struct mipv6_mo_alt_coa *)curr;
+			break;
+		case MIPV6_OPT_NONCE_INDICES:
+			DEBUG(DBG_DATADUMP, "MIPV6_OPT_NONCE_INDICES at %x", curr);
+			opts->nonce_indices = 
+				(struct mipv6_mo_nonce_indices *)curr;
+			break;
+		case MIPV6_OPT_AUTH_DATA:
+			DEBUG(DBG_DATADUMP, "MIPV6_OPT_AUTH_DATA at %x", curr);
+			opts->auth_data = (struct mipv6_mo_bauth_data *)curr;
+			break;
+		case MIPV6_OPT_BIND_REFRESH_ADVICE:
+			DEBUG(DBG_DATADUMP, "MIPV6_OPT_BIND_REFRESH_ADVICE at %x", curr);
+			opts->br_advice = (struct mipv6_mo_br_advice *)curr;
+			break;
+		default:
+			DEBUG(DBG_INFO, "MO Unknown option type %d at %x, ignoring.",
+			       curr->type, curr);
+			/* unknown mobility option, ignore and skip */
+		}
+
+		(u8 *)curr += optlen;
+		left -= optlen;
+	}
+
+	if (left == 0)
+		return 0;
+ bad:
+	return -1;
+}
+
+static int mipv6_handle_mh_HC_testinit(struct in6_addr *cn,
+				       struct in6_addr *unused,
+				       struct in6_addr *saddr,
+				       struct in6_addr *hao,
+				       struct mipv6_mh *mh)
+{
+	struct mipv6_mh_addr_ti *ti = (struct mipv6_mh_addr_ti *)mh->data;
+	int type = mh->type;
+
+	DEBUG_FUNC();
+
+	if (mh->length < 1) {
+		DEBUG(DBG_INFO, "Mobility Header length less than H/C TestInit");
+		return -1;
+	}
+
+	if (hao) {
+		DEBUG(DBG_INFO, "H/C TestInit has HAO, dropped.");
+		return -1;
+	}
+
+	if (type == MIPV6_MH_HOTI)
+		return mipv6_send_addr_test(cn, saddr, ti, MIPV6_MH_HOT);
+	else if (type == MIPV6_MH_COTI)
+		return mipv6_send_addr_test(cn, saddr, ti, MIPV6_MH_COT);
+	else 
+		return -1; /* Impossible to get here */
+}
+
+/**
+ * mipv6_handle_mh_bu - Binding Update handler
+ * @src: care-of address of sender
+ * @dst: destination of this packet
+ * @haddr: home address of sender
+ * @mh: pointer to the beginning of the Mobility Header
+ *
+ * Handles Binding Update. Packet and offset to option are passed.
+ * Returns 0 on success, otherwise negative.
+ **/
+static int mipv6_handle_mh_bu(struct in6_addr *dst,
+			      struct in6_addr *unused,
+			      struct in6_addr *haddr, 
+			      struct in6_addr *coaddr,
+			      struct mipv6_mh *mh)
+{
+	struct mipv6_mh_bu *bu = (struct mipv6_mh_bu *)mh->data;
+	int msg_len = (mh->length << 3) + 2;
+	int auth = 0;
+	int dereg; /* Is this deregistration? */ 
+
+	struct mipv6_bcache_entry bc_entry;
+	struct in6_addr *coa;
+	__u8 *key_bu = NULL; /* RR BU authentication key */
+	__u8 ack, home, single, dad, ll, plength = 0;
+	__u16 sequence;
+	__u32 lifetime;
+	__u32 ba_refresh = 0;
+	__u32 maxdelay = 0;
+	
+	if (msg_len < (sizeof(*bu))) {
+		DEBUG(DBG_INFO, "Mobility Header length less than BU");
+		MIPV6_INC_STATS(n_bu_drop.invalid);
+		return -1;
+	}
+
+	/* If HAO not present, CoA == HAddr */
+	if (coaddr == NULL)
+		coa = haddr;
+	else
+		coa = coaddr;
+
+	ack = !!(bu->flags & MIPV6_BU_F_ACK);
+	home = !!(bu->flags & MIPV6_BU_F_HOME);
+	single = !!(bu->flags & MIPV6_BU_F_SINGLE);
+	dad = !!(bu->flags & MIPV6_BU_F_DAD);
+	ll = !!(bu->flags & MIPV6_BU_F_LLADDR);
+
+
+	sequence = ntohs(bu->sequence);
+	if (bu->lifetime == 0xffff)
+		lifetime = 0xffffffff;
+	else
+		lifetime = ntohs(bu->lifetime) << 2;
+
+	dereg = (ipv6_addr_cmp(haddr, coa) == 0 || lifetime == 0);
+
+	if ((mipv6_bcache_get(haddr, dst, &bc_entry) == 0)
+	    && !modGT65536(sequence, bc_entry.seq)) {
+		DEBUG(DBG_INFO,
+		      "Sequence number mismatch. Sending BA SEQUENCE_NUMBER_OUT_OF_WINDOW");
+		mipv6_send_ba(dst, haddr, coa, maxdelay,
+			      SEQUENCE_NUMBER_OUT_OF_WINDOW,
+			      bc_entry.seq, lifetime,
+			      ba_refresh, key_bu);
+		goto out;
+	}
+
+	if (msg_len > sizeof(*bu)) {
+		struct mobopt opts;
+		memset(&opts, 0, sizeof(opts));
+		if (parse_mo_tlv(bu + 1, msg_len - sizeof(*bu), &opts) < 0)
+			return -1;
+		/*
+		 * MIPV6_OPT_AUTH_DATA, MIPV6_OPT_NONCE_INDICES, 
+		 * MIPV6_OPT_ALT_COA
+		 */
+		if (opts.alt_coa) {
+			coa = &opts.alt_coa->addr;
+			dereg = (ipv6_addr_cmp(haddr, coa) == 0 || lifetime == 0);
+		}
+		if (opts.auth_data && opts.nonce_indices && !home) { 
+			u8 ba_status = 0;
+			u8 *h_ckie  = NULL, *c_ckie = NULL; /* Home and care-of cookies */
+		
+			if (mipv6_rr_cookie_create(
+				    haddr, &h_ckie, opts.nonce_indices->home_nonce_i) < 0) {
+				DEBUG(DBG_WARNING,
+				      "mipv6_rr_cookie_create failed for home cookie");
+				ba_status = EXPIRED_HOME_NONCE_INDEX;
+			}
+			/* Don't create the care-of cookie, if MN deregisters */
+			if (!dereg && mipv6_rr_cookie_create(
+				    coa, &c_ckie,
+				    opts.nonce_indices->careof_nonce_i) < 0) {
+				DEBUG(DBG_WARNING,
+				      "mipv6_rr_cookie_create failed for coa cookie");
+				if (ba_status == 0)
+					ba_status = EXPIRED_CAREOF_NONCE_INDEX;
+				else
+					ba_status = EXPIRED_NONCES;
+			}
+			if (ba_status == 0) {
+				if (dereg)
+					key_bu = mipv6_rr_key_calc(h_ckie, NULL);
+				else
+					key_bu = mipv6_rr_key_calc(h_ckie, c_ckie);	       
+				mh->checksum = 0;/* TODO: Don't mangle the packet */
+				if (key_bu && mipv6_auth_check(
+					dst, coa, (__u8 *)mh,  msg_len + sizeof(*mh), opts.auth_data, key_bu) == 0) {
+					DEBUG(DBG_INFO, "mipv6_auth_check OK for BU");
+					auth = 1;
+				} else {
+					DEBUG(DBG_WARNING, 
+					      "BU Authentication failed");
+				}
+			}
+			if (h_ckie)
+				kfree(h_ckie);
+			if (c_ckie)
+				kfree(c_ckie);
+			if (ba_status != 0) {
+				MIPV6_INC_STATS(n_bu_drop.auth);
+				mipv6_send_ba(dst, haddr, coa, maxdelay,
+					      ba_status, sequence, 0, 0, NULL);
+				goto out;
+			}
+		}
+
+	}
+	/* Require authorization option for RO, home reg is protected by IPsec */
+	if (!home && !auth) {
+		MIPV6_INC_STATS(n_bu_drop.auth);
+		if (key_bu)
+			kfree(key_bu);
+		return MH_AUTH_FAILED;
+	}
+	mipv6_adjust_lifetime(&lifetime);
+
+	if (!dereg) {
+		int ifindex;
+		struct rt6_info *rt;
+
+		DEBUG(DBG_INFO, "calling bu_add.");
+		if ((rt = rt6_lookup(haddr, dst, 0, 0)) != NULL) {
+			ifindex = rt->rt6i_dev->ifindex;
+			dst_release(&rt->u.dst);
+		} else {
+			/*
+			 * Can't process the BU since the right interface is 
+			 * not found.
+			 */
+			DEBUG(DBG_WARNING, "No route entry found for handling "
+			      "a BU request, (using 0 as index)");
+			ifindex = 0;
+		}
+		mipv6_bu_add(ifindex, dst, haddr, 
+			     coa, ack, home, single, dad, ll, plength, 
+			     sequence, lifetime, key_bu);
+	} else {
+		DEBUG(DBG_INFO, "calling bu_delete.");
+		mipv6_bu_delete(dst, haddr, coa, ack, home,
+				single, plength, sequence, lifetime, key_bu);
+	}
+ out:
+	MIPV6_INC_STATS(n_bu_rcvd);
+	if (key_bu)
+		kfree(key_bu);
+	return 0;
+}
+
+/*
+ * these print the contents of several mobility headers.
+ */
+
+static inline void dump_bu(struct mipv6_mh_bu *bu)
+{
+	if (bu->flags & MIPV6_BU_F_ACK)
+		DEBUG(DBG_DATADUMP, " Binding ack requested.");
+	if (bu->flags & MIPV6_BU_F_HOME)
+		DEBUG(DBG_DATADUMP, " Home registration bit is set.");
+	if (bu->flags & MIPV6_BU_F_SINGLE)
+		DEBUG(DBG_DATADUMP, " Single Address bit is set.");
+	if (bu->flags & MIPV6_BU_F_DAD)
+		DEBUG(DBG_DATADUMP, " DAD bit is set.");
+	if (bu->flags & MIPV6_BU_F_LLADDR)
+		DEBUG(DBG_DATADUMP, " Link-local Address bit is set.");
+	DEBUG(DBG_DATADUMP, "Sequence number: %d", bu->sequence);
+	DEBUG(DBG_DATADUMP, "Lifetime: %d", ntohs(bu->lifetime) << 2);
+}
+
+static inline void dump_ba(struct mipv6_mh_ba *ba)
+{
+	DEBUG(DBG_DATADUMP, "Status: %d", ba->status);
+	DEBUG(DBG_DATADUMP, "Sequence number: %d", ntohs(ba->sequence));
+	DEBUG(DBG_DATADUMP, "Lifetime: %d", ntohs(ba->lifetime) << 2);
+}
+
+static inline void dump_be(struct mipv6_mh_be *be)
+{
+	DEBUG(DBG_DATADUMP, "Status: %d", be->status);
+}
+
+void dump_mh(struct mipv6_mh *mh)
+{
+	int len = 0, length;
+	int msg_len = (mh->length << 3) + 2;
+	struct mobopt ops;
+
+	length = mh->length;
+
+	switch (mh->type) {
+	case MIPV6_MH_HOTI:
+		DEBUG(DBG_DATADUMP, "Home Test Init (HoTI)"
+		      " Message (%d)", mh->type);
+		DEBUG(DBG_DATADUMP, " Message Length: %d", length);
+		len = sizeof(struct mipv6_mh_addr_ti);
+		break;
+	case MIPV6_MH_COTI:
+		DEBUG(DBG_DATADUMP, "Care-of Test Init (CoTI)"
+		      " Message (%d)", mh->type);
+		DEBUG(DBG_DATADUMP, " Message Length: %d", length);
+		len = sizeof(struct mipv6_mh_addr_ti);
+		break;
+	case MIPV6_MH_HOT:
+		DEBUG(DBG_DATADUMP, "Home Test (HoT)"
+		      " Message (%d)", mh->type);
+		DEBUG(DBG_DATADUMP, " Message Length: %d", length);
+		len = sizeof(struct mipv6_mh_addr_test);
+		break;
+	case MIPV6_MH_COT:
+		DEBUG(DBG_DATADUMP, "Care-of Test (CoT)"
+		      " Message (%d)", mh->type);
+		DEBUG(DBG_DATADUMP, " Message Length: %d", length);
+		len = sizeof(struct mipv6_mh_addr_test);
+		break;
+	case MIPV6_MH_BU:
+		DEBUG(DBG_DATADUMP, "Binding Update (BU)"
+		      " Message (%d)", mh->type);
+		DEBUG(DBG_DATADUMP, " Message Length: %d", length);
+		dump_bu((struct mipv6_mh_bu *)mh->data);
+		len = sizeof(struct mipv6_mh_bu);
+		break;
+	case MIPV6_MH_BA:
+		DEBUG(DBG_DATADUMP, "Binding Acknowledgement (BA)"
+		      " Message (%d)", mh->type);
+		DEBUG(DBG_DATADUMP, " Message Length: %d", length);
+		dump_ba((struct mipv6_mh_ba *)mh->data);
+		len = sizeof(struct mipv6_mh_ba);
+		break;
+	case MIPV6_MH_BRR:
+		DEBUG(DBG_DATADUMP, "Binding Refresh Request (BRR)"
+		      " Message (%d)", mh->type);
+		DEBUG(DBG_DATADUMP, " Message Length: %d", length);
+		len = sizeof(struct mipv6_mh_brr);
+		break;
+	case MIPV6_MH_BE:
+		DEBUG(DBG_DATADUMP, "Binding Error (BE)"
+		      " Message (%d)", mh->type);
+		DEBUG(DBG_DATADUMP, " Message Length: %d", length);
+		len = sizeof(struct mipv6_mh_be);
+		break;
+	}
+
+	memset(&ops, 0, sizeof(ops));
+	if (msg_len > len && parse_mo_tlv((u8 *)mh->data + len, msg_len - len, &ops) <0)
+			return;
+
+	if (ops.alt_coa) {
+		DEBUG(DBG_DATADUMP, "MO Alternate Care-of Address %x:%x:%x:%x:%x:%x:%x:%x",
+		      NIPV6ADDR(&ops.alt_coa->addr));
+	}
+	if (ops.nonce_indices) {
+		DEBUG(DBG_DATADUMP, "MO Nonce Indices HI %d CI %d", 
+		      ntohs(ops.nonce_indices->home_nonce_i), 
+		      ntohs(ops.nonce_indices->careof_nonce_i));
+	} 
+	if (ops.auth_data) {
+		DEBUG(DBG_DATADUMP, "MO Binding Authentication Data");
+	}
+	if (ops.br_advice) {
+		DEBUG(DBG_DATADUMP, "MO Binding Refresh Advice %d", 
+		      ntohs(ops.br_advice->refresh_interval));
+	}
+}
+
+static int mipv6_mh_rcv(struct sk_buff *skb)
+{
+	struct inet6_skb_parm *opt = (struct inet6_skb_parm *)skb->cb;
+	struct mipv6_mh *mh;
+	struct in6_addr *lhome, *fhome, *lcoa = NULL, *fcoa = NULL;
+	int len = ((skb->h.raw[1] + 1)<<3);
+	int ret = 0;
+
+	fhome = &skb->nh.ipv6h->saddr;
+	lhome = &skb->nh.ipv6h->daddr;
+
+	if (opt->hao != 0) {
+		fcoa = (struct in6_addr *)((u8 *)skb->nh.raw + opt->hao);
+	}
+
+	if (opt->srcrt2 != 0) {
+		struct rt2_hdr *rt2;
+		rt2 = (struct rt2_hdr *)((u8 *)skb->nh.raw + opt->srcrt2);
+		lcoa = &rt2->addr;
+	}
+
+	/* Verify checksum is correct */
+	if (skb->ip_summed == CHECKSUM_HW) {
+		skb->ip_summed = CHECKSUM_UNNECESSARY;
+		if (csum_ipv6_magic(fhome, lhome, skb->len, IPPROTO_MOBILITY,
+				    skb->csum)) {
+			if (net_ratelimit())
+				printk(KERN_WARNING "MIPv6 MH hw checksum failed\n");
+			skb->ip_summed = CHECKSUM_NONE;
+		}
+	}
+	if (skb->ip_summed == CHECKSUM_NONE) {
+		if (csum_ipv6_magic(fhome, lhome, skb->len, IPPROTO_MOBILITY,
+				    skb_checksum(skb, 0, skb->len, 0))) {
+			printk(KERN_WARNING "MIPv6 MH checksum failed\n");
+			goto bad;
+		}
+	}
+
+	if (!pskb_may_pull(skb, (skb->h.raw-skb->data) + sizeof(*mh)) ||
+	    !pskb_may_pull(skb, (skb->h.raw-skb->data) + len)) {
+		DEBUG(DBG_INFO, "MIPv6 MH invalid length");
+		kfree_skb(skb);
+		return 0;
+	}
+
+	mh = (struct mipv6_mh *) skb->h.raw;
+
+	/* Verify there are no more headers after the MH */
+	if (mh->payload != NEXTHDR_NONE) {
+		DEBUG(DBG_INFO, "MIPv6 MH error");
+		goto bad;
+	}
+
+	if (mh->type > MIPV6_MH_MAX) {
+		/* send binding error */
+		printk("Invalid mobility header type (%d)\n", mh->type);
+		mipv6_send_be(lhome, fcoa ? fcoa : fhome, fcoa ? fhome : NULL, 
+			      MIPV6_BE_UNKNOWN_MH_TYPE);
+		goto bad;
+	}
+	if (mh_rcv[mh->type].func != NULL) {
+		ret = mh_rcv[mh->type].func(lhome, lcoa, fhome, fcoa, mh);
+	} else {
+		DEBUG(DBG_INFO, "No handler for MH Type %d", mh->type);
+		goto bad;
+	}
+
+	kfree_skb(skb);
+	return 0;
+
+bad:
+	MIPV6_INC_STATS(n_mh_in_error);
+	kfree_skb(skb);
+	return 0;
+
+}
+
+#if LINUX_VERSION_CODE >= 0x2052a
+struct inet6_protocol mipv6_mh_protocol =
+{
+	mipv6_mh_rcv,		/* handler		*/
+	NULL			/* error control	*/
+};
+#else
+struct inet6_protocol mipv6_mh_protocol = 
+{
+	mipv6_mh_rcv,		/* handler		*/
+	NULL,			/* error control	*/
+	NULL,			/* next			*/
+	IPPROTO_MOBILITY,	/* protocol ID		*/
+	0,			/* copy			*/
+	NULL,			/* data			*/
+	"MIPv6 MH"	       	/* name			*/
+};
+#endif
+
+/*
+ *
+ * Code module init/exit functions
+ *
+ */
+
+int __init mipv6_mh_common_init(void)
+{
+	struct sock *sk;
+	int err;
+
+	mipv6_mh_socket = sock_alloc();
+	if (mipv6_mh_socket == NULL) {
+		printk(KERN_ERR
+		       "Failed to create the MIP6 MH control socket.\n");
+		return -1;
+	}
+	mipv6_mh_socket->type = SOCK_RAW;
+
+	if ((err = sock_create(PF_INET6, SOCK_RAW, IPPROTO_MOBILITY, 
+			       &mipv6_mh_socket)) < 0) {
+		printk(KERN_ERR
+		       "Failed to initialize the MIP6 MH control socket (err %d).\n",
+		       err);
+		sock_release(mipv6_mh_socket);
+		mipv6_mh_socket = NULL; /* for safety */
+		return err;
+	}
+
+	sk = mipv6_mh_socket->sk;
+	sk->allocation = GFP_ATOMIC;
+	sk->sndbuf = SK_WMEM_MAX;
+	sk->prot->unhash(sk);
+
+	memset(&mh_rcv, 0, sizeof(mh_rcv));
+	mh_rcv[MIPV6_MH_HOTI].func = mipv6_handle_mh_HC_testinit;
+	mh_rcv[MIPV6_MH_COTI].func = mipv6_handle_mh_HC_testinit;
+	mh_rcv[MIPV6_MH_BU].func =  mipv6_handle_mh_bu;
+
+#if LINUX_VERSION_CODE >= 0x2052a
+	if (inet6_add_protocol(&mipv6_mh_protocol, IPPROTO_MOBILITY) < 0) {
+		printk(KERN_ERR "Failed to register MOBILITY protocol\n");
+		sock_release(mipv6_mh_socket);
+		mipv6_mh_socket = NULL;
+		return -EAGAIN;
+	}
+#else
+	inet6_add_protocol(&mipv6_mh_protocol);
+#endif
+	/* To disable the use of dst_cache, 
+	 *  which slows down the sending of BUs ??
+	 */
+	sk->dst_cache=NULL; 
+
+	return 0;
+}
+
+void __exit mipv6_mh_common_exit(void)
+{
+	if (mipv6_mh_socket) sock_release(mipv6_mh_socket);
+	mipv6_mh_socket = NULL; /* For safety. */
+
+#if LINUX_VERSION_CODE >= 0x2052a
+	inet6_del_protocol(&mipv6_mh_protocol, IPPROTO_MOBILITY);
+#else
+	inet6_del_protocol(&mipv6_mh_protocol);
+#endif
+	memset(&mh_rcv, 0, sizeof(mh_rcv));
+}
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/mobhdr_mn.c linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/mobhdr_mn.c
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/mobhdr_mn.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/mobhdr_mn.c	2003-05-18 11:33:53.000000000 +0200
@@ -0,0 +1,1037 @@
+/*
+ *	Mobile IPv6 Mobility Header Functions for Mobile Node
+ *
+ *	Authors:
+ *	Antti Tuominen	<ajtuomin@tml.hut.fi>
+ *	Niklas Kmpe	<nhkampe@cc.hut.fi>
+ *	Henrik Petander	<henrik.petander@hut.fi>
+ *
+ *	$Id:$
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License as
+ *	published by the Free Software Foundation; either version 2 of
+ *	the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <net/ipv6.h>
+#include <net/addrconf.h>
+#include <net/mipv6.h>
+
+#include "mobhdr.h"
+#include "mn.h"
+#include "bul.h"
+#include "rr_crypto.h"
+#include "debug.h"
+#include "util.h"
+#include "stats.h"
+
+int rr_configured = 1;
+
+static int mipv6_handle_mh_HC_test(struct in6_addr *saddr,
+				   struct in6_addr *coa,
+				   struct in6_addr *cn,
+				   struct in6_addr *unused,
+				   struct mipv6_mh *mh)
+{
+	int ret = 0;
+	int msg_len = (mh->length << 3) + 2;
+	struct mipv6_mh_addr_test *tm = (struct mipv6_mh_addr_test *)mh->data;
+	struct mipv6_bul_entry *bulentry;
+	struct in6_addr home_addr;
+	struct in6_addr *home;
+	
+	DEBUG_FUNC();
+
+	/* We need to get the home address, since CoT only has the CoA*/
+	if (mh->type == MIPV6_MH_COT) {
+		/* TODO: Change this to work with multiple HoAs */
+		mipv6_mn_get_homeaddr(&home_addr);
+		home = &home_addr;
+	} else /* HoT has the home address */
+		home = saddr;
+	if (!home) {
+		DEBUG(DBG_CRITICAL, "Our addr NULL in handling of HC test packet");
+		return -1;
+	}
+
+	if (msg_len < sizeof(*tm)) {
+		DEBUG(DBG_INFO, "Mobility Header length less than H/C Test");
+		return -1;
+	}
+#if 0 /* TODO: Use fcoa here */
+	if (hao) {
+		DEBUG(DBG_INFO, "H/C Test has HAO, dropped.");
+		return -1;
+	}
+#endif
+	write_lock(&bul_lock);
+	if (((bulentry = mipv6_bul_get(cn, home)) == NULL) || !bulentry->rr) {
+		DEBUG(DBG_ERROR, "has no BUL or RR state for "
+		      "source:%x:%x:%x:%x:%x:%x:%x:%x "
+		      "dest:%x:%x:%x:%x:%x:%x:%x:%x",
+		      NIPV6ADDR(cn), NIPV6ADDR(home));
+		write_unlock(&bul_lock);
+		return -1;
+	}
+
+
+	switch (mh->type) {
+	case MIPV6_MH_HOT:
+		if ((bulentry->rr->rr_state & RR_WAITH) == 0) {
+			DEBUG(DBG_ERROR, "Not waiting for a Home Test message");
+			goto out;
+		}
+#if 0
+		/* Check for non-tunneled packet. TODO: How can one do this
+		 * now since skb is not passed ? */
+		if (!(skb->security & RCV_TUNNEL)) {
+			DEBUG(DBG_ERROR, "Received a untunneled packet");
+			goto out;
+		}
+#endif
+		/*
+		 * Make sure no home cookies have been received yet.
+		 * TODO: Check not being put in at this time since subsequent
+		 * BU's after this time will have home cookie stored.
+		 */
+	
+		/* Check if the cookie received is the right one */
+		if (!mipv6_equal_cookies(tm->test_cookie,
+					 bulentry->rr->hot_cookie)) {
+			/* Invalid cookie, might be an old cookie */
+			DEBUG(DBG_INFO, "Received HoT cookie does not match stored cookie");
+			goto out;
+		}
+		bulentry->rr->rr_state &= ~RR_WAITH;
+		memcpy(bulentry->rr->home_cookie, tm->addr_cookie,MIPV6_COOKIE_LEN);
+		bulentry->rr->home_nonce_index = tm->nonce_index;
+		bulentry->rr->home_time = jiffies;
+		ret = 1;
+		break;
+
+	case MIPV6_MH_COT:
+		if ((bulentry->rr->rr_state & RR_WAITC) == 0) {
+			DEBUG(DBG_ERROR, "Not waiting for a Home Test message");
+			goto out;
+		}
+		/*
+		 * Make sure no home cookies have been received yet.
+		 * TODO: Check not being put in at this time since subsequent
+		 * BU's at this time will have careof cookie stored.
+		 */
+	
+		/* Check if the cookie received is the right one */
+		if (!mipv6_equal_cookies(tm->test_cookie,
+					 bulentry->rr->cot_cookie)) {
+			DEBUG(DBG_INFO, "Received CoT cookie does not match stored cookie");
+			goto out;
+		}
+		bulentry->rr->rr_state &= ~RR_WAITC;
+		memcpy(bulentry->rr->careof_cookie, tm->addr_cookie, MIPV6_COOKIE_LEN);
+		bulentry->rr->careof_nonce_index = tm->nonce_index;
+		bulentry->rr->careof_time = jiffies;
+		ret = 1;
+		break;
+	default:
+		/* Impossible to get here */
+		break;
+	}
+out:
+	if (bulentry->rr->rr_state == RR_DONE) {
+		if (bulentry->rr->kbu) /* First free any old keys */
+			kfree(bulentry->rr->kbu);
+		/* Store the session key to be used in BU's */
+		if (ipv6_addr_cmp(&bulentry->coa, &bulentry->home_addr) && bulentry->lifetime)
+			bulentry->rr->kbu = mipv6_rr_key_calc(bulentry->rr->home_cookie,
+							      bulentry->rr->careof_cookie);
+		else 
+			bulentry->rr->kbu = mipv6_rr_key_calc(bulentry->rr->home_cookie,
+							      NULL);
+		/* RR procedure is over, send a BU */
+		mipv6_send_RR_bu(bulentry);
+	}
+	write_unlock(&bul_lock);
+	return ret;
+}
+
+/**
+ * mipv6_handle_mh_brr - Binding Refresh Request handler
+ * @home: home address
+ * @coa: care-of address
+ * @cn: source of this packet
+ * @mh: pointer to the beginning of the Mobility Header
+ *
+ * Handles Binding Refresh Request.  Packet and offset to option are
+ * passed.  Returns 0 on success, otherwise negative.
+ **/
+static int mipv6_handle_mh_brr(struct in6_addr *home,
+			       struct in6_addr *coa,
+			       struct in6_addr *cn,
+			       struct in6_addr *unused,
+			       struct mipv6_mh *mh)
+{
+	struct mipv6_mh_brr *brr = (struct mipv6_mh_brr *)mh->data;
+	struct mipv6_bul_entry *binding;
+	int msg_len = (mh->length << 3) + 2;
+
+	if (msg_len < sizeof(*brr)) {
+		DEBUG(DBG_WARNING, "Mobility Header length less than BRR");
+		MIPV6_INC_STATS(n_brr_drop.invalid);
+		return -1;
+	}
+
+	/* check we know src, else drop */
+	write_lock(&bul_lock);
+	if ((binding = mipv6_bul_get(cn, home)) == NULL) {
+		MIPV6_INC_STATS(n_brr_drop.misc);
+		write_unlock(&bul_lock);
+		return MH_UNKNOWN_CN;
+	}
+
+	MIPV6_INC_STATS(n_brr_rcvd);
+
+	if (msg_len > sizeof(*brr)) {
+		struct mobopt opts;
+		memset(&opts, 0, sizeof(opts));
+		if (parse_mo_tlv(brr + 1, msg_len - sizeof(*brr), &opts) < 0) {
+			write_unlock(&bul_lock);
+			return -1;
+		}
+		/*
+		 * MIPV6_OPT_AUTH_DATA
+		 */
+	}
+
+	/* must hold bul_lock (write) */
+	mipv6_RR_start(home, cn, coa, binding, CN_BU_DELAY,
+		       binding->delay, binding->maxdelay,
+		       binding->flags, binding->prefix, binding->lifetime,
+		       binding->ops);
+
+	write_unlock(&bul_lock);
+	/* MAY also decide to delete binding and send zero lifetime BU
+           with alt-coa set to home address */
+
+	return 0;
+}
+
+/**
+ * mipv6_handle_mh_ba - Binding Acknowledgement handler
+ * @src: source of this packet
+ * @coa: care-of address
+ * @home: home address
+ * @mh: pointer to the beginning of the Mobility Header
+ *
+ **/
+static int mipv6_handle_mh_ba(struct in6_addr *home,
+			      struct in6_addr *coa,
+			      struct in6_addr *src,
+			      struct in6_addr *unused,
+			      struct mipv6_mh *mh)
+{
+	struct mipv6_mh_ba *ba = (struct mipv6_mh_ba *)mh->data;
+	struct mipv6_bul_entry *binding = NULL;
+	struct mobopt opts;
+	int msg_len = (mh->length << 3)  + 2;
+	int auth = 1, req_auth = 1, refresh = -1, ifindex = 0;
+	u32 lifetime, sequence;
+
+	if (msg_len < sizeof(*ba)) {
+		DEBUG(DBG_WARNING, "Mobility Header length less than BA");
+		MIPV6_INC_STATS(n_ba_drop.invalid);
+		return -1;
+	}
+
+	lifetime = ntohs(ba->lifetime) << 2;
+	sequence = ntohs(ba->sequence);
+
+	if (msg_len > sizeof(*ba)) {
+		memset(&opts, 0, sizeof(opts));
+		if (parse_mo_tlv(ba + 1, msg_len - sizeof(*ba), &opts) < 0)
+			return -1;
+		/*
+		 * MIPV6_OPT_AUTH_DATA, MIPV6_OPT_BR_ADVICE
+		 */
+		if (opts.br_advice)
+			refresh = ntohs(opts.br_advice->refresh_interval);
+	}
+
+	if (ba->status >= EXPIRED_HOME_NONCE_INDEX && 
+	    ba->status <= EXPIRED_NONCES) 
+		req_auth = 0;
+	
+	write_lock(&bul_lock);
+	binding = mipv6_bul_get(src, home);
+	if (!binding) {
+		DEBUG(DBG_INFO, "No binding, BA dropped.");
+		write_unlock(&bul_lock);
+		return -1;
+	}
+
+	if (opts.auth_data && binding->rr && (mipv6_auth_check(
+		src, coa, (__u8 *)mh, msg_len, opts.auth_data, binding->rr->kbu) == 0))
+		auth = 1;
+
+	if (req_auth && binding->rr && !auth) {
+		DEBUG(DBG_INFO, "BA Authentication failed.");
+		MIPV6_INC_STATS(n_ba_drop.auth);
+		write_unlock(&bul_lock);
+		return MH_AUTH_FAILED;
+	}
+
+	if (ba->status == SEQUENCE_NUMBER_OUT_OF_WINDOW) {
+		DEBUG(DBG_INFO,
+		      "Sequence number out of window, setting seq to %d",
+		      sequence);
+		binding->seq = sequence + 1;
+		MIPV6_INC_STATS(n_ban_rcvd);
+		send_bu_msg(binding);
+		
+		write_unlock(&bul_lock);
+		return 1;
+	}
+
+	if (binding->seq != sequence) {
+		DEBUG(DBG_INFO, "BU/BA Sequence Number mismatch %d != %d",
+		      binding->seq, sequence);
+		MIPV6_INC_STATS(n_ba_drop.invalid);
+		write_unlock(&bul_lock);
+		return MH_SEQUENCE_MISMATCH;
+	}
+	if (ba->status == EXPIRED_HOME_NONCE_INDEX || ba->status == EXPIRED_NONCES) {
+		if (binding->rr) {
+			/* Need to resend home test init to CN */
+			binding->rr->rr_state |= RR_WAITH;
+			mipv6_send_addr_test_init(&binding->home_addr, 
+						  &binding->cn_addr, 
+						  MIPV6_MH_HOTI,
+						  binding->rr->hot_cookie);
+			MIPV6_INC_STATS(n_ban_rcvd);
+		} else {
+			DEBUG(DBG_WARNING, "Got BA with status EXPIRED_HOME_NONCE_INDEX"
+			      "for non-RR BU");
+			MIPV6_INC_STATS(n_ba_drop.invalid);
+		}
+		write_unlock(&bul_lock);
+		return 0;
+	} 
+	if (ba->status == EXPIRED_CAREOF_NONCE_INDEX || ba->status == EXPIRED_NONCES) {
+		if (binding->rr) { 
+			/* Need to resend care-of test init to CN */
+			binding->rr->rr_state |= RR_WAITC;
+			mipv6_send_addr_test_init(&binding->coa, 
+						  &binding->cn_addr, 
+						  MIPV6_MH_COTI,
+						  binding->rr->cot_cookie);
+			MIPV6_INC_STATS(n_ban_rcvd);
+		} else  {
+			DEBUG(DBG_WARNING, "Got BA with status EXPIRED_HOME_CAREOF_INDEX"
+			      "for non-RR BU");
+			MIPV6_INC_STATS(n_ba_drop.invalid);
+		}
+		write_unlock(&bul_lock);
+		return 0;
+	}
+	write_unlock(&bul_lock);
+	
+	if (ba->status >= REASON_UNSPECIFIED) {
+		DEBUG(DBG_INFO, "Binding Ack status : %d indicates error", ba->status);
+		mipv6_ba_rcvd(ifindex, src, home, ntohs(ba->sequence), lifetime,
+			      refresh, ba->status);
+		MIPV6_INC_STATS(n_ban_rcvd);
+		return 0;
+	}
+
+	if (ba->status != 0) {
+		/* Unknown BA status */
+		MIPV6_INC_STATS(n_ba_drop.invalid);
+		return 0;
+	}
+	
+	MIPV6_INC_STATS(n_ba_rcvd);
+	if (mipv6_ba_rcvd(ifindex, src, home, ntohs(ba->sequence), lifetime,
+			  refresh, ba->status)) {
+		DEBUG(DBG_WARNING, "mipv6_ba_rcvd failed");
+	}
+	
+	return 0;
+}
+
+/**
+ * mipv6_handle_mh_be - Binding Error handler
+ * @cn: source of this packet
+ * @coa: care-of address
+ * @home: home address
+ * @mh: pointer to the beginning of the Mobility Header
+ *
+ **/
+static int mipv6_handle_mh_be(struct in6_addr *home,
+			      struct in6_addr *coa,
+			      struct in6_addr *cn,
+			      struct in6_addr *unused,
+			      struct mipv6_mh *mh)
+{
+	struct mipv6_mh_be *be = (struct mipv6_mh_be *)mh->data;
+	int msg_len = (mh->length << 3)  + 2;
+
+	if (msg_len < sizeof(*be)) {
+		DEBUG(DBG_WARNING, "Mobility Header length less than BE");
+		MIPV6_INC_STATS(n_be_drop.invalid);
+		return -1;
+	}
+
+	/* check we know src, else drop */
+	if (!mipv6_bul_exists(cn, home)) {
+		MIPV6_INC_STATS(n_be_drop.misc);
+		return MH_UNKNOWN_CN;
+	}
+
+	if (msg_len > sizeof(*be)) {
+		/* no valid Mobility Options this time, just ignore */
+	}
+
+	MIPV6_INC_STATS(n_be_rcvd);
+	switch (be->status) {
+	case 1: /* Home Address Option used without a binding */
+		/* Get ULP information about CN-MN communication.  If
+                   nothing in progress, MUST delete.  Otherwise MAY
+                   ignore. */
+		mipv6_bul_delete(cn, home);
+		break;
+	case 2: /* Received unknown MH type */
+		/* If not expecting ack, SHOULD ignore.  If MH
+                   extension in use, stop it.  If not, stop RO for
+                   this CN. */
+		break;
+	}
+
+	return 0;
+}
+
+int send_bu_msg(struct mipv6_bul_entry *binding)
+{ 
+	int auth = 0; /* Use auth */
+	int ret = 0;
+	struct mipv6_auth_parm parm;
+	struct mipv6_mh_bu bu;
+	
+	MIPV6_INC_STATS(n_bu_sent);
+	if (!binding) {
+		DEBUG(DBG_ERROR, "called with a null bul entry");
+		return -1;
+	}
+	
+	memset(&parm, 0, sizeof(parm));
+	if (mipv6_prefix_compare(&binding->coa, &binding->home_addr, 64))
+		parm.coa = &binding->home_addr;
+	else
+		parm.coa = &binding->coa;
+	parm.cn_addr = &binding->cn_addr;
+	/* First add all other options then calculate the length of the auth opt.
+	 * The contents will be calculated in send_mh after calculating the 
+	 * checksum of MH. 
+	 */ 
+
+	if (binding->rr && binding->rr->kbu) {
+		DEBUG(DBG_INFO, "Binding with key");
+		auth = 1;
+		parm.k_bu = binding->rr->kbu;
+	}
+	/* Add options to BU */
+
+
+	memset(&bu, 0, sizeof(bu));
+	bu.flags = binding->flags;
+	bu.sequence = htons(binding->seq);
+	bu.lifetime = htons(binding->lifetime >> 2);
+	bu.reserved = 0;
+
+	ret = send_mh(&binding->cn_addr, &binding->home_addr, (u8 *)&bu, 
+		      sizeof(bu), MIPV6_MH_BU, &binding->home_addr, NULL, 
+		      binding->ops, &parm);
+	return ret;
+}
+
+/*
+ *
+ * Callback handlers for binding update list
+ *
+ */
+
+/* Return value 0 means keep entry, non-zero means discard entry. */
+
+/* Callback for BUs not requiring acknowledgement
+ */
+static int bul_expired(struct mipv6_bul_entry *bulentry)
+{
+	/* Lifetime expired, delete entry. */
+	DEBUG(DBG_INFO, "bul entry 0x%x lifetime expired, deleting entry", (int) bulentry);
+	return 1;
+}
+
+/* Callback for BUs requiring acknowledgement with exponential resending
+ * scheme */
+static int bul_resend_exp(struct mipv6_bul_entry *bulentry)
+{
+	unsigned long now = jiffies;
+	
+	DEBUG(DBG_INFO, "(0x%x) resending bu", (int) bulentry);
+
+	
+	/* If sending a de-registration, do not care about the
+	 * lifetime value, as de-registrations are normally sent with
+	 * a zero lifetime value. If the entry is a home entry get the 
+	 * current lifetime. 
+	 */
+
+	if (bulentry->lifetime != 0) {
+		bulentry->lifetime = mipv6_mn_get_bulifetime(
+			&bulentry->home_addr, &bulentry->coa, bulentry->flags);
+
+		bulentry->expire = now + bulentry->lifetime * HZ;
+	} else {
+		bulentry->expire = now + HOME_RESEND_EXPIRE * HZ; 
+	}
+	if (bulentry->rr) {
+		/* Redo RR, if cookies have expired */
+		if (time_after(jiffies, bulentry->rr->home_time + MAX_COOKIE_LIFE * HZ)) 
+			bulentry->rr->rr_state |= RR_WAITH;
+		if (time_after(jiffies, bulentry->rr->careof_time + MAX_COOKIE_LIFE * HZ)) 
+			bulentry->rr->rr_state |= RR_WAITC;
+
+		if (bulentry->rr->rr_state & RR_WAITH) {
+				/* Resend HoTI directly */
+			mipv6_send_addr_test_init(&bulentry->home_addr, 
+						  &bulentry->cn_addr, MIPV6_MH_HOTI,
+						  bulentry->rr->hot_cookie);
+		}
+		if (bulentry->rr->rr_state & RR_WAITC) {
+				/* Resend CoTI directly */
+				mipv6_send_addr_test_init(&bulentry->coa, 
+							  &bulentry->cn_addr, MIPV6_MH_COTI,
+							  bulentry->rr->cot_cookie);
+			}
+		goto out;
+	}
+	
+	bulentry->seq++;
+
+	if (send_bu_msg(bulentry) < 0)
+		DEBUG(DBG_ERROR, "Resending of BU failed");
+
+out:
+	/* Schedule next retransmission */
+	if (bulentry->delay < bulentry->maxdelay) {
+		bulentry->delay = 2 * bulentry->delay;
+		if (bulentry->delay > bulentry->maxdelay) {
+			/* can happen if maxdelay is not power(mindelay, 2) */
+			bulentry->delay = bulentry->maxdelay;
+		}
+	} else if (bulentry->flags & MIPV6_BU_F_HOME) {
+		/* Home registration - continue sending BU at maxdelay rate */
+		DEBUG(DBG_INFO, "Sending BU to HA after max ack wait time "
+		      "reached(0x%x)", (int) bulentry);
+		bulentry->delay = bulentry->maxdelay;
+	} else if (!(bulentry->flags & MIPV6_BU_F_HOME)) {
+		/* Failed to get BA from a CN */
+		bulentry->callback_time = now;
+		return -1;
+	}
+	
+	bulentry->callback_time = now + bulentry->delay * HZ;
+	return 0;
+}
+
+
+
+/* Callback for sending a registration refresh BU
+ */
+static int bul_refresh(struct mipv6_bul_entry *bulentry)
+{
+	unsigned long now = jiffies;
+	
+	/* Refresh interval passed, send new BU */
+	DEBUG(DBG_INFO, "bul entry 0x%x refresh interval passed, sending new BU", (int) bulentry);
+	if (bulentry->lifetime == 0)
+		return 0;
+
+	/* Set new maximum lifetime and expiration time */
+	bulentry->lifetime = mipv6_mn_get_bulifetime(&bulentry->home_addr, 
+						     &bulentry->coa, 
+						     bulentry->flags);
+	bulentry->expire = now + bulentry->lifetime * HZ;
+	bulentry->seq++;
+	/* Send update */
+	if (send_bu_msg(bulentry) < 0)
+		DEBUG(DBG_ERROR, "Resending of BU failed");
+	
+	if (bulentry->expire <= now) {
+		/* Sanity check */
+		DEBUG(DBG_ERROR, "bul entry expire time in history - setting expire to %u secs", ERROR_DEF_LIFETIME);
+		bulentry->lifetime = ERROR_DEF_LIFETIME;
+		bulentry->expire = now + ERROR_DEF_LIFETIME*HZ;
+	}
+
+	/* Set up retransmission */
+	bulentry->state = RESEND_EXP;
+	bulentry->callback = bul_resend_exp;
+	bulentry->callback_time = now + INITIAL_BINDACK_TIMEOUT*HZ;
+	bulentry->delay = INITIAL_BINDACK_TIMEOUT;
+	bulentry->maxdelay = MAX_BINDACK_TIMEOUT;
+
+	MIPV6_INC_STATS(n_bu_sent);
+
+	return 0;
+}
+int mipv6_send_RR_bu(struct mipv6_bul_entry *bulentry)
+{
+	int ops_len = 0;
+	u16 nonces[2];
+
+	DEBUG(DBG_INFO, "Sending BU to CN  %x:%x:%x:%x:%x:%x:%x:%x for home address" 
+	      "%x:%x:%x:%x:%x:%x:%x:%x", 
+	      NIPV6ADDR(&bulentry->cn_addr),  NIPV6ADDR(&bulentry->home_addr));
+	nonces[0] = bulentry->rr->home_nonce_index;
+	nonces[1] = bulentry->rr->careof_nonce_index;
+	ops_len = sizeof(struct mipv6_mo_bauth_data) + MIPV6_RR_MAC_LENGTH + 
+			sizeof(struct mipv6_mo_nonce_indices);
+	if (bulentry->ops) {
+		DEBUG(DBG_WARNING, "Bul entry had existing mobility options, freeing them");
+		kfree(bulentry->ops);
+	}
+	bulentry->ops = alloc_mh_opts(ops_len);
+
+	if (!bulentry->ops)
+		return -ENOMEM;
+	if (append_mh_opt(bulentry->ops, MIPV6_OPT_NONCE_INDICES, 
+			  sizeof(struct mipv6_mo_nonce_indices) - 2, nonces) < 0)
+		return -ENOMEM;
+
+	if (append_mh_opt(bulentry->ops, MIPV6_OPT_AUTH_DATA,
+			  MIPV6_RR_MAC_LENGTH, NULL) < 0)
+		return -ENOMEM;
+	/* RR procedure is over, send a BU */
+	if (!(bulentry->flags & MIPV6_BU_F_ACK)) {
+		DEBUG(DBG_INFO, "Setting bul callback to bul_expires");
+		bulentry->state = ACK_OK;
+		bulentry->callback = bul_expired;
+		bulentry->callback_time = jiffies + HZ * bulentry->lifetime;
+		bulentry->expire = jiffies + HZ *  bulentry->lifetime;
+	}
+	else {
+		bulentry->callback_time = jiffies + HZ;
+		bulentry->expire = jiffies + HZ *  bulentry->lifetime;
+	}
+	mipv6_bul_reschedule(bulentry);
+	return send_bu_msg(bulentry);
+}
+
+int mipv6_rr_state(struct mipv6_bul_entry *bul, struct in6_addr *saddr,
+		   struct in6_addr *coa, __u8 plen, __u8 flags)
+{
+	if (!rr_configured)
+		return NO_RR;
+       	if (flags & MIPV6_BU_F_HOME) {
+		/* We don't need RR, this is a Home Registration */
+		return NO_RR;
+	}
+	if (!bul || !bul->rr) {
+		/* First time BU to CN, need RR */
+		return DO_RR;
+	}
+
+	switch (bul->rr->rr_state) {
+	case RR_INIT:
+		/* Need RR if first BU to CN */
+		return DO_RR;
+	case RR_DONE:
+		/* If MN moves to a new coa, do RR for it */
+		if (!ipv6_addr_cmp(&bul->coa, coa))  
+			return NO_RR; 
+		else
+			return DO_RR;
+	default:
+		/*
+		 * We are in the middle of RR, the HoTI and CoTI have been
+		 * sent. But we haven't got HoT and CoT from the CN, so
+		 * don't do anything more at this time.
+		 */
+		return INPROGRESS_RR;
+	}
+}
+
+/*
+ * TODO : try to reduce arguments, and pass only bulentry.
+ * Status : Cannot do above, since send_upd's arguments to RR_start needs
+ * to be saved in the bul for later retranmitting the BU after RR is done.
+ * So this seems to be ok, with more arguments.
+ * TODO : Needs some work still, eg, maxdelay is not being passed to send_upd(),
+ * but it is not a big problem, that is the amount of time to wait before 
+ * sending a BU, and in real life, BU gets sent after a delay equal to the time
+ * needed to do RR.
+ */
+
+/**
+ * mipv6_RR_start - Start Return Routability procedure
+ * @home_addr: home address
+ * @cn_addr: correspondent address
+ * @coa: care-of address
+ * @entry: binding update list entry (if any)
+ * @maxdelay: max wait before send
+ * @initdelay: ??
+ * @maxackdelay: ??
+ * @flags: flags
+ * @plength: prefix length
+ * @lifetime: lifetime of binding
+ * @ops: mobility options
+ *
+ * Caller must hold @bul_lock (write).
+ **/
+int mipv6_RR_start(struct in6_addr *home_addr, struct in6_addr *cn_addr,
+		   struct in6_addr *coa, struct mipv6_bul_entry *entry,
+		   long maxdelay, __u32 initdelay, __u32 maxackdelay,
+		   __u8 flags, __u8 plength, __u32 lifetime, struct mipv6_mh_opt *ops)
+{
+	int ret = -1;
+	struct mipv6_bul_entry *bulentry = entry;
+	struct mipv6_rr_info *rr = NULL;
+	int seq = 0;
+	DEBUG_FUNC();
+	
+	/* Do RR procedure only for care-of address after handoff, 
+	   if home cookie is still valid */
+	if (bulentry && bulentry->rr && time_before(jiffies, bulentry->rr->home_time + 
+						    MAX_COOKIE_LIFE * HZ) && !(ipv6_addr_cmp(home_addr, coa) == 0 || !lifetime)) { 
+		mipv6_rr_mn_cookie_create(bulentry->rr->cot_cookie); 
+		DEBUG(DBG_INFO, "Bul entry and rr info exist, only doing RR for COA");
+		ipv6_addr_copy(&bulentry->coa, coa);
+		bulentry->rr->rr_state |= RR_WAITC;
+	} else if (!bulentry || !(bulentry->flags & MIPV6_BU_F_HOME)) {
+		DEBUG(DBG_INFO, "Doing RR for both HoA and CoA");
+		rr = kmalloc(sizeof(*rr), GFP_ATOMIC);
+		memset(rr, 0, sizeof(*rr));
+		mipv6_rr_mn_cookie_create(rr->cot_cookie);
+		mipv6_rr_mn_cookie_create(rr->hot_cookie);
+		rr->rr_state = RR_WAITHC;
+	}
+	if (bulentry) 
+		seq = bulentry->seq + 1;
+	else
+		seq = 0;
+	/* Save the info in the BUL to retransmit the BU after RR is done */
+	/* Caller must hold bul_lock (write) since we don't */
+       
+	if ((bulentry = mipv6_bul_add(cn_addr, home_addr, coa, min_t(__u32, lifetime, MAX_RR_BINDING_LIFE),
+				      seq, plength, 
+				      flags, bul_resend_exp, initdelay, 
+				      RESEND_EXP, initdelay, 
+				      maxackdelay, ops, 
+				      rr)) == NULL) {
+		DEBUG(DBG_INFO, "couldn't update BUL for HoTi");
+		goto out;
+	}
+	rr = bulentry->rr; 
+	mipv6_send_addr_test_init(home_addr, cn_addr, MIPV6_MH_HOTI, 
+				  rr->hot_cookie);
+	if (ipv6_addr_cmp(home_addr, coa) && lifetime) 
+		mipv6_send_addr_test_init(coa, cn_addr, MIPV6_MH_COTI, rr->cot_cookie);
+	else {
+		bulentry->rr->rr_state &= ~RR_WAITC;
+	}
+	ret = 0;
+out:
+	return ret;
+}
+
+/*
+ * mipv6_upd_rate_limit() : Takes a bulentry, a COA and 'flags' to check
+ * whether BU being sent is for Home Registration or not.
+ *
+ * If the number of BU's sent is fewer than MAX_FAST_UPDATES, this BU
+ * is allowed to be sent at the MAX_UPDATE_RATE.
+ * If the number of BU's sent is greater than or equal to MAX_FAST_UPDATES,
+ * this BU is allowed to be sent at the SLOW_UPDATE_RATE.
+ *
+ * Assumption : This function is not re-entrant. and the caller holds the
+ * bulentry lock (by calling mipv6_bul_get()) to stop races with other
+ * CPU's executing this same function.
+ *
+ * Side-Effects. Either of the following could  on success :
+ *	1. Sets consecutive_sends to 1 if the entry is a Home agent
+ *	   registration or the COA has changed.
+ *	2. Increments consecutive_sends if the number of BU's sent so
+ *	   far is less than MAX_FAST_UPDATES, and this BU is being sent
+ *	   atleast MAX_UPDATE_RATE after previous one.
+ * 
+ * Return Value : 0 on Success, -1 on Failure
+ */
+int mipv6_bu_rate_limit(struct mipv6_bul_entry *bulentry, struct in6_addr *coa,
+	__u8 flags)
+{
+	if ((flags & MIPV6_BU_F_HOME) || ipv6_addr_cmp(&bulentry->coa, coa)) {
+		/* Home Agent Registration or different COA - restart from 1 */
+		bulentry->consecutive_sends = 1;
+		return 0;
+	}
+
+	if (bulentry->consecutive_sends < MAX_FAST_UPDATES) {
+		/* First MAX_FAST_UPDATES can be sent at MAX_UPDATE_RATE */
+		if (jiffies - bulentry->lastsend < MAX_UPDATE_RATE * HZ) {
+			return -1;
+		}
+		bulentry->consecutive_sends ++;
+	} else {
+		/* Remaining updates SHOULD be sent at SLOW_UPDATE_RATE */
+		if (jiffies - bulentry->lastsend < SLOW_UPDATE_RATE * HZ) {
+			return -1;
+		}
+		/* Don't inc 'consecutive_sends' to avoid overflow to zero */
+	}
+	/* OK to send a BU */
+	return 0;
+}
+
+/**
+ * mipv6_send_bu - send a Binding Update 
+ * @saddr: source address for BU
+ * @daddr: destination address for BU
+ * @coa: care-of address for MN
+ * @maxdelay: maximun milliseconds before option is sent
+ * @initdelay: ??
+ * @maxackdelay: 
+ * @exp: exponention back off
+ * @flags: flags for BU
+ * @plength: prefix length
+ * @lifetime: granted lifetime for binding
+ * @ops: mobility options
+ *
+ * Send a binding update.  Actual sending may be delayed up to
+ * @maxdelay milliseconds. 'flags' may contain any of %MIPV6_BU_F_ACK,
+ * %MIPV6_BU_F_HOME, %MIPV6_BU_F_ROUTER bitwise ORed.  If
+ * %MIPV6_BU_F_ACK is included retransmission will be attempted until
+ * the update has been acknowledged.  Retransmission is done if no
+ * acknowledgement is received within @initdelay seconds.  @exp
+ * specifies whether to use exponential backoff (@exp != 0) or linear
+ * backoff (@exp == 0).  For exponential backoff the time to wait for
+ * an acknowledgement is doubled on each retransmission until a delay
+ * of @maxackdelay, after which retransmission is no longer attempted.
+ * For linear backoff the delay is kept constant and @maxackdelay
+ * specifies the maximum number of retransmissions instead.  If
+ * sub-options are present ops must contain all sub-options to be
+ * added.  On a mobile node, use the mobile node's home address for
+ * @saddr.  Returns 0 on success, non-zero on failure.  
+ *
+ * Caller may not hold @bul_lock.
+ **/
+int mipv6_send_bu(struct in6_addr *saddr, struct in6_addr *daddr,
+		  struct in6_addr *coa, long maxdelay, u32 initdelay, 
+		  u32 maxackdelay, u8 exp, u8 flags, u8 plength, 
+		  u32 lifetime, struct mipv6_mh_opt *ops)
+{
+	int ret;
+	__u8 state;
+	 __u16 seq = 0;
+	int (*callback)(struct mipv6_bul_entry *);
+	__u32 callback_time;
+	struct mipv6_bul_entry *bulentry;
+	
+	/* First a sanity check: don't send BU to local addresses */
+	if(ipv6_chk_addr(daddr, NULL)) {
+		DEBUG(DBG_ERROR, "BUG: Trying to send BU to local address");
+		return -1;
+	}
+	DEBUG(DBG_INFO, "Sending BU to CN  %x:%x:%x:%x:%x:%x:%x:%x for home address" 
+		 "%x:%x:%x:%x:%x:%x:%x:%x", 
+		 NIPV6ADDR(daddr),  NIPV6ADDR(saddr));
+	plength = 0;
+
+	if ((bulentry = mipv6_bul_get(daddr, saddr)) != NULL) {
+		if (bulentry->state == ACK_ERROR) {
+			/*
+			 * Don't send any more BU's to nodes which don't
+			 * understanding one. 
+			 */
+			DEBUG(DBG_INFO, "Not sending BU to node which doesn't"
+			      " understand one");
+			return -1;
+		}
+		if (mipv6_bu_rate_limit(bulentry, coa, flags) < 0) {
+			DEBUG(DBG_DATADUMP, "Limiting BU sent.");
+			return 0;
+		}
+	}
+
+	switch (mipv6_rr_state(bulentry, saddr, coa, plength, flags)) {
+	case INPROGRESS_RR:
+		/* We are already doing RR, don't do BU at this time, it is
+		 * done automatically later */
+		DEBUG(DBG_INFO, "RR in progress not sending BU");
+		return 0;
+
+	case DO_RR:
+		/* Just do RR and return, BU is done automatically later */
+		DEBUG(DBG_INFO, "starting RR" );
+		mipv6_RR_start(saddr, daddr, coa, bulentry, maxdelay, initdelay,
+			       maxackdelay, flags, plength, lifetime, ops);
+		return 0;
+		
+	case NO_RR:
+		DEBUG(DBG_DATADUMP, "No RR necessary" );
+	default:
+		break;
+	}
+
+	flags |= MIPV6_BU_F_SINGLE;
+	if (bulentry)
+		seq = bulentry->seq + 1;
+	
+	/* Add to binding update list */
+	
+	if (flags & MIPV6_BU_F_ACK) {
+		DEBUG(DBG_INFO, "Setting bul callback to bul_resend_exp");
+		/* Send using exponential backoff */
+		state = RESEND_EXP;
+		callback = bul_resend_exp;
+		callback_time = initdelay;
+	} else {
+		DEBUG(DBG_INFO, "Setting bul callback to bul_expired");
+		/* No acknowledgement/resending required */
+		state = ACK_OK;	/* pretend we got an ack */
+		callback = bul_expired;
+		callback_time = lifetime;
+	}
+
+	/* BU only for the home address */
+	/* We must hold bul_lock (write) while calling add */
+	if ((bulentry = mipv6_bul_add(daddr, saddr, coa, lifetime, seq,
+				      plength, flags, callback, callback_time, 
+				      state, initdelay, maxackdelay, ops, 
+				      NULL)) == NULL) {
+		DEBUG(DBG_INFO, "couldn't update BUL");
+		return 0;
+	}
+	ret = send_bu_msg(bulentry);
+
+	return ret;
+}
+
+/**
+ *	mipv6_ba_rcvd	-	Update BUL for this Binding Acknowledgement
+ *	@ifindex: interface BA came from
+ *	@cnaddr: sender IPv6 address
+ *	@home_addr: home address
+ *	@sequence: sequence number
+ *	@lifetime: lifetime granted by Home Agent in seconds
+ *	@refresh: recommended resend interval
+ *	@status: %STATUS_UPDATE (ack) or %STATUS_REMOVE (nack)
+ **/
+int mipv6_ba_rcvd(int ifindex, struct in6_addr *cnaddr, 
+		   struct in6_addr *home_addr, 
+		   u16 sequence, u32 lifetime, 
+		   u32 refresh, int status)
+{
+	struct mipv6_bul_entry *bulentry;
+	unsigned long now = jiffies;
+	struct mn_info *mninfo;
+
+	DEBUG(DBG_INFO, "binding ack received with sequence number 0x%x, status: %d ",
+	      (int) sequence, status);
+
+	if (status != 0) {
+		DEBUG(DBG_WARNING, "- NACK - BA status:  %d, deleting bul entry", status);
+		return mipv6_bul_delete(cnaddr, home_addr);
+	}
+
+	/* Find corresponding entry in binding update list. */
+	write_lock(&bul_lock);
+	if ((bulentry = mipv6_bul_get(cnaddr, home_addr)) == NULL) {
+		DEBUG(DBG_INFO, "- discarded, no entry in bul matches BA source address");
+		write_unlock(&bul_lock);
+		return -1;
+	}
+	/* Check that sequence numbers match */
+	if (sequence != bulentry->seq) {
+		/* retransmission handles bad seq number if needed */
+		DEBUG(DBG_INFO, "BA discarded, seq number mismatch");
+		write_unlock(&bul_lock);
+		return -1;
+	}
+	bulentry->state = ACK_OK;
+
+	if (bulentry->flags & MIPV6_BU_F_HOME && lifetime > 0) {
+		/* For home registrations: schedule a refresh binding update.
+		 * Use the refresh interval given by home agent or 80%
+		 * of lifetime, whichever is less.
+		 *
+		 * Adjust binding lifetime if 'granted' lifetime
+		 * (lifetime value in received binding acknowledgement)
+		 * is shorter than 'requested' lifetime (lifetime
+		 * value sent in corresponding binding update).
+		 * max((L_remain - (L_update - L_ack)), 0)
+		 */
+		if (lifetime * HZ < (bulentry->expire - bulentry->lastsend)) {
+			bulentry->expire = 
+				max_t(__u32, bulentry->expire - 
+				      ((bulentry->expire - bulentry->lastsend) - 
+				       lifetime * HZ), jiffies + 
+				      ERROR_DEF_LIFETIME * HZ);
+		}
+		if (refresh > lifetime || refresh == 0)
+			refresh = 4 * lifetime / 5;
+			DEBUG(DBG_INFO, "setting callback for expiration of"
+			      " a Home Registration: lifetime:%d, refresh:%d",
+			      lifetime, refresh);
+		bulentry->callback = bul_refresh;
+		bulentry->callback_time = now + refresh * HZ;
+		bulentry->expire = now + lifetime * HZ;
+		bulentry->lifetime = lifetime;
+		if (bulentry->expire <= jiffies) {
+			/* Sanity check */
+			DEBUG(DBG_ERROR, "bul entry expire time in history - setting expire to %u secs",
+			      ERROR_DEF_LIFETIME);
+			bulentry->expire = jiffies + ERROR_DEF_LIFETIME * HZ;
+		}
+		read_lock(&mn_info_lock);
+		mninfo = mipv6_mninfo_get_by_home(&bulentry->home_addr);
+		if (mninfo == NULL) {
+			/* what should we do ? */
+		} else {
+			spin_lock(&mninfo->lock);
+			mninfo->has_home_reg = 1;
+			spin_unlock(&mninfo->lock);
+			mninfo = NULL;
+		}
+		read_unlock(&mn_info_lock);
+		bulentry->flags &= ~MIPV6_BU_F_DAD;
+			
+	} else if ((bulentry->flags & MIPV6_BU_F_HOME) && bulentry->lifetime == 0) {
+		bulentry->callback = bul_expired;
+		bulentry->callback_time = jiffies + HZ;
+		mipv6_bul_reschedule(bulentry);
+		write_unlock(&bul_lock);
+		mipv6_mn_send_home_na(home_addr);
+
+		return 0;
+	}
+	DEBUG(DBG_INFO, "- accepted");
+
+	mipv6_bul_reschedule(bulentry);
+	write_unlock(&bul_lock);
+
+	return 0;
+}
+
+int __init mipv6_mh_mn_init(void)
+{
+	mipv6_mh_register(MIPV6_MH_HOT, mipv6_handle_mh_HC_test);
+	mipv6_mh_register(MIPV6_MH_COT, mipv6_handle_mh_HC_test);
+	mipv6_mh_register(MIPV6_MH_BA, mipv6_handle_mh_ba);
+	mipv6_mh_register(MIPV6_MH_BRR, mipv6_handle_mh_brr);
+	mipv6_mh_register(MIPV6_MH_BE, mipv6_handle_mh_be);
+
+	return 0;
+}
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/module_cn.c linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/module_cn.c
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/module_cn.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/module_cn.c	2003-05-18 11:33:53.000000000 +0200
@@ -0,0 +1,144 @@
+/*
+ *	Mobile IPv6 Common Module
+ *
+ *	Authors:
+ *	Sami Kivisaari          <skivisaa@cc.hut.fi>
+ *	Antti Tuominen          <ajtuomin@tml.hut.fi>
+ *
+ *	$Id$
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/init.h>
+
+#ifdef CONFIG_SYSCTL
+#include <linux/sysctl.h>
+#endif /* CONFIG_SYSCTL */
+
+#include <net/mipglue.h>
+
+#include "bcache.h"
+#include "stats.h"
+#include "mobhdr.h"
+#include "exthdrs.h"
+
+int mipv6_debug = 1;
+int mipv6_use_auth = 0;
+
+#if defined(MODULE) && LINUX_VERSION_CODE > 0x20115
+MODULE_AUTHOR("MIPL Team");
+MODULE_DESCRIPTION("Mobile IPv6");
+MODULE_LICENSE("GPL");
+MODULE_PARM(mipv6_debug, "i");
+#endif
+
+#include "config.h"
+int mipv6_cap = 0;
+
+#define MIPV6_BCACHE_SIZE 128
+
+/**********************************************************************
+ *
+ * MIPv6 CN Module Init / Cleanup
+ *
+ **********************************************************************/
+
+#ifdef CONFIG_SYSCTL
+/* Sysctl table */
+ctl_table mipv6_mobility_table[] = {
+	{NET_IPV6_MOBILITY_DEBUG, "debuglevel",
+	 &mipv6_debug, sizeof(int), 0644, NULL,
+	 &proc_dointvec},
+	{NET_IPV6_MOBILITY_AUTH, "use_auth",
+	 &mipv6_use_auth, sizeof(int), 0644, NULL,
+	 &proc_dointvec},
+	{0}
+};
+ctl_table mipv6_table[] = {
+	{NET_IPV6_MOBILITY, "mobility", NULL, 0, 0555, mipv6_mobility_table},
+	{0}
+};
+
+static struct ctl_table_header *mipv6_sysctl_header;
+static struct ctl_table mipv6_net_table[];
+static struct ctl_table mipv6_root_table[];
+
+ctl_table mipv6_net_table[] = {
+	{NET_IPV6, "ipv6", NULL, 0, 0555, mipv6_table},
+	{0}
+};
+
+ctl_table mipv6_root_table[] = {
+	{CTL_NET, "net", NULL, 0, 0555, mipv6_net_table},
+	{0}
+};
+#endif /* CONFIG_SYSCTL */
+
+extern void mipv6_rr_init(void);
+
+/*  Initialize the module  */
+int __init init_module(void)
+{
+	int err = 0;
+
+	printk(KERN_INFO "MIPL Mobile IPv6 for Linux Correspondent Node %s (%s)\n",
+	       MIPLVERSION, MIPV6VERSION);
+	mipv6_cap = CAP_CN;
+
+#ifdef CONFIG_IPV6_MOBILITY_DEBUG
+	printk(KERN_INFO "Debug-level: %d\n", mipv6_debug);
+#endif
+	if ((err = mipv6_bcache_init(MIPV6_BCACHE_SIZE)) < 0)
+		goto bcache_fail;
+
+	if ((err = mipv6_stats_init()) < 0)
+		goto stats_fail;
+	mipv6_rr_init();
+
+#ifdef CONFIG_SYSCTL
+	mipv6_sysctl_header = register_sysctl_table(mipv6_root_table, 0);
+#endif
+
+	if ((err = mipv6_mh_common_init()) < 0)
+		goto mh_fail;
+
+	MIPV6_SETCALL(mipv6_modify_txoptions, mipv6_modify_txoptions);
+		
+	MIPV6_SETCALL(mipv6_handle_homeaddr, mipv6_handle_homeaddr);
+	MIPV6_SETCALL(mipv6_icmp_handle_homeaddr, mipv6_icmp_handle_homeaddr);
+
+	return 0;
+
+mh_fail:
+#ifdef CONFIG_SYSCTL
+	unregister_sysctl_table(mipv6_sysctl_header);
+#endif
+	mipv6_stats_exit();
+stats_fail:
+	mipv6_bcache_exit();
+bcache_fail:
+	return err;
+}
+
+/*  Cleanup module  */
+void __exit cleanup_module(void)
+{
+	printk(KERN_INFO "exiting.\n");
+#ifdef CONFIG_SYSCTL
+	unregister_sysctl_table(mipv6_sysctl_header);
+#endif
+
+	/* Invalidate all custom kernel hooks.  No need to do this
+           separately for all hooks. */
+	mipv6_invalidate_calls();
+
+	mipv6_mh_common_exit();
+	mipv6_stats_exit();
+	mipv6_bcache_exit();
+}
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/module_ha.c linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/module_ha.c
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/module_ha.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/module_ha.c	2003-05-18 11:33:53.000000000 +0200
@@ -0,0 +1,293 @@
+/*
+ *	Mobile IPv6 Home Agent Module
+ *
+ *	Authors:
+ *	Sami Kivisaari          <skivisaa@cc.hut.fi>
+ *	Antti Tuominen          <ajtuomin@tml.hut.fi>
+ *
+ *	$Id$
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/init.h>
+
+#ifdef CONFIG_SYSCTL
+#include <linux/sysctl.h>
+#endif /* CONFIG_SYSCTL */
+
+#include <net/mipglue.h>
+
+#include "bcache.h"
+#include "stats.h"
+#include "mobhdr.h"
+#include "tunnel.h"
+#include "exthdrs.h"
+#include "ha.h"
+#include "halist.h"
+#include "mipv6_icmp.h"
+#include "prefix.h"
+
+#include "debug.h"
+#include "util.h"
+
+int mipv6_debug = 1;
+int mipv6_use_auth = 0;
+
+#if defined(MODULE) && LINUX_VERSION_CODE > 0x20115
+MODULE_AUTHOR("MIPL Team");
+MODULE_DESCRIPTION("Mobile IPv6");
+MODULE_LICENSE("GPL");
+MODULE_PARM(mipv6_debug, "i");
+#endif
+
+#include "config.h"
+int mipv6_cap = 0;
+
+#define MIPV6_BCACHE_SIZE 128
+#define MIPV6_HALIST_SIZE 128
+
+/*
+ * Called from ndisc.c's router_discovery.
+ */
+static int mipv6_ha_ra_rcv(struct sk_buff *skb)
+{
+	int optlen, ha_info_pref = 0, ha_info_lifetime;
+	int ifi = ((struct inet6_skb_parm *)skb->cb)->iif;
+	struct ra_msg *ra = (struct ra_msg *) skb->h.raw;
+	struct in6_addr *saddr = &skb->nh.ipv6h->saddr;
+	struct in6_addr ll_addr;
+	struct hal {
+		struct in6_addr prefix;
+		struct hal *next;
+	};
+	struct hal *ha_queue = NULL;
+	
+	__u8 * opt = (__u8 *)(ra + 1);
+
+	DEBUG_FUNC();
+
+	ha_info_lifetime = ntohs(ra->icmph.icmp6_rt_lifetime);
+	ipv6_addr_copy(&ll_addr, saddr);
+
+	optlen = (skb->tail - (unsigned char *)ra) - sizeof(struct ra_msg);
+
+	while (optlen > 0) {
+		int len = (opt[1] << 3);
+		if (len == 0) 
+			return MIPV6_IGN_RTR;
+		
+		if (opt[0] == ND_OPT_PREFIX_INFO) {
+			struct prefix_info *pinfo;
+
+			if (len < sizeof(struct prefix_info)) 
+				return MIPV6_IGN_RTR;
+
+			pinfo = (struct prefix_info *) opt;
+			if ((ra->icmph.icmp6_home_agent) && pinfo->router_address) {
+				/* If RA has H bit set and Prefix Info
+				 * Option R bit set, queue this
+				 * address to be added to Home Agents
+				 * List.  
+				 */
+				struct hal *tmp;
+				if (ipv6_addr_type(&pinfo->prefix) & IPV6_ADDR_LINKLOCAL)
+					goto nextopt;
+				tmp = kmalloc(sizeof(struct hal), GFP_ATOMIC);
+				if (tmp == NULL) {
+					DEBUG(DBG_ERROR, "Out of memory");
+					return MIPV6_IGN_RTR;
+				}
+				ipv6_addr_copy(&tmp->prefix, &pinfo->prefix);
+				tmp->next = ha_queue;
+				ha_queue = tmp;
+			}
+			goto nextopt;
+		}
+		if (opt[0] == ND_OPT_HOME_AGENT_INFO) {
+			__u16 tmp;
+			tmp = ntohs(*(__u16 *)(opt + 4));
+			ha_info_pref = (tmp & 0x8000) ? -(int)((u16)(~0))^(tmp + 1) : tmp;
+			ha_info_lifetime = ntohs(*(__u16 *)(opt + 6));
+			DEBUG(DBG_DATADUMP,
+			      "received home agent info with preference : %d and lifetime : %d",
+			      ha_info_pref, ha_info_lifetime);
+		}
+	nextopt:
+		optlen -= len;
+		opt += len;
+	}
+	while (ha_queue) {
+		struct hal *tmp = ha_queue->next;
+		if (ha_info_lifetime) {
+			mipv6_halist_add(ifi, &ha_queue->prefix, &ll_addr,
+					 ha_info_pref, ha_info_lifetime);
+		} else {
+			if (mipv6_halist_delete(&ha_queue->prefix) < 0) {
+				DEBUG(DBG_INFO, "Not able to delete %x:%x:%x:%x:%x:%x:%x:%x",
+				      NIPV6ADDR(&ha_queue->prefix));
+			}
+		}
+		kfree(ha_queue);
+		ha_queue = tmp;
+	}
+	return MIPV6_ADD_RTR;
+}
+
+/**********************************************************************
+ *
+ * MIPv6 Module Init / Cleanup
+ *
+ **********************************************************************/
+
+#ifdef CONFIG_SYSCTL
+/* Sysctl table */
+extern int 
+mipv6_max_tnls_sysctl(ctl_table *, int, struct file *, void *, size_t *);
+
+extern int 
+mipv6_min_tnls_sysctl(ctl_table *, int, struct file *, void *, size_t *);
+
+ctl_table mipv6_mobility_table[] = {
+	{NET_IPV6_MOBILITY_DEBUG, "debuglevel", &mipv6_debug, sizeof(int),
+	 0644, NULL, &proc_dointvec},
+	{NET_IPV6_MOBILITY_AUTH, "use_auth", &mipv6_use_auth, sizeof(int),
+	 0644, NULL, &proc_dointvec},
+	{NET_IPV6_MOBILITY_MAX_TNLS, "max_tnls", &mipv6_max_tnls, sizeof(int),
+	 0644, NULL, &mipv6_max_tnls_sysctl},
+	{NET_IPV6_MOBILITY_MIN_TNLS, "min_tnls", &mipv6_min_tnls, sizeof(int),
+	 0644, NULL, &mipv6_min_tnls_sysctl},
+	{0}
+};
+ctl_table mipv6_table[] = {
+	{NET_IPV6_MOBILITY, "mobility", NULL, 0, 0555, mipv6_mobility_table},
+	{0}
+};
+
+static struct ctl_table_header *mipv6_sysctl_header;
+static struct ctl_table mipv6_net_table[];
+static struct ctl_table mipv6_root_table[];
+
+ctl_table mipv6_net_table[] = {
+	{NET_IPV6, "ipv6", NULL, 0, 0555, mipv6_table},
+	{0}
+};
+
+ctl_table mipv6_root_table[] = {
+	{CTL_NET, "net", NULL, 0, 0555, mipv6_net_table},
+	{0}
+};
+#endif /* CONFIG_SYSCTL */
+
+extern void mipv6_rr_init(void);
+
+extern void mipv6_check_dad(struct in6_addr *haddr);
+extern void mipv6_dad_init(void);
+extern void mipv6_dad_exit(void);
+
+/*  Initialize the module  */
+int __init init_module(void)
+{
+	int err = 0;
+
+	printk(KERN_INFO "MIPL Mobile IPv6 for Linux Home Agent %s (%s)\n",
+	       MIPLVERSION, MIPV6VERSION);
+	mipv6_cap = CAP_CN | CAP_HA;
+
+#ifdef CONFIG_IPV6_MOBILITY_DEBUG
+	printk(KERN_INFO "Debug-level: %d\n", mipv6_debug);
+#endif
+
+/* common init */
+	if ((err = mipv6_bcache_init(MIPV6_BCACHE_SIZE)) < 0)
+		goto bcache_fail;
+
+	if ((err = mipv6_stats_init()) < 0)
+		goto stats_fail;
+	mipv6_rr_init();
+
+#ifdef CONFIG_SYSCTL
+	mipv6_sysctl_header = register_sysctl_table(mipv6_root_table, 0);
+#endif
+
+	if ((err = mipv6_mh_common_init()) < 0)
+		goto mh_fail;
+
+	MIPV6_SETCALL(mipv6_modify_txoptions, mipv6_modify_txoptions);
+
+	MIPV6_SETCALL(mipv6_handle_homeaddr, mipv6_handle_homeaddr);
+	MIPV6_SETCALL(mipv6_icmp_handle_homeaddr, mipv6_icmp_handle_homeaddr);
+/* end of common */
+
+	mipv6_initialize_tunnel();
+
+	if ((err = mipv6_ha_init()) < 0)
+		goto ha_fail;
+
+	MIPV6_SETCALL(mipv6_ra_rcv, mipv6_ha_ra_rcv);
+
+	mipv6_dad_init();
+	MIPV6_SETCALL(mipv6_check_dad, mipv6_check_dad);
+	MIPV6_SETCALL(mipv6_pfxs_modified, mipv6_pfxs_modified);
+
+	if ((err = mipv6_halist_init(MIPV6_HALIST_SIZE)) < 0)
+		goto halist_fail;
+
+	mipv6_initialize_pfx_icmpv6();
+
+	if ((err = mipv6_initialize_icmpv6()) < 0)
+		goto icmpv6_fail;
+
+	return 0;
+
+icmpv6_fail:
+	mipv6_shutdown_pfx_icmpv6();
+	mipv6_halist_exit();
+halist_fail:
+	mipv6_dad_exit();
+	mipv6_ha_exit();
+ha_fail:
+	mipv6_shutdown_tunnel();
+	mipv6_invalidate_calls();
+	mipv6_mh_common_exit();
+mh_fail:
+#ifdef CONFIG_SYSCTL
+	unregister_sysctl_table(mipv6_sysctl_header);
+#endif
+	mipv6_stats_exit();
+stats_fail:
+	mipv6_bcache_exit();
+bcache_fail:
+	return err;
+}
+
+/*  Cleanup module  */
+void __exit cleanup_module(void)
+{
+	printk(KERN_INFO "mobile_ip6.o exiting.\n");
+
+	/* Invalidate all custom kernel hooks.  No need to do this
+           separately for all hooks. */
+	mipv6_invalidate_calls();
+	
+	mipv6_halist_exit();
+	mipv6_shutdown_pfx_icmpv6();
+	mipv6_shutdown_icmpv6();
+
+	mipv6_dad_exit();
+	mipv6_ha_exit();
+	mipv6_shutdown_tunnel();
+
+/* common cleanup */
+#ifdef CONFIG_SYSCTL
+	unregister_sysctl_table(mipv6_sysctl_header);
+#endif
+	mipv6_mh_common_exit();
+	mipv6_stats_exit();
+	mipv6_bcache_exit();
+}
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/module_mn.c linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/module_mn.c
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/module_mn.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/module_mn.c	2003-05-18 11:33:53.000000000 +0200
@@ -0,0 +1,381 @@
+/*
+ *	Mobile IPv6 Mobile Node Module
+ *
+ *	Authors:
+ *	Sami Kivisaari          <skivisaa@cc.hut.fi>
+ *	Antti Tuominen          <ajtuomin@tml.hut.fi>
+ *
+ *	$Id$
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/init.h>
+
+#ifdef CONFIG_SYSCTL
+#include <linux/sysctl.h>
+#endif /* CONFIG_SYSCTL */
+
+#include <net/mipglue.h>
+
+int mipv6_debug = 1;
+int mipv6_use_auth = 0;
+
+int mipv6_is_initialized = 0; /* XXX */
+
+#if defined(MODULE) && LINUX_VERSION_CODE > 0x20115
+MODULE_AUTHOR("MIPL Team");
+MODULE_DESCRIPTION("Mobile IPv6");
+MODULE_LICENSE("GPL");
+MODULE_PARM(mipv6_debug, "i");
+#endif
+
+#include "config.h"
+int mipv6_cap = 0;
+
+#define MIPV6_BCACHE_SIZE 128
+#define MIPV6_HALIST_SIZE 128
+
+#include "bcache.h"
+#include "stats.h"
+#include "mobhdr.h"
+#include "tunnel.h"
+#include "mipv6_ioctl.h"
+#include "exthdrs.h"
+#include "mn.h"
+#include "halist.h"
+#include "prefix.h"
+#include "mipv6_icmp.h"
+
+#include "debug.h"
+#include "mdetect.h"
+#include "util.h"
+
+/* 
+ * Called from ndisc.c's router_discovery.
+ */
+
+static int mipv6_mn_ra_rcv(struct sk_buff *skb)
+{
+	int optlen, ha_info_pref = 0, ha_info_lifetime;
+	int ifi = ((struct inet6_skb_parm *)skb->cb)->iif;
+	struct ra_msg *ra = (struct ra_msg *) skb->h.raw;
+	struct in6_addr *saddr = &skb->nh.ipv6h->saddr;
+	struct router nrt;
+	struct hal {
+		struct in6_addr prefix;
+		struct hal *next;
+	};
+	struct hal *ha_queue = NULL;
+
+	__u8 * opt = (__u8 *)(ra + 1);
+
+	DEBUG_FUNC();
+
+	memset(&nrt, 0, sizeof(struct router));
+
+	if (ra->icmph.icmp6_home_agent) {
+		nrt.flags |= ND_RA_FLAG_HA;
+		DEBUG(DBG_DATADUMP, "RA has ND_RA_FLAG_HA up");
+	}
+
+	if (ra->icmph.icmp6_addrconf_managed) {
+		nrt.flags |= ND_RA_FLAG_MANAGED;
+		DEBUG(DBG_DATADUMP, "RA has ND_RA_FLAG_MANAGED up");
+	}
+
+	if (ra->icmph.icmp6_addrconf_other) {
+		nrt.flags |= ND_RA_FLAG_OTHER;
+		DEBUG(DBG_DATADUMP, "RA has ND_RA_FLAG_OTHER up");
+	}
+
+	ha_info_lifetime = nrt.lifetime = 
+		ntohs(ra->icmph.icmp6_rt_lifetime);
+	ipv6_addr_copy(&nrt.ll_addr, saddr);
+	nrt.ifindex = ifi;
+
+	optlen = (skb->tail - (unsigned char *)ra) - sizeof(struct ra_msg);
+
+	while (optlen > 0) {
+		int len = (opt[1] << 3);
+		if (len == 0)
+			return MIPV6_IGN_RTR;
+		
+		if (opt[0] == ND_OPT_PREFIX_INFO) {
+			struct prefix_info *pinfo;
+
+			if (len < sizeof(struct prefix_info)) 
+				return MIPV6_IGN_RTR;
+
+			pinfo = (struct prefix_info *) opt;
+
+			if (!pinfo->autoconf) {
+				/* Autonomous not set according to
+                                 * 2462 5.5.3 (a)
+				 */
+				goto nextopt;
+			}
+
+			if ((nrt.flags & ND_RA_FLAG_HA) && pinfo->router_address) {
+				/* If RA has H bit set and Prefix Info
+				 * Option R bit set, queue this
+				 * address to be added to Home Agents
+				 * List.  
+				 */
+				struct hal *tmp;
+				if (ipv6_addr_type(&pinfo->prefix) & IPV6_ADDR_LINKLOCAL)
+					goto nextopt;
+				tmp = kmalloc(sizeof(struct hal), GFP_ATOMIC);
+				if (tmp == NULL) {
+					DEBUG(DBG_ERROR, "Out of memory");
+					return MIPV6_IGN_RTR;
+				}
+				ipv6_addr_copy(&tmp->prefix, &pinfo->prefix);
+				tmp->next = ha_queue;
+				ha_queue = tmp;
+			}
+
+			/* use first prefix with widest scope */
+			if (ipv6_addr_any(&nrt.raddr) || 
+			    ((ipv6_addr_type(&nrt.raddr) != IPV6_ADDR_UNICAST) &&
+			    (ipv6_addr_type(&pinfo->prefix) == IPV6_ADDR_UNICAST))) {
+				ipv6_addr_copy(&nrt.raddr, &pinfo->prefix);
+				nrt.pfix_len = pinfo->prefix_len;
+				if (pinfo->router_address)
+					nrt.glob_addr = 1;
+				else
+					nrt.glob_addr = 0;
+				DEBUG(DBG_DATADUMP, "Address of the received "
+				      "prefix info option: %x:%x:%x:%x:%x:%x:%x:%x", 
+				      NIPV6ADDR(&nrt.raddr));
+				DEBUG(DBG_DATADUMP, "the length of the prefix is %d", 
+				      nrt.pfix_len);
+			}
+		}
+		if (opt[0] == ND_OPT_SOURCE_LL_ADDR) {
+			nrt.link_addr_len = skb->dev->addr_len;
+			memcpy(nrt.link_addr, opt + 2, nrt.link_addr_len);
+		}
+		if (opt[0] == ND_OPT_RTR_ADV_INTERVAL) {			
+			nrt.interval = ntohl(*(__u32 *)(opt+4));
+			DEBUG(DBG_DATADUMP, 
+			      "received router interval option with interval : %d ",
+			      nrt.interval / HZ);
+			
+			if (nrt.interval > MAX_RADV_INTERVAL) {
+				nrt.interval = 0;
+				DEBUG(DBG_DATADUMP, "but we are using: %d, "
+				      "because interval>MAX_RADV_INTERVAL",
+				      nrt.interval / HZ);
+			}
+		}
+		if (opt[0] == ND_OPT_HOME_AGENT_INFO) {
+			__u16 tmp;
+			tmp = ntohs(*(__u16 *)(opt + 4));
+			ha_info_pref = (tmp & 0x8000) ? -(int)((u16)(~0))^(tmp + 1) : tmp;
+			ha_info_lifetime = ntohs(*(__u16 *)(opt + 6));
+			DEBUG(DBG_DATADUMP,
+			      "received home agent info with preference : %d and lifetime : %d",
+				 ha_info_pref, ha_info_lifetime);
+		}
+	nextopt:
+		optlen -= len;
+		opt += len;
+	}
+	while (ha_queue) {
+		struct hal *tmp = ha_queue->next;
+		if (ha_info_lifetime) {
+			mipv6_halist_add(ifi, &ha_queue->prefix, &nrt.ll_addr,
+					ha_info_pref, ha_info_lifetime);
+		} else {
+			if (mipv6_halist_delete(&ha_queue->prefix) < 0) {
+				DEBUG(DBG_INFO, "mipv6_ra_rcv: Not able "
+				      "to delete %x:%x:%x:%x:%x:%x:%x:%x",
+				      NIPV6ADDR(&ha_queue->prefix));
+			}
+		}
+		kfree(ha_queue);
+		ha_queue = tmp;
+	}
+	return mipv6_router_event(&nrt);
+}
+
+/**********************************************************************
+ *
+ * MIPv6 Module Init / Cleanup
+ *
+ **********************************************************************/
+
+#ifdef CONFIG_SYSCTL
+/* Sysctl table */
+
+extern int max_rtr_reach_time;
+extern int eager_cell_switching;
+
+int max_reach = 1000;
+int min_reach = 1;
+int max_eagercell = 1;
+int min_eagercell = 0;
+
+extern int 
+mipv6_mdetect_mech_sysctl(ctl_table *, int, struct file *, void *, size_t *);
+
+extern int 
+mipv6_router_reach_sysctl(ctl_table *, int, struct file *, void *, size_t *);
+
+extern int 
+mipv6_max_tnls_sysctl(ctl_table *, int, struct file *, void *, size_t *);
+
+extern int 
+mipv6_min_tnls_sysctl(ctl_table *, int, struct file *, void *, size_t *);
+
+
+ctl_table mipv6_mobility_table[] = {
+	{NET_IPV6_MOBILITY_DEBUG, "debuglevel", &mipv6_debug, sizeof(int),
+	 0644, NULL, &proc_dointvec},
+	{NET_IPV6_MOBILITY_AUTH, "use_auth", &mipv6_use_auth, sizeof(int),
+	 0644, NULL, &proc_dointvec},
+
+	{NET_IPV6_MOBILITY_ROUTER_REACH, "max_router_reachable_time",
+	 &max_rtr_reach_time, sizeof(int), 0644, NULL,
+	 &proc_dointvec_minmax, &sysctl_intvec, 0, &min_reach, &max_reach},
+
+	{NET_IPV6_MOBILITY_MDETECT_MECHANISM, "eager_cell_switching",
+	 &eager_cell_switching, sizeof(int), 0644, NULL,
+	 &proc_dointvec_minmax, &sysctl_intvec, 0, &min_eagercell, 
+	 &max_eagercell},
+
+	{NET_IPV6_MOBILITY_MAX_TNLS, "max_tnls", &mipv6_max_tnls, sizeof(int),
+	 0644, NULL, &mipv6_max_tnls_sysctl},
+	{NET_IPV6_MOBILITY_MIN_TNLS, "min_tnls", &mipv6_min_tnls, sizeof(int),
+	 0644, NULL, &mipv6_min_tnls_sysctl},
+	{0}
+};
+ctl_table mipv6_table[] = {
+	{NET_IPV6_MOBILITY, "mobility", NULL, 0, 0555, mipv6_mobility_table},
+	{0}
+};
+
+static struct ctl_table_header *mipv6_sysctl_header;
+static struct ctl_table mipv6_net_table[];
+static struct ctl_table mipv6_root_table[];
+
+ctl_table mipv6_net_table[] = {
+	{NET_IPV6, "ipv6", NULL, 0, 0555, mipv6_table},
+	{0}
+};
+
+ctl_table mipv6_root_table[] = {
+	{CTL_NET, "net", NULL, 0, 0555, mipv6_net_table},
+	{0}
+};
+#endif /* CONFIG_SYSCTL */
+
+extern void mipv6_rr_init(void);
+
+/*  Initialize the module  */
+int __init init_module(void)
+{
+	int err = 0;
+
+	printk(KERN_INFO "MIPL Mobile IPv6 for Linux Mobile Node %s (%s)\n",
+	       MIPLVERSION, MIPV6VERSION);
+	mipv6_cap = CAP_CN | CAP_MN;
+
+#ifdef CONFIG_IPV6_MOBILITY_DEBUG
+	printk(KERN_INFO "Debug-level: %d\n", mipv6_debug);
+#endif
+/* common init */
+	if ((err = mipv6_bcache_init(MIPV6_BCACHE_SIZE)) < 0)
+		goto bcache_fail;
+
+	if ((err = mipv6_stats_init()) < 0)
+		goto stats_fail;
+	mipv6_rr_init();
+
+#ifdef CONFIG_SYSCTL
+	mipv6_sysctl_header = register_sysctl_table(mipv6_root_table, 0);
+#endif
+
+	if ((err = mipv6_mh_common_init()) < 0)
+		goto mh_fail;
+
+	mipv6_mh_mn_init();
+
+	MIPV6_SETCALL(mipv6_modify_txoptions, mipv6_modify_txoptions);
+
+	MIPV6_SETCALL(mipv6_handle_homeaddr, mipv6_handle_homeaddr);
+	MIPV6_SETCALL(mipv6_icmp_handle_homeaddr, mipv6_icmp_handle_homeaddr);
+/* end of common */
+
+	mipv6_initialize_tunnel();
+
+	if ((err = mipv6_mn_init()) < 0)
+		goto mn_fail;
+
+	MIPV6_SETCALL(mipv6_ra_rcv, mipv6_mn_ra_rcv);
+
+	if ((err = mipv6_halist_init(MIPV6_HALIST_SIZE)) < 0)
+		goto halist_fail;
+
+	mipv6_initialize_pfx_icmpv6();
+
+	if ((err = mipv6_initialize_icmpv6()) < 0)
+		goto icmpv6_fail;
+
+	if ((err = mipv6_ioctl_mn_init()) < 0)
+		goto ioctl_fail;
+
+	mipv6_is_initialized = 1;
+
+	return 0;
+
+ioctl_fail:
+	mipv6_shutdown_icmpv6();
+icmpv6_fail:
+	mipv6_shutdown_pfx_icmpv6();
+	mipv6_halist_exit();
+halist_fail:
+	mipv6_mn_exit();
+mn_fail:
+	mipv6_shutdown_tunnel();
+	mipv6_invalidate_calls();
+	mipv6_mh_common_exit();
+mh_fail:
+#ifdef CONFIG_SYSCTL
+	unregister_sysctl_table(mipv6_sysctl_header);
+#endif
+	mipv6_stats_exit();
+stats_fail:
+	mipv6_bcache_exit();
+bcache_fail:
+	return err;
+}
+
+/*  Cleanup module  */
+void __exit cleanup_module(void)
+{
+	printk(KERN_INFO "mobile_ip6.o exiting.\n");
+	mipv6_ioctl_mn_exit();
+	/* Invalidate all custom kernel hooks.  No need to do this
+           separately for all hooks. */
+	mipv6_invalidate_calls();
+	mipv6_halist_exit();
+	mipv6_shutdown_icmpv6();
+	mipv6_shutdown_pfx_icmpv6();
+	mipv6_mn_exit();
+	mipv6_shutdown_tunnel();
+
+/* common cleanup */
+#ifdef CONFIG_SYSCTL
+	unregister_sysctl_table(mipv6_sysctl_header);
+#endif
+	mipv6_mh_common_exit();
+	mipv6_stats_exit();
+	mipv6_bcache_exit();
+}
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/multiaccess_ctl.c linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/multiaccess_ctl.c
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/multiaccess_ctl.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/multiaccess_ctl.c	2003-05-18 11:33:53.000000000 +0200
@@ -0,0 +1,289 @@
+/*  
+ * 2001 (c) Oy L M Ericsson Ab
+ *
+ * Author: NomadicLab / Ericsson Research <ipv6@nomadiclab.com>
+ *
+ * $Id: s.multiaccess_ctl.c 1.12 02/10/08 13:52:57+03:00 antti@traci.mipl.mediapoli.com $
+ *
+ */
+
+/*
+ * Vertical hand-off information manager
+ */
+
+#include <linux/netdevice.h>
+#include <linux/in6.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/proc_fs.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <linux/list.h>
+#include "multiaccess_ctl.h"
+#include "debug.h"
+
+#define TRUE 1
+#define FALSE 0
+/*
+ * Local variables
+ */
+static LIST_HEAD(if_list);
+
+/* Internal interface information list */
+struct ma_if_info {
+	struct list_head list;
+	int        interface_id;
+	int        preference;
+	__u8       status;
+};
+
+/**
+ * ma_ctl_get_preference - get preference value for interface
+ * @ifi: interface index
+ * 
+ * Returns integer value preference for given interface.
+ **/
+int ma_ctl_get_preference(int ifi)
+{
+	struct list_head *lh;
+	struct ma_if_info *info;
+	int pref = 0;
+
+	list_for_each(lh, &if_list) {
+		info = list_entry(lh, struct ma_if_info, list);
+		if (info->interface_id == ifi) {
+			pref = info->preference;
+			return pref;
+		}
+	}
+	return -1;
+}
+/**
+ * ma_ctl_get_preference - get preference value for interface
+ * @ifi: interface index
+ * 
+ * Returns integer value interface index for interface with highest preference.
+ **/
+int ma_ctl_get_preferred_if(void)
+{
+	struct list_head *lh;
+	struct ma_if_info *info, *pref_if = NULL;
+	
+	list_for_each(lh, &if_list) {
+		info = list_entry(lh, struct ma_if_info, list);
+		if (!pref_if || (info->preference > pref_if->preference)) {
+			pref_if = info;
+		}
+	}
+	if (pref_if) return pref_if->interface_id;
+	return 0;
+}
+/**
+ * ma_ctl_set_preference - set preference for interface
+ * @arg: ioctl args
+ *
+ * Sets preference of an existing interface (called by ioctl).
+ **/
+void ma_ctl_set_preference(unsigned long arg)
+{
+	struct list_head *lh;
+	struct ma_if_info *info;
+	struct ma_if_uinfo uinfo;
+	
+	memset(&uinfo, 0, sizeof(struct ma_if_uinfo));
+	if (copy_from_user(&uinfo, (struct ma_if_uinfo *)arg, 
+			   sizeof(struct ma_if_uinfo)) < 0) {
+		DEBUG(DBG_WARNING, "copy_from_user failed");
+		return;
+	}
+
+	/* check if the interface exists */
+	list_for_each(lh, &if_list) {
+		info = list_entry(lh, struct ma_if_info, list);
+		if (info->interface_id == uinfo.interface_id) {
+			info->preference = uinfo.preference;
+			return;
+		}
+	}
+}
+
+/**
+ * ma_ctl_add_iface - add new interface to list
+ * @if_index: interface index
+ *
+ * Adds new interface entry to preference list.  Preference is set to
+ * the same value as @if_index.  Entry @status is set to
+ * %MA_IFACE_NOT_USED.
+ **/
+void ma_ctl_add_iface(int if_index)
+{
+	struct list_head *lh;
+	struct ma_if_info *info;
+
+	DEBUG_FUNC();
+	
+	/* check if the interface already exists */
+	list_for_each(lh, &if_list) {
+		info = list_entry(lh, struct ma_if_info, list);
+		if (info->interface_id == if_index) {
+			info->status = MA_IFACE_NOT_USED;
+			info->preference = if_index;
+			return;
+		}
+	}
+
+	info = kmalloc(sizeof(struct ma_if_info), GFP_ATOMIC);
+	if (info == NULL) {
+		DEBUG(DBG_ERROR, "Out of memory");
+		return;
+	}
+	memset(info, 0, sizeof(struct ma_if_info));
+	info->interface_id = if_index;
+	info->preference = if_index;
+	info->status = MA_IFACE_NOT_USED;
+	list_add(&info->list, &if_list);
+}
+
+/**
+ * ma_ctl_del_iface - remove entry from the list
+ * @if_index: interface index
+ *
+ * Removes entry for interface @if_index from preference list.
+ **/
+int ma_ctl_del_iface(int if_index)
+{
+	struct list_head *lh, *next;
+	struct ma_if_info *info;
+
+	DEBUG_FUNC();
+
+	/* if the iface exists, change availability to 0 */
+	list_for_each_safe(lh, next, &if_list) {
+		info = list_entry(lh, struct ma_if_info, list);
+		if (info->interface_id == if_index) {
+			list_del(&info->list);
+			kfree(info);
+			return 0;
+		}
+	}
+
+	return -1;
+}
+
+/**
+ * ma_ctl_upd_iface - update entry (and list)
+ * @if_index: interface to update
+ * @status: new status for interface
+ * @change_if_index: new interface
+ *
+ * Updates @if_index entry on preference list.  Entry status is set to
+ * @status.  If new @status is %MA_IFACE_CURRENT, updates list to have
+ * only one current device.  If @status is %MA_IFACE_NOT_PRESENT,
+ * entry is deleted and further if entry had %MA_IFACE_CURRENT set,
+ * new current device is looked up and returned in @change_if_index.
+ * New preferred interface is also returned if current device changes
+ * to %MA_IFACE_NOT_USED.  Returns 0 on success, otherwise negative.
+ **/
+int ma_ctl_upd_iface(int if_index, int status, int *change_if_index)
+{
+	struct list_head *lh, *tmp;
+	struct ma_if_info *info, *pref = NULL;
+	int found = 0;
+
+	DEBUG_FUNC();
+
+	*change_if_index = 0;
+
+	/* check if the interface exists */
+	list_for_each_safe(lh, tmp, &if_list) {
+		info = list_entry(lh, struct ma_if_info, list);
+		if (status == MA_IFACE_NOT_PRESENT) {
+			if (info->interface_id == if_index) {
+				list_del_init(&info->list);
+				kfree(info);
+				found = 1;
+				break;
+			}
+		} else if (status == MA_IFACE_CURRENT) {
+			if (info->interface_id == if_index) {
+				info->status |= MA_IFACE_CURRENT;
+				found = 1;
+			} else {
+				info->status |= MA_IFACE_NOT_USED;
+			}
+		} else if (status == MA_IFACE_NOT_USED) {
+			if (info->interface_id == if_index) {
+				if (info->status | MA_IFACE_CURRENT) {
+					found = 1;
+				}
+				info->status &= !MA_IFACE_CURRENT;
+				info->status |= MA_IFACE_NOT_USED;
+				info->status &= !MA_IFACE_HAS_ROUTER;
+			}
+			break;
+		} else if (status == MA_IFACE_HAS_ROUTER) {
+			if (info->interface_id == if_index) {
+				info->status |= MA_IFACE_HAS_ROUTER;
+			}
+			return 0;
+		}
+	}
+
+	if (status & (MA_IFACE_NOT_USED|MA_IFACE_NOT_PRESENT) && found) {
+		/* select new interface */
+		list_for_each(lh, &if_list) {
+			info = list_entry(lh, struct ma_if_info, list);
+			if (pref == NULL || ((info->preference > pref->preference) && 
+					     info->status & MA_IFACE_HAS_ROUTER))
+				pref = info;
+		}
+		if (pref) {
+			*change_if_index = pref->interface_id;
+			pref->status |= MA_IFACE_CURRENT;
+		} else {
+			*change_if_index = -1;
+		}
+		return 0;
+	}
+
+	if (found) return 0;
+
+	return -1;
+}
+
+static int if_proc_info(char *buffer, char **start, off_t offset,
+			int length)
+{
+	struct list_head *lh;
+	struct ma_if_info *info;
+	int len = 0;
+
+	list_for_each(lh, &if_list) {
+		info = list_entry(lh, struct ma_if_info, list);
+		len += sprintf(buffer + len, "%02d %010d %1d %1d\n",
+			       info->interface_id, info->preference,
+			       !!(info->status & MA_IFACE_HAS_ROUTER),
+			       !!(info->status & MA_IFACE_CURRENT));
+	}
+
+	*start = buffer + offset;
+
+	len -= offset;
+
+	if (len > length) len = length;
+
+	return len;
+
+}
+
+void ma_ctl_init(void)
+{
+	proc_net_create("mip6_iface", 0, if_proc_info);
+}
+
+void ma_ctl_clean(void)
+{
+	proc_net_remove("mip6_iface");
+}
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/multiaccess_ctl.h linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/multiaccess_ctl.h
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/multiaccess_ctl.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/multiaccess_ctl.h	2003-05-18 11:33:53.000000000 +0200
@@ -0,0 +1,77 @@
+/*  
+ * 2001 (c) Oy L M Ericsson Ab
+ *
+ * Author: NomadicLab / Ericsson Research <ipv6@nomadiclab.com>
+ *
+ * $Id: s.multiaccess_ctl.h 1.5 02/04/12 18:10:40-00:00 henkku $
+ *
+ */
+
+#ifndef _MULTIACCESS_CTL_H
+#define _MULTIACCESS_CTL_H
+
+/* status */
+#define MA_IFACE_NOT_PRESENT 0x01
+#define MA_IFACE_NOT_USED    0x02
+#define MA_IFACE_HAS_ROUTER  0x04
+#define MA_IFACE_CURRENT     0x10
+
+struct ma_if_uinfo {
+	int        interface_id;
+	int        preference;
+	__u8       status;
+};
+/*
+ *  @ma_ctl_get_preferred_id: returns most preferred interface id
+ */
+int ma_ctl_get_preferred_if(void);
+
+/* @ma_ctl_get_preference: returns preference for an interface
+ * @name: name of the interface (dev->name)
+ */
+int ma_ctl_get_preference(int ifi);
+
+/*
+ * Public function: ma_ctl_set_preference
+ * Description: Set preference of an existing interface (called by ioctl)
+ * Returns:
+ */
+void ma_ctl_set_preference(unsigned long);
+
+/*
+ * Public function: ma_ctl_add_iface
+ * Description: Inform control module to insert a new interface
+ * Returns: 0 if success, any other number means an error
+ */
+void ma_ctl_add_iface(int);
+
+/*
+ * Public function: ma_ctl_del_iface
+ * Description: Inform control module to remove an obsolete interface
+ * Returns: 0 if success, any other number means an error
+ */
+int ma_ctl_del_iface(int);
+
+/*
+ * Public function: ma_ctl_upd_iface
+ * Description: Inform control module of status change.
+ * Returns: 0 if success, any other number means an error
+ */
+int ma_ctl_upd_iface(int, int, int *);
+
+/*
+ * Public function: ma_ctl_init
+ * Description: XXX
+ * Returns: XXX
+ */
+void ma_ctl_init(void);
+
+/*
+ * Public function: ma_ctl_clean
+ * Description: XXX
+ * Returns: -
+ */
+void ma_ctl_clean(void);
+
+
+#endif
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/prefix.c linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/prefix.c
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/prefix.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/prefix.c	2003-05-18 11:33:53.000000000 +0200
@@ -0,0 +1,203 @@
+/**
+ * Prefix solicitation and advertisement
+ *
+ * Authors:
+ * Jaakko Laine <medved@iki.fi>
+ *
+ * $Id: s.prefix.c 1.24 02/11/25 11:18:16+02:00 vnuorval@amber.hut.mediapoli.com $
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/config.h>
+#include <linux/icmpv6.h>
+#include <linux/net.h>
+#include <linux/spinlock.h>
+#include <linux/timer.h>
+#include <linux/netdevice.h>
+#include <net/ipv6.h>
+#include <net/addrconf.h>
+#include <net/ip6_route.h>
+#include <net/mipv6.h>
+
+#include "mipv6_icmp.h"
+#include "debug.h"
+#include "sortedlist.h"
+#include "util.h"
+#include "mn.h"
+#include "ha.h"
+#include "bcache.h"
+#include "mdetect.h"
+#include "config.h"
+
+#define INFINITY 0xffffffff
+
+struct timer_list pfx_timer;
+
+struct list_head pfx_list;
+rwlock_t pfx_list_lock = RW_LOCK_UNLOCKED;
+
+int compare_pfx_list_entry(const void *data1, const void *data2,
+			   int datalen)
+{
+	struct pfx_list_entry *e1 = (struct pfx_list_entry *) data1;
+	struct pfx_list_entry *e2 = (struct pfx_list_entry *) data2;
+
+	return ((ipv6_addr_cmp(&e1->daddr, &e2->daddr) == 0)
+		&& (e2->ifindex == -1 || e1->ifindex == e2->ifindex));
+}
+
+/**
+ * mipv6_pfx_cancel_send - cancel pending items to daddr from saddr
+ * @daddr: Destination address
+ * @ifindex: pending items on this interface will be canceled
+ *
+ * if ifindex == -1, all items to daddr will be removed
+ */
+void mipv6_pfx_cancel_send(struct in6_addr *daddr, int ifindex)
+{
+	unsigned long tmp;
+	struct pfx_list_entry entry;
+
+	DEBUG_FUNC();
+
+	/* We'll just be comparing these parts... */
+	memcpy(&entry.daddr, daddr, sizeof(struct in6_addr));
+	entry.ifindex = ifindex;
+
+	write_lock_bh(&pfx_list_lock);
+
+	while (mipv6_slist_del_item(&pfx_list, &entry,
+				    compare_pfx_list_entry) == 0)
+		;
+
+	if ((tmp = mipv6_slist_get_first_key(&pfx_list)))
+		mod_timer(&pfx_timer, tmp);
+
+	write_unlock_bh(&pfx_list_lock);
+}
+
+/**
+ * mipv6_pfx_add_ha - add a new HA to send prefix solicitations to
+ * @daddr: address of HA
+ * @saddr: our address to use as source address
+ * @ifindex: interface index
+ */
+void mipv6_pfx_add_ha(struct in6_addr *daddr, struct in6_addr *saddr,
+		      int ifindex)
+{
+	unsigned long tmp;
+	struct pfx_list_entry entry;
+
+	DEBUG_FUNC();
+
+	memcpy(&entry.daddr, daddr, sizeof(struct in6_addr));
+	memcpy(&entry.saddr, saddr, sizeof(struct in6_addr));
+	entry.retries = 0;
+	entry.ifindex = ifindex;
+
+	write_lock_bh(&pfx_list_lock);
+	if (mipv6_slist_modify(&pfx_list, &entry, sizeof(struct pfx_list_entry),
+			       jiffies + INITIAL_SOLICIT_TIMER * HZ,
+			       compare_pfx_list_entry))
+		DEBUG(DBG_WARNING, "Cannot add new HA to pfx list");
+
+	if ((tmp = mipv6_slist_get_first_key(&pfx_list)))
+		mod_timer(&pfx_timer, tmp);
+	write_unlock_bh(&pfx_list_lock);
+}
+
+int mipv6_pfx_add_home(int ifindex, struct in6_addr *saddr, 
+		       struct in6_addr *daddr, unsigned long min_expire)
+{
+	unsigned long tmp;
+
+	write_lock(&pfx_list_lock);
+
+	if (min_expire != INFINITY) {
+		unsigned long expire;
+		struct pfx_list_entry entry;
+		
+		memcpy(&entry.daddr, saddr, sizeof(struct in6_addr));
+		memcpy(&entry.saddr, daddr, sizeof(struct in6_addr));
+		entry.retries = 0;
+		entry.ifindex = ifindex;
+
+		/* This is against the draft, but we need to set
+		 * a minimum interval for a prefix solicitation.
+		 * Otherwise a prefix solicitation storm will
+		 * result if valid lifetime of the prefix is
+		 * smaller than MAX_PFX_ADV_DELAY
+		 */
+		min_expire -= MAX_PFX_ADV_DELAY;
+		min_expire = min_expire < MIN_PFX_SOL_DELAY ? MIN_PFX_SOL_DELAY : min_expire;
+
+		expire = jiffies + min_expire * HZ;
+
+		if (mipv6_slist_modify(&pfx_list, &entry,
+				       sizeof(struct pfx_list_entry),
+				       expire,
+				       compare_pfx_list_entry) != 0)
+			DEBUG(DBG_WARNING, "Cannot add new entry to pfx_list");
+	}
+
+	if ((tmp = mipv6_slist_get_first_key(&pfx_list)))
+		mod_timer(&pfx_timer, tmp);
+
+	write_unlock(&pfx_list_lock);
+
+	return 0;
+}
+
+/**
+ * pfx_timer_handler - general timer handler
+ * @dummy: dummy
+ *
+ * calls set_ha_pfx_list and set_mn_pfx_list to do the thing when
+ * a timer goes off
+ */
+static void pfx_timer_handler(unsigned long dummy)
+{
+	unsigned long tmp;
+	struct pfx_list_entry *entry;
+
+	DEBUG_FUNC();
+
+	write_lock(&pfx_list_lock);
+	if (!(entry = mipv6_slist_get_first(&pfx_list)))
+		goto out;
+
+	set_ha_pfx_list(entry);
+	set_mn_pfx_list(entry);
+	if ((tmp = mipv6_slist_get_first_key(&pfx_list)))
+		mod_timer(&pfx_timer, tmp);
+
+ out:
+	write_unlock(&pfx_list_lock);
+}
+
+int mipv6_initialize_pfx_icmpv6(void)
+{
+	INIT_LIST_HEAD(&pfx_list);
+
+	init_timer(&pfx_timer);
+	pfx_timer.function = pfx_timer_handler;
+
+	return 0;
+}
+
+void mipv6_shutdown_pfx_icmpv6(void)
+{
+	struct prefix_info *tmp;
+
+	if (timer_pending(&pfx_timer))
+		del_timer(&pfx_timer);
+
+	write_lock_bh(&pfx_list_lock);
+	while ((tmp = mipv6_slist_del_first(&pfx_list)))
+		kfree(tmp);
+	write_unlock_bh(&pfx_list_lock);
+}
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/prefix.h linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/prefix.h
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/prefix.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/prefix.h	2003-05-18 11:33:53.000000000 +0200
@@ -0,0 +1,60 @@
+/**
+ * Prefix solicitation and advertisement
+ *
+ * Authors:
+ * Jaakko Laine <medved@iki.fi>
+ *
+ * $Id: s.prefix.h 1.8 02/11/25 11:18:16+02:00 vnuorval@amber.hut.mediapoli.com $
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#ifndef _PREFIX_H
+#define _PREFIX_H
+
+#include <net/addrconf.h>
+
+struct pfx_list_entry {
+	struct in6_addr daddr;
+	struct in6_addr saddr;
+	int retries;
+	int ifindex;
+};
+
+extern struct list_head pfx_list;
+extern rwlock_t pfx_list_lock;
+extern struct timer_list pfx_timer;
+
+int compare_pfx_list_entry(const void *data1, const void *data2,
+			   int datalen);
+
+/**
+ * mipv6_pfx_cancel_send - cancel pending pfx_advs/sols to daddr
+ * @daddr: destination address
+ * @ifindex: pending items on this interface will be canceled
+ *
+ * if ifindex == -1, all items to daddr will be removed
+ */
+void mipv6_pfx_cancel_send(struct in6_addr *daddr, int ifindex);
+
+/**
+ * mipv6_pfx_add_ha - add a new HA to send prefix solicitations to
+ * @daddr: address of HA
+ * @saddr: our address to use as source address
+ * @ifindex: interface index
+ */
+void mipv6_pfx_add_ha(struct in6_addr *daddr, struct in6_addr *saddr,
+		      int ifindex);
+
+void mipv6_pfxs_modified(struct prefix_info *pinfo, int ifindex);
+
+int mipv6_pfx_add_home(int ifindex, struct in6_addr *daddr,
+		       struct in6_addr *saddr, unsigned long min_expire);
+
+int mipv6_initialize_pfx_icmpv6(void);
+void mipv6_shutdown_pfx_icmpv6(void);
+
+#endif
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/prefix_ha.c linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/prefix_ha.c
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/prefix_ha.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/prefix_ha.c	2003-05-18 11:33:53.000000000 +0200
@@ -0,0 +1,124 @@
+/**
+ * Prefix advertisement for Home Agent
+ *
+ * Authors:
+ * Jaakko Laine <medved@iki.fi>
+ *
+ * $Id$
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/config.h>
+#include <linux/icmpv6.h>
+#include <linux/net.h>
+#include <linux/spinlock.h>
+#include <linux/timer.h>
+#include <linux/netdevice.h>
+#include <net/ipv6.h>
+#include <net/addrconf.h>
+#include <net/ip6_route.h>
+#include <net/mipv6.h>
+
+#include "mipv6_icmp.h"
+#include "debug.h"
+#include "sortedlist.h"
+#include "util.h"
+#include "bcache.h"
+#include "mdetect.h"
+#include "config.h"
+#include "prefix.h"
+
+/**
+ * pfx_adv_iterator - modify pfx_list entries according to new prefix info
+ * @data: MN's home registration bcache_entry
+ * @args: new prefix info
+ * @sortkey: ignored
+ */
+static int pfx_adv_iterator(void *data, void *args, unsigned long sortkey)
+{
+	struct mipv6_bcache_entry *bc_entry =
+		(struct mipv6_bcache_entry *) data;
+	struct prefix_info *pinfo = (struct prefix_info *) args;
+
+	if (mipv6_prefix_compare(&bc_entry->coa, &pinfo->prefix,
+				 pinfo->prefix_len) == 0) {
+		struct pfx_list_entry pfx_entry;
+
+		memcpy(&pfx_entry.daddr, &bc_entry->coa,
+		       sizeof(struct in6_addr));
+		memcpy(&pfx_entry.daddr, &bc_entry->our_addr,
+		       sizeof(struct in6_addr));
+		pfx_entry.retries = 0;
+		pfx_entry.ifindex = bc_entry->ifindex;
+
+		mipv6_slist_modify(&pfx_list, &pfx_entry,
+				   sizeof(struct pfx_list_entry),
+				   jiffies +
+				   net_random() % (MAX_PFX_ADV_DELAY * HZ),
+				   compare_pfx_list_entry);
+	}
+
+	return 0;
+}
+
+struct homereg_iterator_args {
+	struct list_head *head;
+	int count;
+};
+
+static int homereg_iterator(void *data, void *args, unsigned long *sortkey)
+{
+	struct mipv6_bcache_entry *entry = (struct mipv6_bcache_entry *) data;
+	struct homereg_iterator_args *state =
+		(struct homereg_iterator_args *) args;
+
+	if (entry->type == HOME_REGISTRATION) {
+		mipv6_slist_add(state->head, entry,
+				sizeof(struct mipv6_bcache_entry),
+				state->count);
+		state->count++;
+	}
+	return 0;
+}
+
+static int mipv6_bcache_get_homeregs(struct list_head *head)
+{
+	struct homereg_iterator_args args;
+
+	DEBUG_FUNC();
+
+	args.count = 0;
+	args.head = head;
+
+	mipv6_bcache_iterate(homereg_iterator, &args);
+	return args.count;
+}
+
+/**
+ * mipv6_prefix_added - prefix was added to interface, act accordingly
+ * @pinfo: prefix_info that was added
+ * @ifindex: interface index
+ */
+void mipv6_pfxs_modified(struct prefix_info *pinfo, int ifindex)
+{
+	int count;
+	unsigned long tmp;
+	struct list_head home_regs;
+
+	DEBUG_FUNC();
+
+	INIT_LIST_HEAD(&home_regs);
+
+	if (!(count = mipv6_bcache_get_homeregs(&home_regs)))
+		return;
+
+	write_lock_bh(&pfx_list_lock);
+	mipv6_slist_for_each(&home_regs, pinfo, pfx_adv_iterator);
+	if ((tmp = mipv6_slist_get_first_key(&pfx_list)))
+		mod_timer(&pfx_timer, tmp);
+	write_unlock_bh(&pfx_list_lock);
+}
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/rr_crypto.c linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/rr_crypto.c
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/rr_crypto.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/rr_crypto.c	2003-05-18 11:33:53.000000000 +0200
@@ -0,0 +1,270 @@
+/*
+ *      rr_cookie.c - Mobile IPv6 return routability crypto  
+ *      Author :  Henrik Petander <henrik.petander@hut.fi>
+ * 
+ *      $Id$
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ *
+ *
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/spinlock.h>
+#include <linux/sched.h>
+#include <linux/timer.h>
+#include <linux/in6.h>
+#include <linux/init.h>
+#include <linux/random.h>
+
+#include <net/ipv6.h>
+
+#include "debug.h"
+#include "hmac.h"
+#include "rr_crypto.h"
+
+#define DBG_RR 5
+
+u8 k_CN[HMAC_SHA1_KEY_SIZE]; // secret key of CN 
+
+u16 curr_index = 0;
+
+struct nonce_timestamp nonce_table[MAX_NONCES];
+spinlock_t nonce_lock = SPIN_LOCK_UNLOCKED;
+void update_nonces(void);
+
+/** nonce_is_fresh - whether the nonce was generated recently
+ *  
+ * @non_ts : table entry containing the nonce and a timestamp
+ * @interval : if nonce was generated within interval seconds it is fresh
+ *
+ * Returns 1 if the nonce is fresh, 0 otherwise.
+ */
+static int nonce_is_fresh(struct nonce_timestamp *non_ts, unsigned long interval)
+{
+	if (time_before(jiffies, non_ts->timestamp + interval * HZ))
+		return 1;
+	return 0;
+}
+
+/* Returns a pointer to a new nonce  */
+struct mipv6_rr_nonce * mipv6_rr_get_new_nonce(void)
+{
+	struct mipv6_rr_nonce *nce = kmalloc(sizeof(*nce), GFP_ATOMIC);
+
+	if (!nce)
+		return NULL;
+	// Lock nonces here
+	spin_lock_bh(&nonce_lock);
+	// If nonce is not fresh create new one 
+	if (!nonce_is_fresh(&nonce_table[curr_index], MIPV6_RR_NONCE_LIFETIME)) {
+		// increment the last nonce pointer and create new nonce
+		curr_index++;
+		// Wrap around
+		if (curr_index == MAX_NONCES)
+			curr_index = 0;
+		// Get random data to fill the nonce data
+		get_random_bytes(nonce_table[curr_index].nonce.data, MIPV6_RR_NONCE_DATA_LENGTH);
+		// Fill the index field
+		nonce_table[curr_index].nonce.index = curr_index;
+		nonce_table[curr_index].timestamp = jiffies;
+	}
+	spin_unlock_bh(&nonce_lock);
+	memcpy(nce, &nonce_table[curr_index].nonce, sizeof(*nce));
+	// Unlock nonces
+	return nce;
+}
+/** mipv6_rr_nonce_get_by_index - returns a nonce for index 
+ * @nonce_ind : index of the nonce
+ *
+ * Returns a nonce or NULL if the nonce index was invalid or the nonce 
+ * for the index was not fresh.
+ */
+struct mipv6_rr_nonce * mipv6_rr_nonce_get_by_index(u16 nonce_ind)
+{
+	struct mipv6_rr_nonce *nce = NULL;
+	
+	spin_lock_bh(&nonce_lock);
+	if (nonce_ind >= MAX_NONCES) {
+		DEBUG(DBG_WARNING, "Nonce index field from BU invalid");
+
+		/* Here a double of the nonce_lifetime is used for freshness 
+		 * verification, since the nonces 
+		 * are not created in response to every initiator packet
+		 */
+	} else if (nonce_is_fresh(&nonce_table[nonce_ind], 2 * MIPV6_RR_NONCE_LIFETIME)) {
+		nce = kmalloc(sizeof(*nce), GFP_ATOMIC);
+		memcpy(nce, &nonce_table[nonce_ind].nonce, sizeof(*nce));
+	}
+	spin_unlock_bh(&nonce_lock);
+
+	return nce;
+}
+
+/* Fills rr test init cookies with random bytes */  
+void mipv6_rr_mn_cookie_create(u8 *cookie)
+{
+	get_random_bytes(cookie, MIPV6_RR_COOKIE_LENGTH);
+}
+
+/** mipv6_rr_cookie_create - builds a home or care-of cookie
+ * 
+ * @addr : the home or care-of address from HoTI or CoTI
+ * @ckie : memory where the cookie is copied to
+ * @nce : pointer to a nonce used for the calculation, nce is freed during the function
+ *
+ */
+int mipv6_rr_cookie_create(struct in6_addr *addr, u8 **ckie,
+	       	u16 nonce_index)
+{
+	struct ah_processing ah_proc;
+	u8 digest[HMAC_SHA1_HASH_LEN];
+	struct mipv6_rr_nonce *nce;
+
+	if ((nce = mipv6_rr_nonce_get_by_index(nonce_index))== NULL)
+		return -1;
+
+	if (*ckie == NULL && (*ckie = kmalloc(MIPV6_RR_COOKIE_LENGTH,
+				       	GFP_ATOMIC)) == NULL) {
+		kfree(nce);
+		return -1;
+	}
+	/* Calculate the full hmac-sha1 digest from address and nonce using the secret key of cn */
+	
+	if (ah_hmac_sha1_init(&ah_proc, k_CN, HMAC_SHA1_KEY_SIZE) < 0) {
+		DEBUG(DBG_ERROR, "Hmac sha1 initialization failed");
+		kfree(nce);
+		return -1;
+	}
+
+	ah_hmac_sha1_loop(&ah_proc, addr, sizeof(*addr));
+	ah_hmac_sha1_loop(&ah_proc, nce->data,  MIPV6_RR_NONCE_DATA_LENGTH);
+	ah_hmac_sha1_result(&ah_proc, digest);
+
+	
+	/* clean up nonce */
+	kfree(nce);
+
+	/* Copy first 64 bits of hash target to the cookie */ 
+	memcpy(*ckie, digest, MIPV6_RR_COOKIE_LENGTH);
+	return 0;
+}
+
+/** mipv6_rr_key_calc - creates BU authentication key
+ * 
+ * @hoc : Home Cookie 
+ * @coc : Care-of Cookie 
+ * 
+ * Returns BU authentication key of length HMAC_SHA1_KEY_SIZE  or NULL in error cases, 
+ * caller needs to free the key.
+ */
+u8 *mipv6_rr_key_calc(u8 *hoc, u8 *coc)
+{
+	
+	u8 *key_bu = kmalloc(HMAC_SHA1_KEY_SIZE, GFP_ATOMIC);
+	SHA1_CTX c;
+
+	if (!key_bu) {
+		DEBUG(DBG_CRITICAL, "Memory allocation failed, could nort create BU authentication key");
+		return NULL;
+	}
+
+	/* Calculate the key from home and care-of cookies 
+	 * Kbu = sha1(home_cookie | care-of cookie) 
+	 * or KBu = sha1(home_cookie), if MN deregisters
+	 */
+	sha1_init(&c);
+	sha1_compute(&c, hoc, MIPV6_RR_COOKIE_LENGTH);
+	if (coc)
+		sha1_compute(&c, coc, MIPV6_RR_COOKIE_LENGTH);
+	sha1_final(&c, key_bu);
+	DEBUG(DBG_RR, "Home and Care-of cookies used for calculating key ");
+	debug_print_buffer(DBG_RR, hoc,  MIPV6_RR_COOKIE_LENGTH);
+	if (coc)	
+		debug_print_buffer(DBG_RR, coc,  MIPV6_RR_COOKIE_LENGTH);
+
+	return key_bu;
+}
+
+/* CN function for calculating the key for authenticating the BU, 
+ *  caller needs to free the key. 
+ *
+ */
+u8 *mipv6_rr_get_bu_key(struct in6_addr *homeaddr, struct in6_addr *coaddr, 
+			      u16 home_nonce_index, u16 coa_nonce_index)
+{
+	u8 *home_ckie = NULL, *coa_ckie = NULL;
+	
+	/* Calculate the key from home and care-of cookies 
+	 * Kbu = sha1(home_cookie | care-of cookie)
+	 * Or Kbu = sha1(home_cookie), if MN deregistered
+	 */
+	if (mipv6_rr_cookie_create(homeaddr, &home_ckie, home_nonce_index) 
+	    || (coaddr && mipv6_rr_cookie_create(coaddr, &coa_ckie, coa_nonce_index)))
+		return NULL;
+	DEBUG(DBG_RR, "Home and Care-of cookies used for calculating key ");
+	debug_print_buffer(DBG_RR, home_ckie,  MIPV6_RR_COOKIE_LENGTH);
+	if (coa_ckie)	
+		debug_print_buffer(DBG_RR, coa_ckie,  MIPV6_RR_COOKIE_LENGTH);
+
+	return mipv6_rr_key_calc(home_ckie, coa_ckie);
+
+}
+
+void mipv6_rr_init(void)
+{
+	get_random_bytes(k_CN, HMAC_SHA1_KEY_SIZE);
+	memset(nonce_table, 0, MAX_NONCES * sizeof(struct nonce_timestamp));
+}
+
+#ifdef TEST_MIPV6_RR_CRYPTO
+void mipv6_test_rr(void)
+{
+	struct mipv6_rr_nonce *nonce;
+	struct in6_addr a1, a2;
+	int ind1, ind2;
+	u8 *ckie1 = NULL, *ckie2 = NULL;
+	u8 *key_mn = NULL, *key_cn = NULL;
+	mipv6_init_rr();
+
+	nonce = mipv6_rr_get_new_nonce();
+	if (!nonce) {
+		printk("mipv6_rr_get_new_nonce() failed, at 1! \n");
+		return;
+	}
+	mipv6_rr_cookie_create(&a1, &ckie1, nonce->index);
+	ind1 = nonce->index;
+	kfree(nonce);
+
+	nonce = mipv6_rr_get_new_nonce();
+	if (!nonce) {
+		printk("mipv6_rr_get_new_nonce() failed, at 2! \n");
+		return;
+	}
+
+	mipv6_rr_cookie_create(&a2, &ckie2, nonce->index); 
+	ind2 = nonce->index;
+	key_mn =  mipv6_rr_key_calc(ckie1, ckie2);
+
+	/* Create home and coa cookies based on indices */
+	mipv6_rr_cookie_create(&a1, &ckie1, ind1);
+	mipv6_rr_cookie_create(&a2, &ckie2, ind2);
+	key_cn =  mipv6_rr_key_calc(ckie1, ckie2);	       
+	if (!key_cn || !key_mn) {
+		printk("creation of secret key failed!\n");
+		return;
+	}
+	if(memcmp(key_cn, key_mn, HMAC_SHA1_KEY_SIZE))
+		printk("mipv6_rr_key_calc produced different keys for MN and CN \n");
+	else
+		printk("mipv6_rr_crypto test OK\n");
+	kfree(nonce);
+	kfree(key_cn);
+	kfree(key_mn);
+}
+#endif
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/rr_crypto.h linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/rr_crypto.h
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/rr_crypto.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/rr_crypto.h	2003-05-18 11:33:53.000000000 +0200
@@ -0,0 +1,84 @@
+/**
+ * Return routability crypto routines
+ *
+ * Authors:
+ * Henrik Petander <henrik.petander@hut.fi>
+ *
+ * $Id:$
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#ifndef _RR_CRYPTO
+#define _RR_CRYPTO
+
+#include <linux/in6.h>
+
+/* Macros and data structures */
+
+#define MIPV6_RR_NONCE_LIFETIME 60 
+#define MIPV6_RR_NONCE_DATA_LENGTH 8
+#define MIPV6_RR_COOKIE_LENGTH 8
+#define COOKIE_SIZE 8
+#define MAX_NONCES 4
+#define HMAC_SHA1_KEY_SIZE 20
+ 
+struct mipv6_rr_nonce {
+	u_int16_t index;
+	u_int8_t data[MIPV6_RR_NONCE_DATA_LENGTH];
+};
+
+struct nonce_timestamp {
+	struct  mipv6_rr_nonce nonce;
+	unsigned long timestamp;
+};
+
+/* Function definitions */
+
+/* Return 1 if equal, 0 if not */
+static __inline__ int mipv6_equal_cookies(u8 *c1, u8 *c2)
+{
+	return (memcmp(c1, c2, MIPV6_RR_COOKIE_LENGTH) == 0);
+}
+
+/* Function declarations */
+
+/* Create cookie for HoTi and CoTi */
+extern void mipv6_rr_mn_cookie_create(u8 *cookie);
+
+/* Create cookie for HoT and CoT */
+extern int mipv6_rr_cookie_create(struct in6_addr *addr, u8 **ckie, u16 nonce_index);
+
+/* Calculate return routability key from home and care-of cookies, key length is 
+ *  HMAC_SHA1_KEY_SIZE  
+ */
+extern u_int8_t *mipv6_rr_key_calc(u8 *hoc, u8 *coc);
+
+/* Function for calculating the key for authenticating the BU in CN based on the 
+ *  fields of a BU, key length is HMAC_SHA1_KEY_SIZE 
+ */
+extern u_int8_t *mipv6_rr_get_bu_key(struct in6_addr *homeaddr,
+				     struct in6_addr *coaddr,
+				     u16 home_nonce_index,
+				     u16 coa_nonce_index);
+
+extern struct mipv6_rr_nonce *mipv6_rr_get_new_nonce(void);
+
+extern struct mipv6_rr_nonce *mipv6_rr_nonce_get_by_index(u16 nonce_ind);
+
+extern int mipv6_equal_cookies(u8 *c1, u8 *c2);
+
+/*
+ * initializes the return routability crypto
+ */
+
+void mipv6_rr_init(void);
+
+#ifdef TEST_MIPV6_RR_CRYPTO
+void mipv6_test_rr(void);
+#endif /* TEST_MIPV6_RR_CRYPTO */
+
+#endif /* RR_CRYPTO */
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/sortedlist.c linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/sortedlist.c
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/sortedlist.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/sortedlist.c	2003-05-18 11:33:53.000000000 +0200
@@ -0,0 +1,349 @@
+/**
+ * Sorted list - linked list with sortkey.
+ *
+ * Authors:
+ * Jaakko Laine <medved@iki.fi>
+ *
+ * $Id: s.sortedlist.c 1.10 02/10/18 16:34:09+03:00 vnuorval@eric.hut.mediapoli.com $
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/list.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/string.h>
+
+struct mipv6_sorted_list_entry {
+	struct list_head list;
+	void *data;
+	int datalen;
+	unsigned long sortkey;
+};
+
+/**
+ * compare - compares two arbitrary data items
+ * @data1: first data item
+ * @data2: second data item
+ * @datalen: length of data items in bits
+ *
+ * datalen is in bits!
+ */
+int mipv6_bitwise_compare(const void *data1, const void *data2, int datalen)
+{
+	int n = datalen;
+	__u8 * ptr1 = (__u8 *)data1;
+	__u8 * ptr2 = (__u8 *)data2;
+	
+	for (; n>=0; n-=8, ptr1++, ptr2++) {
+		if (n >= 8) {
+			if (*ptr1 != *ptr2)
+				return 0;
+		} else {
+			if ((*ptr1 ^ *ptr2) & ((~0) << (8 - n)))
+				return 0;
+		}
+	}
+
+	return 1;
+}
+
+/**
+ * mipv6_slist_add - add an entry to sorted list
+ * @head: list_head of the sorted list
+ * @data: item to store
+ * @datalen: length of data (in bytes)
+ * @key: sortkey of item
+ *
+ * Allocates memory for entry and data
+ */
+int mipv6_slist_add(struct list_head *head, void *data, int datalen,
+		    unsigned long sortkey)
+{
+	struct list_head *pos;
+	struct mipv6_sorted_list_entry *entry, *tmp, *next;
+
+	entry = kmalloc(sizeof(struct mipv6_sorted_list_entry), GFP_ATOMIC);
+
+	if (!entry)
+		return -1;
+
+	entry->data = kmalloc(datalen, GFP_ATOMIC);
+
+	if (!entry->data) {
+		kfree(entry);
+		return -1;
+	}
+
+	memcpy(entry->data, data, datalen);
+	entry->datalen = datalen;
+	entry->sortkey = sortkey;
+
+	if ((pos = head->next) == head) {
+		list_add(&entry->list, head);
+		return 0;
+	}
+
+	tmp = list_entry(pos, struct mipv6_sorted_list_entry, list);
+	if (entry->sortkey < tmp->sortkey) {
+		list_add(&entry->list, head);
+		return 0;
+	}
+
+	for (; pos != head; pos = pos->next) {
+		tmp = list_entry(pos, struct mipv6_sorted_list_entry, list);
+		if (pos->next == head) {
+			list_add(&entry->list, &tmp->list);
+			return 0;
+		}
+		next = list_entry(pos->next, struct mipv6_sorted_list_entry, list);
+		if (entry->sortkey >= tmp->sortkey && entry->sortkey < next->sortkey) {
+			list_add(&entry->list, &tmp->list);
+			return 0;
+		}
+	}
+
+	/* never reached */
+	return -1;
+}
+
+/**
+ * mipv6_slist_get_first - get the first data item in the list
+ * @head: list_head of the sorted list
+ *
+ * Returns the actual data item, not copy, so don't kfree it
+ */
+void *mipv6_slist_get_first(struct list_head *head)
+{
+	struct mipv6_sorted_list_entry *entry;
+
+	if (list_empty(head))
+		return NULL;
+
+	entry = list_entry(head->next, struct mipv6_sorted_list_entry, list);
+	return entry->data;
+}
+
+/**
+ * mipv6_slist_del_first - delete (and get) the first item in list
+ * @head: list_head of the sorted list
+ *
+ * Remember to kfree the item
+ */
+void *mipv6_slist_del_first(struct list_head *head)
+{
+	void *tmp;
+	struct mipv6_sorted_list_entry *entry;
+
+	if (list_empty(head))
+		return NULL;
+
+	entry = list_entry(head->next, struct mipv6_sorted_list_entry, list);
+	tmp = entry->data;
+
+	list_del(head->next);
+	kfree(entry);
+
+	return tmp;
+}
+
+/**
+ * mipv6_slist_del_item - delete entry
+ * @head: list_head of the sorted list
+ * @data: item to delete
+ * @compare: function used for comparing the data items
+ *
+ * compare function needs to have prototype
+ * int (*compare)(const void *data1, const void *data2, int datalen)
+ */
+int mipv6_slist_del_item(struct list_head *head, void *data,
+			 int (*compare)(const void *data1, const void *data2,
+					int datalen))
+{
+	struct list_head *pos;
+	struct mipv6_sorted_list_entry *entry;
+
+	for(pos = head->next; pos != head; pos = pos->next) {
+		entry = list_entry(pos, struct mipv6_sorted_list_entry, list);
+		if (compare(data, entry->data, entry->datalen)) {
+			list_del(pos);
+			kfree(entry->data);
+			kfree(entry);
+			return 0;
+		}
+	}
+
+	return -1;
+}
+
+/**
+ * mipv6_slist_get_first_key - get sortkey of the first item
+ * @head: list_head of the sorted list
+ */
+unsigned long mipv6_slist_get_first_key(struct list_head *head)
+{
+	struct mipv6_sorted_list_entry *entry;
+
+	if (list_empty(head))
+		return 0;
+
+	entry = list_entry(head->next, struct mipv6_sorted_list_entry, list);
+	return entry->sortkey;
+}
+
+/**
+ * mipv6_slist_get_key - get sortkey of the data item
+ * @head: list_head of the sorted list
+ * @data: the item to search for
+ * @compare: function used for comparing the data items
+ *
+ * compare function needs to have prototype
+ * int (*compare)(const void *data1, const void *data2, int datalen)
+ */
+unsigned long mipv6_slist_get_key(struct list_head *head, void *data,
+				  int (*compare)(const void *data1,
+						 const void *data2,
+						 int datalen))
+{
+	struct list_head *pos;
+	struct mipv6_sorted_list_entry *entry;
+	
+	for(pos = head->next; pos != head; pos = pos->next) {
+		entry = list_entry(pos, struct mipv6_sorted_list_entry, list);
+		if (compare(data, entry->data, entry->datalen))
+			return entry->sortkey;
+	}
+	
+	return 0;
+}
+
+/**
+ * mipv6_slist_get_data - get the data item identified by sortkey
+ * @head: list_head of the sorted list
+ * @key: sortkey of the item
+ *
+ * Returns the actual data item, not copy, so don't kfree it
+ */
+void *mipv6_slist_get_data(struct list_head *head, unsigned long sortkey)
+{
+	struct list_head *pos;
+	struct mipv6_sorted_list_entry *entry;
+
+	list_for_each(pos, head) {
+		entry = list_entry(pos, struct mipv6_sorted_list_entry, list);
+		if (entry->sortkey == sortkey) 
+			return entry->data;
+	}
+
+	return NULL;
+}
+
+/**
+ * reorder_entry - move an entry to a new position according to sortkey
+ * @head: list_head of the sorted list
+ * @entry_pos: current place of the entry
+ * @key: new sortkey
+ */
+static void reorder_entry(struct list_head *head, struct list_head *entry_pos,
+			  unsigned long sortkey)
+{
+	struct list_head *pos;
+	struct mipv6_sorted_list_entry *entry;
+
+	list_del(entry_pos);
+
+	for (pos = head->next; pos != head; pos = pos->next) {
+		entry = list_entry(pos, struct mipv6_sorted_list_entry, list);
+		if (sortkey >= entry->sortkey) {
+			list_add(entry_pos, &entry->list);
+			return;
+		}
+	}
+
+	list_add(entry_pos, head);
+}
+
+/**
+ * mipv6_slist_modify - modify data item
+ * @head: list_head of the sorted list
+ * @data: item, whose sortkey is to be modified
+ * @datalen: datalen in bytes
+ * @new_key: new sortkey
+ * @compare: function used for comparing the data items
+ *
+ * Compies the new data on top of the old one, if compare function returns
+ * true. If there's no matching entry, new one will be created.
+ * Compare function needs to have prototype
+ * int (*compare)(const void *data1, const void *data2, int datalen)
+ */
+int mipv6_slist_modify(struct list_head *head, void *data, int datalen,
+		       unsigned long new_key,
+		       int (*compare)(const void *data1, const void *data2,
+				      int datalen))
+{
+	struct list_head *pos;
+	struct mipv6_sorted_list_entry *entry;
+
+	for (pos = head->next; pos != head; pos = pos->next) {
+		entry = list_entry(pos, struct mipv6_sorted_list_entry, list);
+		if (compare(data, entry->data, datalen)) {
+			memcpy(entry->data, data, datalen);
+			entry->sortkey = new_key;
+			reorder_entry(head, &entry->list, new_key);
+			return 0;
+		}
+	}
+
+	return mipv6_slist_add(head, data, datalen, new_key);
+}
+
+/**
+ * mipv6_slist_push_first - move the first entry to place indicated by new_key
+ * @head: list_head of the sorted list
+ * @new_key: new sortkey
+ */
+int mipv6_slist_push_first(struct list_head *head, unsigned long new_key)
+{
+	struct mipv6_sorted_list_entry *entry;
+
+	if (list_empty(head))
+		return -1;
+
+	entry = list_entry(head->next, struct mipv6_sorted_list_entry, list);
+	entry->sortkey = new_key;
+
+	reorder_entry(head, head->next, new_key);
+	return 0;
+}
+
+/**
+ * mipv6_slist_for_each - apply func to every item in list
+ * @head: list_head of the sorted list
+ * @args: args to pass to func
+ * @func: function to use
+ *
+ * function must be of type
+ * int (*func)(void *data, void *args, unsigned long sortkey)
+ * List iteration will stop once func has been applied to every item
+ * or when func returns true
+ */
+int mipv6_slist_for_each(struct list_head *head, void *args,
+			 int (*func)(void *data, void *args,
+				     unsigned long sortkey))
+{
+	struct list_head *pos;
+	struct mipv6_sorted_list_entry *entry;
+
+	list_for_each(pos, head) {
+		entry = list_entry(pos, struct mipv6_sorted_list_entry, list);
+		if (func(entry->data, args, entry->sortkey))
+			break;
+	}
+
+	return 0;
+}
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/sortedlist.h linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/sortedlist.h
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/sortedlist.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/sortedlist.h	2003-05-18 11:33:53.000000000 +0200
@@ -0,0 +1,136 @@
+/**
+ * Sorted list - linked list with sortkey
+ *
+ * Authors:
+ * Jaakko Laine <medved@iki.fi>
+ *
+ * $Id: s.sortedlist.h 1.4 02/08/16 08:25:10-00:00 jola $
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+/**
+ * compare - compares two arbitrary data items
+ * @data1: first data item
+ * @data2: second data item
+ * @datalen: length of data items in bits
+ *
+ * datalen is in bits!
+ */
+int mipv6_bitwise_compare(const void *data1, const void *data2, int datalen);
+
+/**
+ * mipv6_slist_add - add an entry to sorted list
+ * @head: list_head of the sorted list
+ * @data: item to store
+ * @datalen: length of data (in bytes)
+ * @key: sortkey of item
+ *
+ * Allocates memory for entry and data
+ */
+int mipv6_slist_add(struct list_head *head, void *data, int datalen,
+		    unsigned long sortkey);
+
+/**
+ * mipv6_slist_get_first - get the first data item in the list
+ * @head: list_head of the sorted list
+ *
+ * Returns the actual data item, not copy, so don't kfree it
+ */
+void *mipv6_slist_get_first(struct list_head *head);
+
+/**
+ * mipv6_slist_del_first - delete (and get) the first item in list
+ * @head: list_head of the sorted list
+ *
+ * Remember to kfree the item
+ */
+void *mipv6_slist_del_first(struct list_head *head);
+
+/**
+ * mipv6_slist_del_item - delete entry
+ * @head: list_head of the sorted list
+ * @data: item to delete
+ * @compare: function used for comparing the data items
+ *
+ * compare function needs to have prototype
+ * int (*compare)(const void *data1, const void *data2, int datalen) where
+ * datalen is in bits
+ */
+int mipv6_slist_del_item(struct list_head *head, void *data,
+			 int (*compare)(const void *data1, const void *data2,
+					int datalen));
+
+/**
+ * mipv6_slist_get_first_key - get sortkey of the first item
+ * @head: list_head of the sorted list
+ */
+unsigned long mipv6_slist_get_first_key(struct list_head *head);
+
+/**
+ * mipv6_slist_get_key - get sortkey of the data item
+ * @head: list_head of the sorted list
+ * @data: the item to search for
+ * @compare: function used for comparing the data items
+ *
+ * compare function needs to have prototype
+ * int (*compare)(const void *data1, const void *data2, int datalen) where
+ * datalen is in bits
+ */
+unsigned long mipv6_slist_get_key(struct list_head *head, void *data,
+				  int (*compare)(const void *data1,
+						 const void *data2,
+						 int datalen));
+
+/**
+ * mipv6_slist_get_data - get the data item identified by sortkey
+ * @head: list_head of the sorted list
+ * @key: sortkey of the item
+ *
+ * Returns the actual data item, not copy, so don't kfree it
+ */
+void *mipv6_slist_get_data(struct list_head *head, unsigned long sortkey);
+
+/**
+ * mipv6_slist_modify - modify data item
+ * @head: list_head of the sorted list
+ * @data: item, whose sortkey is to be modified
+ * @datalen: datalen in bytes
+ * @new_key: new sortkey
+ * @compare: function used for comparing the data items
+ *
+ * Compies the new data on top of the old one, if compare function returns
+ * non-negative. If there's no matching entry, new one will be created.
+ * Compare function needs to have prototype
+ * int (*compare)(const void *data1, const void *data2, int datalen) where
+ * datalen is in bits.
+ */
+int mipv6_slist_modify(struct list_head *head, void *data, int datalen,
+		       unsigned long new_key,
+		       int (*compare)(const void *data1, const void *data2,
+				      int datalen));
+
+/**
+ * mipv6_slist_push_first - move the first entry to place indicated by new_key
+ * @head: list_head of the sorted list
+ * @new_key: new sortkey
+ */
+int mipv6_slist_push_first(struct list_head *head, unsigned long new_key);
+
+/**
+ * mipv6_slist_for_each - apply func to every item in list
+ * @head: list_head of the sorted list
+ * @args: args to pass to func
+ * @func: function to use
+ *
+ * function must be of type
+ * int (*func)(void *data, void *args, unsigned long sortkey)
+ * List iteration will stop once func has been applied to every item
+ * or when func returns true
+ */
+int mipv6_slist_for_each(struct list_head *head, void *args,
+			 int (*func)(void *data, void *args,
+				     unsigned long sortkey));
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/stats.c linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/stats.c
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/stats.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/stats.c	2003-05-18 11:33:53.000000000 +0200
@@ -0,0 +1,81 @@
+/*
+ *      Statistics module
+ *
+ *      Authors:
+ *      Sami Kivisaari          <skivisaa@cc.hut.fi>
+ *
+ *      $Id: s.stats.c 1.11 02/10/15 13:53:09+03:00 antti@traci.mipl.mediapoli.com $
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ *     
+ *      Changes:
+ *      Krishna Kumar, 
+ *      Venkata Jagana   :  SMP locking fix  
+ */
+
+#include <linux/config.h>
+#include <linux/proc_fs.h>
+#include "stats.h"
+
+struct mipv6_statistics mipv6_stats;
+
+static int proc_info_dump(
+	char *buffer, char **start,
+	off_t offset, int length)
+{
+	struct inf {
+		char *name;
+		int *value;
+	} int_stats[] = {
+		{"NEncapsulations", &mipv6_stats.n_encapsulations},
+		{"NDecapsulations", &mipv6_stats.n_decapsulations},
+		{"NBindUpdatesRcvd", &mipv6_stats.n_bu_rcvd},
+		{"NBindAcksRcvd", &mipv6_stats.n_ba_rcvd},
+		{"NBindNAcksRcvd", &mipv6_stats.n_ban_rcvd},
+		{"NBindRqsRcvd", &mipv6_stats.n_brr_rcvd},
+		{"NBindUpdatesSent", &mipv6_stats.n_bu_sent},
+		{"NBindAcksSent", &mipv6_stats.n_ba_sent},
+		{"NBindNAcksSent", &mipv6_stats.n_ban_sent},
+		{"NBindRqsSent", &mipv6_stats.n_brr_sent},
+		{"NBindUpdatesDropAuth", &mipv6_stats.n_bu_drop.auth},
+		{"NBindUpdatesDropInvalid", &mipv6_stats.n_bu_drop.invalid},
+		{"NBindUpdatesDropMisc", &mipv6_stats.n_bu_drop.misc},
+		{"NBindAcksDropAuth", &mipv6_stats.n_bu_drop.auth},
+		{"NBindAcksDropInvalid", &mipv6_stats.n_bu_drop.invalid},
+		{"NBindAcksDropMisc", &mipv6_stats.n_bu_drop.misc},
+		{"NBindRqsDropAuth", &mipv6_stats.n_bu_drop.auth},
+		{"NBindRqsDropInvalid", &mipv6_stats.n_bu_drop.invalid},
+		{"NBindRqsDropMisc", &mipv6_stats.n_bu_drop.misc}
+	};
+
+	int i;
+	int len = 0;
+	for(i=0; i<sizeof(int_stats) / sizeof(struct inf); i++) {
+		len += sprintf(buffer + len, "%s = %d\n",
+			       int_stats[i].name, *int_stats[i].value);
+	}
+
+	*start = buffer + offset;
+
+	len -= offset;
+
+	if(len > length) len = length;
+
+	return len;
+}
+
+int mipv6_stats_init(void)
+{
+	memset(&mipv6_stats, 0, sizeof(struct mipv6_statistics));
+	proc_net_create("mip6_stat", 0, proc_info_dump);
+	return 0;
+}
+
+void mipv6_stats_exit(void)
+{
+	proc_net_remove("mip6_stat");
+}
+
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/stats.h linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/stats.h
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/stats.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/stats.h	2003-05-18 11:33:53.000000000 +0200
@@ -0,0 +1,64 @@
+/*
+ *      Statistics module header file
+ *
+ *      Authors:
+ *      Sami Kivisaari          <skivisaa@cc.hut.fi>
+ *
+ *      $Id: s.stats.h 1.8 02/10/15 13:53:09+03:00 antti@traci.mipl.mediapoli.com $
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef _STATS_H
+#define _STATS_H
+
+struct mipv6_drop {
+	__u32 auth;
+	__u32 invalid;
+	__u32 misc;
+};
+
+struct mipv6_statistics {
+	int n_encapsulations;
+	int n_decapsulations;
+	int n_mh_in_msg;
+	int n_mh_in_error;
+	int n_mh_out_msg;
+	int n_mh_out_error;
+
+        int n_bu_rcvd;
+        int n_ba_rcvd;
+	int n_ban_rcvd;
+        int n_brr_rcvd;
+	int n_be_rcvd;
+        int n_ha_rcvd;
+        int n_bu_sent;
+        int n_ba_sent;
+	int n_ban_sent;
+        int n_brr_sent;
+	int n_be_sent;
+        int n_ha_sent;
+	struct mipv6_drop n_bu_drop;
+	struct mipv6_drop n_ba_drop;
+	struct mipv6_drop n_brr_drop;
+	struct mipv6_drop n_be_drop;
+	struct mipv6_drop n_ha_drop;
+};
+
+extern struct mipv6_statistics mipv6_stats;
+
+#ifdef CONFIG_SMP
+/* atomic_t is max 24 bits long */
+#define MIPV6_INC_STATS(X) atomic_inc((atomic_t *)&mipv6_stats.X);
+#else
+#define MIPV6_INC_STATS(X) mipv6_stats.X++;
+#endif
+
+int mipv6_stats_init(void);
+void mipv6_stats_exit(void);
+
+#endif
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/tunnel.c linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/tunnel.c
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/tunnel.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/tunnel.c	2003-05-18 11:33:53.000000000 +0200
@@ -0,0 +1,363 @@
+/*
+ *	IPv6-IPv6 tunneling module
+ *
+ *	Authors:
+ *	Sami Kivisaari		<skivisaa@cc.hut.fi>
+ *	Ville Nuorvala          <vnuorval@tml.hut.fi>
+ *
+ *	$Id: s.tunnel.c 1.31 02/10/16 00:31:21+03:00 vnuorval@eric.hut.mediapoli.com $
+ *
+ *	This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/net.h>
+#include <linux/skbuff.h>
+#include <linux/ipv6.h>
+#include <linux/net.h>
+#include <linux/netdevice.h>
+#include <linux/init.h>
+#include <linux/route.h>
+#include <linux/ipv6_route.h>
+
+#ifdef CONFIG_SYSCTL
+#include <linux/sysctl.h>
+#endif /* CONFIG_SYSCTL */
+
+#include <net/protocol.h>
+#include <net/ipv6.h>
+#include <net/ip6_route.h>
+#include <net/dst.h>
+#include <net/addrconf.h>
+#include <net/ipv6_tunnel.h>
+#include "tunnel.h"
+#include "debug.h"
+#include "util.h"
+#include "stats.h"
+
+#define MIPV6_TNL_MAX IPV6_TNL_MAX
+#define MIPV6_TNL_MIN 1
+
+int mipv6_max_tnls = 3;
+int mipv6_min_tnls = 1;
+
+DECLARE_MUTEX(tnl_sem);
+
+int mipv6_max_tnls_sysctl(ctl_table *ctl, int write, struct file *filp,
+			  void *buffer, size_t *lenp)
+{
+	int err;
+	
+	DEBUG_FUNC();
+
+	down(&tnl_sem);
+	if (write) {
+		int diff;
+		int old_max_tnls = mipv6_max_tnls;
+		err = proc_dointvec(ctl, write, filp, buffer, lenp);
+		if (err < 0) 
+			goto out;
+		if (mipv6_max_tnls < mipv6_min_tnls || 
+		    mipv6_max_tnls > MIPV6_TNL_MAX) {
+			mipv6_max_tnls = old_max_tnls;
+			goto out;
+		}
+		if (mipv6_max_tnls < old_max_tnls) {
+			diff = old_max_tnls - mipv6_max_tnls;
+			ipv6_ipv6_tnl_dec_max_kdev_count(diff);
+		} else if (mipv6_max_tnls > old_max_tnls) {
+			diff = mipv6_max_tnls - old_max_tnls;
+			ipv6_ipv6_tnl_inc_max_kdev_count(diff);
+		}
+	} else {
+		err = proc_dointvec(ctl, write, filp, buffer, lenp);
+	}
+out:
+	up(&tnl_sem);
+	return err;
+}
+
+int mipv6_min_tnls_sysctl(ctl_table *ctl, int write, struct file *filp,
+			  void *buffer, size_t *lenp)
+{
+	int err;
+
+	DEBUG_FUNC();
+
+	down(&tnl_sem);
+	if (write) {
+		int diff;
+		int old_min_tnls = mipv6_min_tnls;
+		err = proc_dointvec(ctl, write, filp, buffer, lenp);
+		if (err < 0) 
+			goto out;
+		if (mipv6_min_tnls > mipv6_max_tnls || 
+		    mipv6_min_tnls < MIPV6_TNL_MIN) {
+			mipv6_min_tnls = old_min_tnls;
+			goto out;
+		}
+		if (mipv6_min_tnls < old_min_tnls) {
+			diff = old_min_tnls - mipv6_min_tnls;
+			ipv6_ipv6_tnl_dec_min_kdev_count(diff);
+		} else if (mipv6_min_tnls > old_min_tnls) {
+			diff = mipv6_min_tnls - old_min_tnls;
+			ipv6_ipv6_tnl_inc_min_kdev_count(diff);
+		}
+	} else {
+		err = proc_dointvec(ctl, write, filp, buffer, lenp);
+	}
+out:
+	up(&tnl_sem);
+	return err;
+}
+
+__init void mipv6_initialize_tunnel(void)
+{
+	down(&tnl_sem);
+	ipv6_ipv6_tnl_inc_max_kdev_count(mipv6_max_tnls);
+	ipv6_ipv6_tnl_inc_min_kdev_count(mipv6_min_tnls);
+	up(&tnl_sem);
+}
+
+__exit void mipv6_shutdown_tunnel(void)
+{
+	down(&tnl_sem);
+	ipv6_ipv6_tnl_dec_min_kdev_count(mipv6_min_tnls);
+	ipv6_ipv6_tnl_dec_max_kdev_count(mipv6_max_tnls);
+	up(&tnl_sem);
+}
+
+static int tnl_add(struct in6_addr *remote, 
+		   struct in6_addr *local, 
+		   int local_origin) 
+{
+	struct ipv6_tnl_parm p;
+	int ret;
+
+	DEBUG_FUNC();
+
+ 	memset(&p, 0, sizeof(p));
+	p.proto = IPPROTO_IPV6;
+	ipv6_addr_copy(&p.laddr, local);
+	ipv6_addr_copy(&p.raddr, remote);
+	p.hop_limit = -1;
+	p.flags = (IPV6_TNL_F_KERNEL_DEV | IPV6_TNL_F_MIPV6_DEV |
+		   IPV6_TNL_F_IGN_ENCAP_LIMIT | 
+		   (local_origin ? IPV6_TNL_F_ALLOW_LOCAL : 0));
+
+	ret = ipv6_ipv6_kernel_tnl_add(&p);
+	if (ret > 0) {
+		DEBUG(DBG_INFO, "added tunnel from: "
+		      "%x:%x:%x:%x:%x:%x:%x:%x to: %x:%x:%x:%x:%x:%x:%x:%x", 
+		      NIPV6ADDR(local), NIPV6ADDR(remote));
+	} else {
+		DEBUG(DBG_WARNING, "unable to add tunnel from: "
+		      "%x:%x:%x:%x:%x:%x:%x:%x to: %x:%x:%x:%x:%x:%x:%x:%x", 
+		      NIPV6ADDR(local), NIPV6ADDR(remote));		
+	}
+	return ret;
+}
+
+static int tnl_del(struct in6_addr *remote, 
+		   struct in6_addr *local) 
+{
+	struct ipv6_tnl *t = ipv6_ipv6_tnl_lookup(remote, local);
+	
+	DEBUG_FUNC();
+	
+	if (t != NULL && (t->parms.flags & IPV6_TNL_F_MIPV6_DEV)) {
+		DEBUG(DBG_INFO, "deleting tunnel from: "
+		      "%x:%x:%x:%x:%x:%x:%x:%x to: %x:%x:%x:%x:%x:%x:%x:%x", 
+		      NIPV6ADDR(local), NIPV6ADDR(remote));
+
+		return ipv6_ipv6_kernel_tnl_del(t);
+	}
+	return 0;
+}
+
+static __inline__ int add_route_to_mn(struct in6_addr *coa, 
+				      struct in6_addr *ha_addr, 
+				      struct in6_addr *home_addr) 
+{
+	struct in6_rtmsg rtmsg;
+	int err;
+	struct ipv6_tnl *t = ipv6_ipv6_tnl_lookup(coa, ha_addr);
+	
+	if (!is_mipv6_tnl(t)) {
+		DEBUG(DBG_CRITICAL,"Tunnel missing");
+		return -ENODEV;
+	}
+	
+	DEBUG(DBG_INFO, "adding route to: %x:%x:%x:%x:%x:%x:%x:%x via "
+	      "tunnel device", NIPV6ADDR(home_addr));
+
+	memset(&rtmsg, 0, sizeof(rtmsg));
+	ipv6_addr_copy(&rtmsg.rtmsg_dst, home_addr);
+	rtmsg.rtmsg_dst_len = 128;
+	rtmsg.rtmsg_type = RTMSG_NEWROUTE;
+	rtmsg.rtmsg_flags = RTF_UP | RTF_NONEXTHOP | RTF_HOST;
+	rtmsg.rtmsg_ifindex = t->dev->ifindex;
+	rtmsg.rtmsg_metric = IP6_RT_PRIO_MIPV6;
+	if ((err = ip6_route_add(&rtmsg)) == -EEXIST) {
+		err = 0;
+	}
+	return err;
+}
+
+
+extern int ip6_route_del(struct in6_rtmsg *rtmsg);
+
+static __inline__ void del_route_to_mn(struct in6_addr *coa, 
+				       struct in6_addr *ha_addr, 
+				       struct in6_addr *home_addr) 
+{
+	struct ipv6_tnl *t = ipv6_ipv6_tnl_lookup(coa, ha_addr);
+
+	DEBUG_FUNC();
+
+	if (is_mipv6_tnl(t)) {
+		struct in6_rtmsg rtmsg;
+
+		DEBUG(DBG_INFO, "deleting route to: %x:%x:%x:%x:%x:%x:%x:%x "
+		      " via tunnel device", NIPV6ADDR(home_addr));
+
+		memset(&rtmsg, 0, sizeof(rtmsg));
+		ipv6_addr_copy(&rtmsg.rtmsg_dst, home_addr);
+		rtmsg.rtmsg_dst_len = 128;
+		rtmsg.rtmsg_ifindex = t->dev->ifindex;
+		rtmsg.rtmsg_metric = IP6_RT_PRIO_MIPV6;
+		ip6_route_del(&rtmsg);
+	}
+}
+
+
+int mipv6_add_tnl_to_mn(struct in6_addr *coa, 
+			struct in6_addr *ha_addr,
+			struct in6_addr *home_addr)
+{
+	int ret;
+
+	DEBUG_FUNC();
+
+	ret = tnl_add(coa, ha_addr, 1);
+
+	if (ret > 0) {
+		int err = add_route_to_mn(coa, ha_addr, home_addr);
+		if (err) {
+			if (err != -ENODEV) {
+				tnl_del(coa, ha_addr);
+			}
+			return err;
+		}
+	}
+	return ret;
+} 
+
+int mipv6_del_tnl_to_mn(struct in6_addr *coa, 
+			struct in6_addr *ha_addr,
+			struct in6_addr *home_addr)
+{
+	DEBUG_FUNC();
+	del_route_to_mn(coa, ha_addr, home_addr);
+	return tnl_del(coa, ha_addr);
+} 
+
+static __inline__ int add_reverse_route(struct in6_addr *ha_addr,
+					struct in6_addr *coa,
+					struct in6_addr *home_addr) 
+{
+	struct in6_rtmsg rtmsg;
+	int ret;
+	struct ipv6_tnl *t;
+
+	DEBUG_FUNC();
+
+	t = ipv6_ipv6_tnl_lookup(ha_addr, coa);	
+	
+	if (!is_mipv6_tnl(t)) {
+		DEBUG(DBG_CRITICAL, "Tunnel missing");
+		return -ENODEV;
+	}
+	
+	DEBUG(DBG_INFO, "adding reverse route via tunnel device");
+	
+	memset(&rtmsg, 0, sizeof(rtmsg));
+	rtmsg.rtmsg_type = RTMSG_NEWROUTE;
+	ipv6_addr_copy(&rtmsg.rtmsg_src, home_addr);
+	rtmsg.rtmsg_src_len = 128;
+	rtmsg.rtmsg_flags = RTF_UP | RTF_DEFAULT;
+	rtmsg.rtmsg_ifindex = t->dev->ifindex;
+	rtmsg.rtmsg_metric = IP6_RT_PRIO_MIPV6;
+	if ((ret = ip6_route_add(&rtmsg)) == -EEXIST) {
+		DEBUG(DBG_INFO, "add_reverse_route: route exists");
+		return 0;
+	}
+	return ret;	
+}
+
+static __inline__ void del_reverse_route(struct in6_addr *ha_addr, 
+					 struct in6_addr *coa, 
+					 struct in6_addr *home_addr) 
+{
+	struct ipv6_tnl *t = ipv6_ipv6_tnl_lookup(ha_addr, coa);
+
+	DEBUG_FUNC();
+
+	if (is_mipv6_tnl(t)) {
+		struct in6_rtmsg rtmsg;
+
+		DEBUG(DBG_INFO, "removing reverse route via tunnel device");
+	
+		memset(&rtmsg, 0, sizeof(rtmsg));
+		ipv6_addr_copy(&rtmsg.rtmsg_src, home_addr);
+		rtmsg.rtmsg_src_len = 128;
+		rtmsg.rtmsg_ifindex = t->dev->ifindex;
+		rtmsg.rtmsg_metric = IP6_RT_PRIO_MIPV6;
+		ip6_route_del(&rtmsg);
+	}
+}
+
+int mipv6_add_tnl_to_ha(struct in6_addr *ha_addr, 
+			struct in6_addr *coa,
+			struct in6_addr *home_addr)
+{
+	int ret;
+	
+	DEBUG_FUNC();
+	
+	if (!ipv6_addr_cmp(home_addr, coa)) {
+		return 1;
+	}
+	
+	ret = tnl_add(ha_addr, coa, 1);
+
+	if (ret >= 1) {
+		int err = add_reverse_route(ha_addr, coa, home_addr);
+		
+		if (err) { 
+			if (err != -ENODEV) {
+				tnl_del(ha_addr, coa);
+			}
+			ret = err;
+		}
+	}
+	return ret;
+} 
+
+int mipv6_del_tnl_to_ha(struct in6_addr *ha_addr, 
+			struct in6_addr *coa,
+			struct in6_addr *home_addr)
+{
+	DEBUG_FUNC();
+
+	if (!ipv6_addr_cmp(home_addr, coa)) {
+		return 0;
+	}
+	
+	del_reverse_route(ha_addr, coa, home_addr);
+
+	return tnl_del(ha_addr, coa);
+} 
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/tunnel.h linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/tunnel.h
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/tunnel.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/tunnel.h	2003-05-18 11:33:53.000000000 +0200
@@ -0,0 +1,61 @@
+/*
+ *      IPv6-IPv6 tunneling header file
+ *
+ *      Authors:
+ *      Sami Kivisaari          <skivisaa@cc.hut.fi>
+ *
+ *      $Id: s.tunnel.h 1.12 02/10/16 00:31:21+03:00 vnuorval@eric.hut.mediapoli.com $
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef _TUNNEL_H
+#define _TUNNEL_H
+
+#include <linux/in6.h>
+#include <linux/if_arp.h>
+#include <net/ipv6_tunnel.h>
+
+extern int mipv6_max_tnls;
+extern int mipv6_min_tnls;
+
+extern void mipv6_initialize_tunnel(void);
+extern void mipv6_shutdown_tunnel(void);
+
+extern int mipv6_add_tnl_to_mn(struct in6_addr *coa, 
+			       struct in6_addr *ha_addr,
+			       struct in6_addr *home_addr);
+
+extern int mipv6_del_tnl_to_mn(struct in6_addr *coa, 
+			       struct in6_addr *ha_addr,
+			       struct in6_addr *home_addr);
+
+extern int mipv6_add_tnl_to_ha(struct in6_addr *ha_addr, 
+			       struct in6_addr *coa,
+			       struct in6_addr *home_addr);
+
+extern int mipv6_del_tnl_to_ha(struct in6_addr *ha_addr, 
+			       struct in6_addr *coa,
+			       struct in6_addr *home_addr);
+
+static __inline__ int is_mipv6_tnl(struct ipv6_tnl *t)
+{
+	return (t != NULL && 
+		t->parms.flags & IPV6_TNL_F_KERNEL_DEV &&
+		t->parms.flags & IPV6_TNL_F_MIPV6_DEV);
+			
+}
+
+static __inline__ int dev_is_mipv6_tnl(struct net_device *dev)
+{
+	struct ipv6_tnl *t = (struct ipv6_tnl *)dev->priv;
+	return (dev->type == ARPHRD_IPV6_IPV6_TUNNEL && is_mipv6_tnl(t));
+}
+
+
+#endif
+
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/util.c linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/util.c
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/util.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/util.c	2003-05-18 11:33:53.000000000 +0200
@@ -0,0 +1,140 @@
+/*
+ *      Mobile IPv6 Utility functions
+ *
+ *      Authors:
+ *      Sami Kivisaari          <skivisaa@cc.hut.fi>
+ *      Antti Tuominen          <ajtuomin@tml.hut.fi>
+ *
+ *      $Id: s.util.c 1.5 02/10/04 13:54:10+03:00 antti@traci.mipl.mediapoli.com $
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/in6.h>
+#include <asm/byteorder.h>
+
+const struct in6_addr in6addr_any = { { { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } } };
+const struct in6_addr in6addr_loopback = { { { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1 } } };
+/**
+ * mipv6_prefix_compare - Compare two IPv6 prefixes
+ * @addr: IPv6 address
+ * @prefix: IPv6 address
+ * @nprefix: number of bits to compare
+ *
+ * Perform prefix comparison bitwise for the @nprefix first bits
+ * Returns 1, if the prefixes are the same, 0 otherwise 
+ **/
+int mipv6_prefix_compare(struct in6_addr *addr,
+			 struct in6_addr *prefix, unsigned int nprefix)
+{
+	int i;
+
+	if (nprefix > 128)
+		return 0;
+
+	for (i = 0; nprefix > 0; nprefix -= 32, i++) {
+		if (nprefix >= 32) {
+			if (addr->s6_addr32[i] != prefix->s6_addr32[i])
+				return 0;
+		} else {
+			if (((addr->s6_addr32[i] ^ prefix->s6_addr32[i]) &
+			     ((~0) << (32 - nprefix))) != 0)
+				return 0;
+			return 1;
+		}
+	}
+
+	return 1;
+}
+
+/**
+ * mipv6_suffix_compare - Compare two IPv6 prefixes
+ * @addr: IPv6 address
+ * @suffix: IPv6 address
+ * @nsuffix: number of bits to compare
+ *
+ * Perform suffix comparison bitwise for the @nsuffix last bits
+ **/
+int mipv6_suffix_compare(struct in6_addr *addr,
+			 struct in6_addr *suffix, unsigned int nsuffix)
+{
+	int i;
+
+	if (nsuffix > 128)
+		return 0;
+
+	for (i = 3; nsuffix > 0; nsuffix -= 32, i--) {
+		if (nsuffix >= 32) {
+			if (addr->s6_addr32[i] != suffix->s6_addr32[i])
+				return 0;
+		} else {
+			if (((addr->s6_addr32[i] ^ suffix->s6_addr32[i]) &
+			     ((~0) << nsuffix)) != 0)
+				return 0;
+			return 1;
+		}
+	}
+
+	return 1;
+}
+
+/**
+ * homeagent_anycast - Compute Home Agent anycast address
+ * @ha_anycast: append home agent anycast suffix to passed prefix
+ * @plen: length of prefix in bits
+ *
+ * Calculate corresponding Home Agent Anycast Address (RFC2526) in a
+ * given subnet.
+ */
+int homeagent_anycast(struct in6_addr *ha_anycast, int plen)
+{
+	if (plen > 120) {
+		/* error, interface id should be minimum 8 bits */
+		return -1;
+	}
+
+	if (plen < 32)
+		ha_anycast->s6_addr32[0] |= htonl((u32)(~0) >> plen);
+	if (plen < 64)
+		ha_anycast->s6_addr32[1] |= htonl((u32)(~0) >> (plen > 32 ? plen % 32 : 0));
+	if (plen < 92)
+		ha_anycast->s6_addr32[2] |= htonl((u32)(~0) >> (plen > 64 ? plen % 32 : 0));
+	if (plen <= 120)
+		ha_anycast->s6_addr32[3] |= htonl((u32)(~0) >> (plen > 92 ? plen % 32 : 0));
+
+	/* RFC2526: for interface identifiers in EUI-64
+	 * format, the universal/local bit in the interface
+	 * identifier MUST be set to 0. */
+	ha_anycast->s6_addr32[2] &= (int)htonl(0xfdffffff);
+
+	/* Mobile IPv6 Home-Agents anycast id (0x7e) */
+	ha_anycast->s6_addr32[3] &= (int)htonl(0xffffff80 | 0x7e);
+
+	return 0;
+}
+
+int modGT65536(__u16 x, __u16 y)
+{
+	__u16 z;
+	
+	z = y + (__u16)0x8000;           /* Forward window from y */
+	if (z > y)                       /* Overflow(z) = False   */
+		return ((x>y) && (x<=z));
+	else                             /* Overflow(z) = True    */
+		return ((x>y) || (x<=z));
+}
+
+int modGT256(__u8 x, __u8 y)
+{
+	__u8 z;
+	
+	z = y + (__u8)0x80;              /* Forward window from y */
+	if (z > y)                       /* Overflow(z) = False   */
+		return ((x>y) && (x<=z));
+	else                             /* Overflow(z) = True    */
+		return ((x>y) || (x<=z));
+}
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/util.h linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/util.h
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/mobile_ip6/util.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/mobile_ip6/util.h	2003-05-18 11:33:53.000000000 +0200
@@ -0,0 +1,74 @@
+/*
+ *      Mobile IPv6 Utility functions
+ *
+ *      Authors:
+ *      Sami Kivisaari          <skivisaa@cc.hut.fi>
+ *      Antti Tuominen          <ajtuomin@tml.hut.fi>
+ *
+ *      $Id: s.util.h 1.9 02/10/04 13:54:10+03:00 antti@traci.mipl.mediapoli.com $
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef _UTIL_H
+#define _UTIL_H
+
+extern const struct in6_addr in6addr_any;
+extern const struct in6_addr in6addr_loopback;
+
+/* Support for pre 2.4.10 kernels */
+#ifndef min_t
+#define min_t(type,x,y) \
+        ({ type __x = (x); type __y = (y); __x < __y ? __x: __y; })
+#endif
+#ifndef max_t
+#define max_t(type,x,y) \
+        ({ type __x = (x); type __y = (y); __x > __y ? __x: __y; })
+#endif
+
+/**
+ * NIPV6ADDR - macro for IPv6 addresses
+ * @addr: Network byte order IPv6 address
+ *
+ * Macro for printing IPv6 addresses.  Used in conjunction with
+ * printk() or derivatives (such as DEBUG macro).
+ **/
+#define NIPV6ADDR(addr) \
+        ntohs(((u16 *)addr)[0]), \
+        ntohs(((u16 *)addr)[1]), \
+        ntohs(((u16 *)addr)[2]), \
+        ntohs(((u16 *)addr)[3]), \
+        ntohs(((u16 *)addr)[4]), \
+        ntohs(((u16 *)addr)[5]), \
+        ntohs(((u16 *)addr)[6]), \
+        ntohs(((u16 *)addr)[7])
+
+int mipv6_prefix_compare(struct in6_addr *addr,
+			 struct in6_addr *prefix, unsigned int nprefix);
+
+int mipv6_suffix_compare(struct in6_addr *addr,
+			 struct in6_addr *suffix, unsigned int nsuffix);
+
+int homeagent_anycast(struct in6_addr *ha_anycast, int plen);
+
+int modGT65536(__u16 x, __u16 y);
+int modGT256(__u8 x, __u8 y);
+
+#define SEQMOD(x,y) modGT256(x,y)
+
+#define MOD256GT(x,y) \
+        ((char)(((__u8)(x)) - ((__u8)(y))) > 0)
+
+#define MOD65536(x,y) \
+        ((short int)(((__u16)(x)) - ((__u16)(y))) > 0)
+
+struct in6_addr_pair {
+	struct in6_addr *a1;
+	struct in6_addr *a2;
+};
+
+#endif /* _UTIL_H */
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/ndisc.c linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/ndisc.c
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/ndisc.c	2003-05-03 02:33:36.000000000 +0200
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/ndisc.c	2003-05-18 11:33:53.000000000 +0200
@@ -23,6 +23,8 @@
  *						and moved to net/core.
  *	Pekka Savola			:	RFC2461 validation
  *	YOSHIFUJI Hideaki @USAGI	:	Verify ND options properly
+ *	Ville Nuorvala			:	proxy offers protection
+ *						against DAD
  */
 
 /* Set to 3 to get tracing... */
@@ -71,6 +73,7 @@
 #include <net/ip6_route.h>
 #include <net/addrconf.h>
 #include <net/icmp.h>
+#include <net/mipglue.h>
 
 #include <net/checksum.h>
 #include <linux/proc_fs.h>
@@ -201,6 +204,10 @@
 			if (ndopts->nd_opt_array[nd_opt->nd_opt_type] == 0)
 				ndopts->nd_opt_array[nd_opt->nd_opt_type] = nd_opt;
 			break;
+		case ND_OPT_RTR_ADV_INTERVAL:
+		case ND_OPT_HOME_AGENT_INFO:
+			/* These two are handled by the MIPv6 code */
+			break;
 		default:
 			/*
 			 * Unknown options must be silently ignored,
@@ -566,6 +573,9 @@
 	struct in6_addr *target = (struct in6_addr *)&neigh->primary_key;
 	int probes = atomic_read(&neigh->probes);
 
+	if (ndisc_mipv6_mn_solicit_ha(dev, target))
+		return;
+
 	if (skb && ipv6_chk_addr(&skb->nh.ipv6h->saddr, dev))
 		saddr = &skb->nh.ipv6h->saddr;
 
@@ -588,6 +598,7 @@
         struct ra_msg *ra_msg = (struct ra_msg *) skb->h.raw;
 	struct neighbour *neigh;
 	struct inet6_dev *in6_dev;
+	int change_rtr;
 	struct rt6_info *rt;
 	int lifetime;
 	struct ndisc_options ndopts;
@@ -617,6 +628,7 @@
 		ND_PRINTK1("RA: can't find in6 device\n");
 		return;
 	}
+	change_rtr = ndisc_mipv6_ra_rcv(skb);
 	if (in6_dev->cnf.forwarding || !in6_dev->cnf.accept_ra) {
 		in6_dev_put(in6_dev);
 		return;
@@ -645,8 +657,7 @@
 		ip6_del_rt(rt);
 		rt = NULL;
 	}
-
-	if (rt == NULL && lifetime) {
+	if (rt == NULL && lifetime && change_rtr) {
 		ND_PRINTK2("ndisc_rdisc: adding default router\n");
 
 		rt = rt6_add_dflt_router(&skb->nh.ipv6h->saddr, skb->dev);
@@ -769,6 +780,8 @@
 	if (rt)
 		dst_release(&rt->u.dst);
 	in6_dev_put(in6_dev);
+
+	ndisc_mipv6_change_router(change_rtr);
 }
 
 static void ndisc_redirect_rcv(struct sk_buff *skb)
@@ -1062,7 +1075,8 @@
       		 *	destination address MUST be a solicited-node multicast address.
 		 */
 
-		if ((ifp = ipv6_get_ifaddr(&msg->target, dev)) != NULL) {
+		if (ndisc_mipv6_mn_may_advertise(&msg->target, saddr) &&
+		    (ifp = ipv6_get_ifaddr(&msg->target, dev)) != NULL) {
 			int addr_type = ipv6_addr_type(saddr);
 
 			if (ifp->flags & IFA_F_TENTATIVE) {
@@ -1133,7 +1147,8 @@
 			int addr_type = ipv6_addr_type(saddr);
 
 			if (in6_dev && in6_dev->cnf.forwarding &&
-			    (addr_type & IPV6_ADDR_UNICAST) &&
+			    ((addr_type & IPV6_ADDR_UNICAST) || 
+			     addr_type == IPV6_ADDR_ANY) &&
 			    pneigh_lookup(&nd_tbl, &msg->target, dev, 0)) {
 				int inc = ipv6_addr_type(daddr)&IPV6_ADDR_MULTICAST;
 
@@ -1146,13 +1161,22 @@
 					else
 						nd_tbl.stats.rcv_probes_ucast++;
 
-					
-					neigh = neigh_event_ns(&nd_tbl, lladdr, saddr, skb->dev);
-
-					if (neigh) {
-						ndisc_send_na(dev, neigh, saddr, &msg->target,
-							      0, 1, 0, 1);
-						neigh_release(neigh);
+					if (addr_type & IPV6_ADDR_UNICAST) {
+						neigh = neigh_event_ns(&nd_tbl, lladdr, saddr, skb->dev);
+						if (neigh) {
+							ndisc_send_na(dev, neigh, 
+								      saddr, 
+								      &msg->target,
+								      0, 1, 0, 1);
+							neigh_release(neigh);
+						}
+					} else {
+						/* the proxy must also 
+						   protect against DAD */
+						struct in6_addr maddr;
+						ipv6_addr_all_nodes(&maddr);
+						ndisc_send_na(dev, NULL, &maddr, &msg->target, 
+							      0, 0, 0, 1);
 					}
 				} else {
 					struct sk_buff *n = skb_clone(skb, GFP_ATOMIC);
@@ -1244,10 +1268,13 @@
 			}
 
 			neigh_update(neigh, lladdr,
-				     msg->icmph.icmp6_solicited ? NUD_REACHABLE : NUD_STALE,
+				     msg->icmph.icmp6_solicited || 
+				     ndisc_mipv6_mn_may_solicit_ha(&msg->target) ?
+				     NUD_REACHABLE : NUD_STALE,
 				     msg->icmph.icmp6_override, 1);
 			neigh_release(neigh);
 		}
+		ndisc_check_mipv6_dad(&msg->target);
 		break;
 	    }
 
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/raw.c linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/raw.c
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/raw.c	2003-05-03 02:36:47.000000000 +0200
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/raw.c	2003-05-18 11:33:53.000000000 +0200
@@ -43,6 +43,7 @@
 #include <net/transp_v6.h>
 #include <net/udp.h>
 #include <net/inet_common.h>
+#include <net/mipglue.h>
 
 #include <net/rawv6.h>
 
@@ -636,6 +637,7 @@
 			hdr.daddr = daddr;
 		else
 			hdr.daddr = NULL;
+		hdr.daddr = mipv6_get_fake_hdr_daddr(hdr.daddr, daddr);
 
 		err = ip6_build_xmit(sk, rawv6_frag_cksum, &hdr, &fl, len,
 				     opt, hlimit, msg->msg_flags);
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/route.c linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/route.c
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/route.c	2003-05-03 01:36:32.000000000 +0200
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/route.c	2003-05-18 11:33:53.000000000 +0200
@@ -361,9 +361,14 @@
 		rt->u.dst.flags |= DST_HOST;
 
 #ifdef CONFIG_IPV6_SUBTREES
-		if (rt->rt6i_src.plen && saddr) {
+		if (saddr) {
 			ipv6_addr_copy(&rt->rt6i_src.addr, saddr);
 			rt->rt6i_src.plen = 128;
+		} else {
+			dst_clone(&rt->u.dst);
+			dst_free((struct dst_entry *) rt);
+			rt->u.dst.error = -EAGAIN;
+			return rt;
 		}
 #endif
 
@@ -1096,6 +1101,11 @@
 			goto out;
 		ipv6_addr_copy(&nrt->rt6i_dst.addr, daddr);
 		nrt->rt6i_dst.plen = 128;
+#ifdef CONFIG_IPV6_SUBTREES
+		ipv6_addr_copy(&nrt->rt6i_src.addr, &rt->rt6i_src.addr);
+		nrt->rt6i_src.plen = rt->rt6i_src.plen;
+		ipv6_wash_prefix(&rt->rt6i_src.addr, rt->rt6i_src.plen);
+#endif
 		nrt->u.dst.flags |= DST_HOST;
 		nrt->rt6i_nexthop = neigh_clone(rt->rt6i_nexthop);
 		dst_set_expires(&nrt->u.dst, ip6_rt_mtu_expires);
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/tcp_ipv6.c linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/tcp_ipv6.c
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/tcp_ipv6.c	2003-05-03 02:36:47.000000000 +0200
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/tcp_ipv6.c	2003-05-18 11:33:53.000000000 +0200
@@ -47,6 +47,7 @@
 #include <net/addrconf.h>
 #include <net/ip6_route.h>
 #include <net/inet_ecn.h>
+#include <net/mipglue.h>
 
 #include <asm/uaccess.h>
 
@@ -531,6 +532,7 @@
 	struct flowi fl;
 	struct dst_entry *dst;
 	int addr_type;
+	int reroute = 0;
 	int err;
 
 	if (addr_len < SIN6_LEN_RFC2133) 
@@ -631,7 +633,7 @@
 
 	fl.proto = IPPROTO_TCP;
 	fl.fl6_dst = &np->daddr;
-	fl.fl6_src = saddr;
+	fl.fl6_src = saddr; 
 	fl.oif = sk->bound_dev_if;
 	fl.uli_u.ports.dport = usin->sin6_port;
 	fl.uli_u.ports.sport = sk->sport;
@@ -640,31 +642,44 @@
 		struct rt0_hdr *rt0 = (struct rt0_hdr *) np->opt->srcrt;
 		fl.nl_u.ip6_u.daddr = rt0->addr;
 	}
-
 	dst = ip6_route_output(sk, &fl);
-
-	if ((err = dst->error) != 0) {
-		dst_release(dst);
-		goto failure;
+#ifdef CONFIG_IPV6_SUBTREES
+	reroute = (dst->error == -EAGAIN);
+#endif
+	if (!reroute) {
+		if ((err = dst->error) != 0) {
+			dst_release(dst);
+			goto failure;
+		}
+		ip6_dst_store(sk, dst, NULL, NULL);
+		sk->route_caps = dst->dev->features&~NETIF_F_IP_CSUM;
 	}
-
-	ip6_dst_store(sk, dst, NULL);
-	sk->route_caps = dst->dev->features&~NETIF_F_IP_CSUM;
-
 	if (saddr == NULL) {
 		err = ipv6_get_saddr(dst, &np->daddr, &saddr_buf);
 		if (err)
 			goto failure;
 
 		saddr = &saddr_buf;
+		ipv6_addr_copy(&np->rcv_saddr, saddr);
+#ifdef CONFIG_IPV6_SUBTREES
+		dst_release(dst);
+		fl.fl6_src = saddr; 
+		dst = ip6_route_output(sk, &fl);
+
+		if ((err = dst->error) != 0) {
+			dst_release(dst);
+			goto failure;
+		}
+		ip6_dst_store(sk, dst, NULL, NULL);
+		sk->route_caps = dst->dev->features&~NETIF_F_IP_CSUM;
+#endif
 	}
 
 	/* set the source address */
-	ipv6_addr_copy(&np->rcv_saddr, saddr);
 	ipv6_addr_copy(&np->saddr, saddr);
 	sk->rcv_saddr= LOOPBACK4_IPV6;
 
-	tp->ext_header_len = 0;
+	tp->ext_header_len = tcp_v6_get_mipv6_header_len();
 	if (np->opt)
 		tp->ext_header_len = np->opt->opt_flen+np->opt->opt_nflen;
 	tp->mss_clamp = IPV6_MIN_MTU - sizeof(struct tcphdr) - sizeof(struct ipv6hdr);
@@ -1309,7 +1324,7 @@
 #endif
 	MOD_INC_USE_COUNT;
 
-	ip6_dst_store(newsk, dst, NULL);
+	ip6_dst_store(newsk, dst, NULL, NULL);
 	sk->route_caps = dst->dev->features&~NETIF_F_IP_CSUM;
 
 	newtp = &(newsk->tp_pinfo.af_tcp);
@@ -1354,7 +1369,7 @@
 			sock_kfree_s(sk, opt, opt->tot_len);
 	}
 
-	newtp->ext_header_len = 0;
+	newtp->ext_header_len = tcp_v6_get_mipv6_header_len();
 	if (np->opt)
 		newtp->ext_header_len = np->opt->opt_nflen + np->opt->opt_flen;
 
@@ -1687,7 +1702,7 @@
 			return err;
 		}
 
-		ip6_dst_store(sk, dst, NULL);
+		ip6_dst_store(sk, dst, NULL, NULL);
 		sk->route_caps = dst->dev->features&~NETIF_F_IP_CSUM;
 	}
 
@@ -1726,7 +1741,7 @@
 			return -sk->err_soft;
 		}
 
-		ip6_dst_store(sk, dst, NULL);
+		ip6_dst_store(sk, dst, NULL, NULL);
 	}
 
 	skb->dst = dst_clone(dst);
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/ipv6/udp.c linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/udp.c
--- linux-2.4.20-wolk4.0-fullkernel/net/ipv6/udp.c	2003-05-03 02:36:47.000000000 +0200
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/ipv6/udp.c	2003-05-18 11:33:53.000000000 +0200
@@ -45,6 +45,7 @@
 #include <net/ip.h>
 #include <net/udp.h>
 #include <net/inet_common.h>
+#include <net/mipglue.h>
 
 #include <net/checksum.h>
 
@@ -213,12 +214,14 @@
 	struct sockaddr_in6	*usin = (struct sockaddr_in6 *) uaddr;
 	struct ipv6_pinfo      	*np = &sk->net_pinfo.af_inet6;
 	struct in6_addr		*daddr;
-	struct in6_addr		saddr;
+	struct in6_addr		*saddr = NULL;
+	struct in6_addr		saddr_buf;
 	struct dst_entry	*dst;
 	struct flowi		fl;
 	struct ip6_flowlabel	*flowlabel = NULL;
 	int			addr_type;
 	int			err;
+	int			reroute = 0;
 
 	if (usin->sin6_family == AF_INET) {
 		err = udp_connect(sk, uaddr, addr_len);
@@ -313,7 +316,7 @@
 
 	fl.proto = IPPROTO_UDP;
 	fl.fl6_dst = &np->daddr;
-	fl.fl6_src = &saddr;
+	fl.fl6_src = saddr;
 	fl.oif = sk->bound_dev_if;
 	fl.uli_u.ports.dport = sk->dport;
 	fl.uli_u.ports.sport = sk->sport;
@@ -330,27 +333,40 @@
 		struct rt0_hdr *rt0 = (struct rt0_hdr *) np->opt->srcrt;
 		fl.fl6_dst = rt0->addr;
 	}
-
 	dst = ip6_route_output(sk, &fl);
-
-	if ((err = dst->error) != 0) {
-		dst_release(dst);
-		fl6_sock_release(flowlabel);
-		return err;
+#ifdef CONFIG_IPV6_SUBTREES
+	reroute = (dst->error == -EAGAIN);
+#endif
+	if (!reroute) {
+		if ((err = dst->error) != 0) {
+			dst_release(dst);
+			fl6_sock_release(flowlabel);
+			return err; 
+		} 
+		ip6_dst_store(sk, dst, fl.fl6_dst, NULL);
 	}
-
-	ip6_dst_store(sk, dst, fl.fl6_dst);
-
 	/* get the source adddress used in the apropriate device */
 
-	err = ipv6_get_saddr(dst, daddr, &saddr);
+	saddr = &saddr_buf;
+	err = ipv6_get_saddr(dst, daddr, saddr);
 
 	if (err == 0) {
+#ifdef CONFIG_IPV6_SUBTREES
+		dst_release(dst);
+		fl.fl6_src = saddr;
+		dst = ip6_route_output(sk, &fl);
+		if ((err = dst->error) != 0) {
+			dst_release(dst);
+			fl6_sock_release(flowlabel);
+			return err; 
+		} 
+		ip6_dst_store(sk, dst, fl.fl6_dst, fl.fl6_dst);
+#endif
 		if(ipv6_addr_any(&np->saddr))
-			ipv6_addr_copy(&np->saddr, &saddr);
+			ipv6_addr_copy(&np->saddr, saddr);
 
 		if(ipv6_addr_any(&np->rcv_saddr)) {
-			ipv6_addr_copy(&np->rcv_saddr, &saddr);
+			ipv6_addr_copy(&np->rcv_saddr, saddr);
 			sk->rcv_saddr = LOOPBACK4_IPV6;
 		}
 		sk->state = TCP_ESTABLISHED;
@@ -869,6 +885,7 @@
 		opt = fl6_merge_options(&opt_space, flowlabel, opt);
 	if (opt && opt->srcrt)
 		udh.daddr = daddr;
+	udh.daddr = mipv6_get_fake_hdr_daddr(udh.daddr, daddr);
 
 	udh.uh.source = sk->sport;
 	udh.uh.len = len < 0x10000 ? htons(len) : 0;
diff -ruN linux-2.4.20-wolk4.0-fullkernel/net/netsyms.c linux-2.4.20-wolk4.0-fullkernel.mipl/net/netsyms.c
--- linux-2.4.20-wolk4.0-fullkernel/net/netsyms.c	2003-05-03 02:36:44.000000000 +0200
+++ linux-2.4.20-wolk4.0-fullkernel.mipl/net/netsyms.c	2003-05-18 11:33:53.000000000 +0200
@@ -187,6 +187,7 @@
 #endif
 EXPORT_SYMBOL(pneigh_lookup);
 EXPORT_SYMBOL(pneigh_enqueue);
+EXPORT_SYMBOL(pneigh_delete);
 EXPORT_SYMBOL(neigh_destroy);
 EXPORT_SYMBOL(neigh_parms_alloc);
 EXPORT_SYMBOL(neigh_parms_release);
